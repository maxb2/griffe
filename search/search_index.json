{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Griffe","text":"<p>  [![ci](https://github.com/mkdocstrings/griffe/workflows/ci/badge.svg)](https://github.com/mkdocstrings/griffe/actions?query=workflow%3Aci) [![documentation](https://img.shields.io/badge/docs-mkdocs%20material-blue.svg?style=flat)](https://mkdocstrings.github.io/griffe/) [![pypi version](https://img.shields.io/pypi/v/griffe.svg)](https://pypi.org/project/griffe/) [![gitpod](https://img.shields.io/badge/gitpod-workspace-blue.svg?style=flat)](https://gitpod.io/#https://github.com/mkdocstrings/griffe) [![gitter](https://badges.gitter.im/join%20chat.svg)](https://gitter.im/mkdocstrings/griffe)  </p> <p></p> <p>Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.</p> <p>Griffe, pronounced \"grif\" (<code>/\u0261\u0281if/</code>), is a french word that means \"claw\", but also \"signature\" in a familiar way. \"On reconna\u00eet bien l\u00e0 sa griffe.\"</p>"},{"location":"#installation","title":"Installation","text":"<p>With <code>pip</code>: <pre><code>pip install griffe\n</code></pre></p> <p>With <code>pipx</code>: <pre><code>python3.7 -m pip install --user pipx\npipx install griffe\n</code></pre></p>"},{"location":"#usage","title":"Usage","text":"<p>On the command line, pass the names of packages to the <code>griffe dump</code> command:</p> <pre><code>$ griffe dump httpx fastapi\n{\n  \"httpx\": {\n    \"name\": \"httpx\",\n    ...\n  },\n  \"fastapi\": {\n    \"name\": \"fastapi\",\n    ...\n  }\n}\n</code></pre> <p>See the Dumping data section for more examples.</p> <p>Or pass a relative path to the <code>griffe check</code> command:</p> <pre><code>$ griffe check mypackage --verbose\nmypackage/mymodule.py:10: MyClass.mymethod(myparam):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n</code></pre> <p>For <code>src</code> layouts:</p> <pre><code>$ griffe check --search src mypackage --verbose\nsrc/mypackage/mymodule.py:10: MyClass.mymethod(myparam):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n</code></pre> <p>See the API breakage section for more examples.</p> <p>With Python, loading a package:</p> <pre><code>import griffe\n\nfastapi = griffe.load(\"fastapi\")\n</code></pre> <p>Finding breaking changes:</p> <pre><code>import griffe\n\nprevious = griffe.load_git(\"mypackage\", ref=\"0.2.0\")\ncurrent = griffe.load(\"mypackage\")\n\nfor breakage in griffe.find_breaking_changes(previous, current):\n    ...\n</code></pre> <p>See the Loading data section for more examples.</p>"},{"location":"#todo","title":"Todo","text":"<ul> <li>Visitor/Inspector:<ul> <li>Merging inherited members into class.     Needs to be able to post-process classes,     and to compute their MRO (C3Linearization, see docspec/pydocspec issues).</li> </ul> </li> <li>Extensions<ul> <li>Post-processing extensions</li> <li>Third-party libraries we could provide support for:<ul> <li>Django support</li> <li>Marshmallow support</li> <li>Pydantic support</li> </ul> </li> </ul> </li> <li>Docstrings parsers<ul> <li>epydoc</li> <li>New Markdown-based format? For graceful degradation</li> </ul> </li> <li>Serializer:<ul> <li>Flat JSON</li> <li>JSON schema</li> </ul> </li> <li>API diff:<ul> <li> Mechanism to cache APIs? Should users version them, or store them somewhere (docs)?</li> <li> Ability to return warnings (things that are not backward-compatibility-friendly)</li> <li>List of things to consider for warnings<ul> <li>Multiple positional-or-keyword parameters</li> <li>Public imports in public modules</li> <li>Private things made public through imports/assignments</li> <li>Too many public things? Generally annoying. Configuration?</li> </ul> </li> <li> Ability to compare two APIs to return breaking changes</li> <li>List of things to consider for breaking changes<ul> <li> Changed position of positional only parameter</li> <li> Changed position of positional or keyword parameter</li> <li> Changed type of parameter</li> <li> Changed type of public module attribute</li> <li> Changed return type of a public function/method</li> <li> Added parameter without a default value</li> <li> Removed keyword-only parameter without a default value, without **kwargs to swallow it</li> <li> Removed positional-only parameter without a default value, without *args to swallow it</li> <li> Removed positional-or_keyword argument without a default value, without args and *kwargs to swallow it</li> <li> Removed public module/class/function/method/attribute</li> <li> All of the previous even when parent is private (could be publicly imported or assigned somewhere),     and later be smarter: public assign/import makes private things public!</li> <li> Inheritance: removed, added or changed base that changes MRO</li> </ul> </li> </ul> </li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0275-2023-05-12","title":"0.27.5 - 2023-05-12","text":"<p>Compare with 0.27.4</p>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Represent function using their names when inspecting default values (9116c1f by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#180</li> </ul>"},{"location":"changelog/#0274-2023-05-10","title":"0.27.4 - 2023-05-10","text":"<p>Compare with 0.27.3</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Don't recurse through targets, get directly to final target and handle alias-related errors (c5bc197 by Timoth\u00e9e Mazzucotelli). Issue #155</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Follow <code>.pth</code> files to extend search paths with editable modules (79bf724 by Timoth\u00e9e Mazzucotelli). Issue #154</li> <li>Add default values to <code>_load_packages</code> helper (f104c20 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0273-2023-05-05","title":"0.27.3 - 2023-05-05","text":"<p>Compare with 0.27.2</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Allow setting doctring through alias (2e0f553 by Timoth\u00e9e Mazzucotelli).</li> <li>Prevent infinite recursion (0e98546 by Timoth\u00e9e Mazzucotelli). Issue #155</li> </ul>"},{"location":"changelog/#0272-2023-05-03","title":"0.27.2 - 2023-05-03","text":"<p>Compare with 0.27.1</p>"},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>Remove async extra (aiofiles) (70d9b93 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Support walrus operator (bf721f4 by Timoth\u00e9e Mazzucotelli). Issue #152</li> <li>Respect <code>ClassVar</code> annotation (60e01c1 by Victor Westerhuis). PR #150, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> <li>Add missing \"other args\" section aliases (f5c0a0e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_2","title":"Code Refactoring","text":"<ul> <li>Move utils from cli to respective modules (c6ce49e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0271-2023-04-16","title":"0.27.1 - 2023-04-16","text":"<p>Compare with 0.27.0</p>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Actually parse warnings sections (bc00da5 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow Raises and Warns items to start with a newline (f3b088c by Victor Westerhuis). PR #149, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#0270-2023-04-10","title":"0.27.0 - 2023-04-10","text":"<p>Compare with 0.26.0</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Implement basic handling of Alias for breaking changes (aa8ce00 by Yurii). PR #140, Co-authored-by: Timoth\u00e9e Mazzucotelli pawamoy@pm.me</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>Support <code>Literal</code> imported from <code>typing_extensions</code> (3a16e58 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#545</li> <li>Fix parameter default checking logic and diff tests (1b940fd by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0260-2023-04-03","title":"0.26.0 - 2023-04-03","text":"<p>Compare with 0.25.5</p>"},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li><code>AliasResolutionError</code> instances don't have a <code>target_path</code> attribute anymore.     It is instead replaced by an <code>alias</code> attribute which is a reference to an <code>Alias</code> instance.</li> <li>Lots of positional-or-keyword parameters were changed to keyword-only parameters.</li> </ul>"},{"location":"changelog/#deprecations","title":"Deprecations","text":"<ul> <li>The <code>griffe.agents.extensions</code> module was moved to <code>griffe.extensions</code>.     The old path is deprecated.</li> </ul>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Support newer versions of <code>editables</code> (ab7a3be by Timoth\u00e9e Mazzucotelli): the names of editable modules have changed from <code>__editables_*</code> to <code>_editable_impl_*</code>.</li> <li>Provide a JSON schema (7dfed39 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow hybrid extension to filter objects and run multiple inspectors (f8ff53a by Timoth\u00e9e Mazzucotelli).</li> <li>Allow loading extension from file path (131454e by Timoth\u00e9e Mazzucotelli).</li> <li>Add back <code>relative_filepath</code> which now really returns the filepath relative to the current working directory (40fe0c5 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>Fix JSON schema for ending line numbers (and add test) (318c6b4 by Timoth\u00e9e Mazzucotelli).</li> <li>Prevent cyclic aliases by not overwriting a module member with an indirect alias to itself (c188a95 by Timoth\u00e9e Mazzucotelli). Issue #122</li> <li>Prevent alias resolution errors when copying docstring or labels from previously existing attribute (48747b6 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google admonition regular expression (ef0be5f by Timoth\u00e9e Mazzucotelli).</li> <li>Add back <code>griffe.agents.extensions</code> module (deprecated) (7129477 by Timoth\u00e9e Mazzucotelli).</li> <li>Forward class attribute docstrings to instances (7bf4952 by Rodrigo Gir\u00e3o Serr\u00e3o). Issue #128, PR #135</li> <li>Prevent errors related to getting attributes in the inspector (5d15d27 by Timoth\u00e9e Mazzucotelli).</li> <li>Catch \"member does not exist\" errors while expanding wildcards (a966022 by Timoth\u00e9e Mazzucotelli).</li> <li>Catch more inspection errors (4f6eef9 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_3","title":"Code Refactoring","text":"<ul> <li>Log final path after resolving alias (c7ec7f7 by Timoth\u00e9e Mazzucotelli).</li> <li>Move extensions one level up (67ebd71 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default <code>when</code> value on extension base classes (e8ad889 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>relative_filepath</code> to <code>relative_package_filepath</code> to better express what it does (6148f85 by Timoth\u00e9e Mazzucotelli).</li> <li>Show file name and line number in alias resolution error messages (c48928d by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0255-2023-02-16","title":"0.25.5 - 2023-02-16","text":"<p>Compare with 0.25.4</p>"},{"location":"changelog/#bug-fixes_6","title":"Bug Fixes","text":"<ul> <li>Fix parsing empty lines with indentation in Google docstrings (705edff by Timoth\u00e9e Mazzucotelli). Issue #129</li> </ul>"},{"location":"changelog/#0254-2023-01-19","title":"0.25.4 - 2023-01-19","text":"<p>Compare with 0.25.3</p>"},{"location":"changelog/#bug-fixes_7","title":"Bug Fixes","text":"<ul> <li>Fix creation of aliases to modules when inspecting (54242cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support (setuptools) editable packages with multiple roots (bd37dfb by Gilad). PR #126</li> </ul>"},{"location":"changelog/#0253-2023-01-04","title":"0.25.3 - 2023-01-04","text":"<p>Compare with 0.25.2</p>"},{"location":"changelog/#bug-fixes_8","title":"Bug Fixes","text":"<ul> <li>Fix parsing of annotations in Numpy attributes sections (18fa396 by Timoth\u00e9e Mazzucotelli). Issue #72</li> </ul>"},{"location":"changelog/#0252-2022-12-24","title":"0.25.2 - 2022-12-24","text":"<p>Compare with 0.25.1</p>"},{"location":"changelog/#bug-fixes_9","title":"Bug Fixes","text":"<ul> <li>Make sure passage through aliases is reset (79733f4 by Timoth\u00e9e Mazzucotelli). Issue #123</li> <li>Ignore cyclic alias errors when updating target aliases (bb62b2f by Timoth\u00e9e Mazzucotelli). Issue #123</li> </ul>"},{"location":"changelog/#0251-2022-12-20","title":"0.25.1 - 2022-12-20","text":"<p>Compare with 0.25.0</p>"},{"location":"changelog/#bug-fixes_10","title":"Bug Fixes","text":"<ul> <li>Pass through aliases earlier to prevent infinite recursion (e533f29 by Timoth\u00e9e Mazzucotelli). Issue #83, #122</li> </ul>"},{"location":"changelog/#0250-2022-12-11","title":"0.25.0 - 2022-12-11","text":"<p>Compare with 0.24.1</p>"},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>Parameter <code>only_known_modules</code> was renamed <code>external</code> in the <code>expand_wildcards()</code> method of the loader.</li> <li>Exception <code>UnhandledEditablesModuleError</code> was renamed <code>UnhandledEditableModuleError</code> since we now support editable installation from other packages than <code>editables</code>.</li> </ul>"},{"location":"changelog/#highlights","title":"Highlights","text":"<ul> <li>Properties are now fetched as attributes rather than functions, since that is how they are used. This was asked by users, and since Griffe generates signatures for Python APIs (emphasis on APIs), it makes sense to return data that matches the interface provided to users. Such property objects in Griffe's output will still have the associated <code>property</code> labels of course.</li> <li>Lots of bug fixes. These bugs were discovered by running Griffe on many major packages as well as the standard library (again). Particularly, alias resolution should be more robust now, and should generate less issues like cyclic aliases, meaning indirect/wildcard imports should be better understood. We still highly discourage the use of wilcard imports </li> </ul>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Support <code>setuptools</code> editable modules (abc18f7 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#463</li> <li>Support merging stubs on wildcard imported objects (0ed9c36 by Timoth\u00e9e Mazzucotelli). Issue #116</li> </ul>"},{"location":"changelog/#bug-fixes_11","title":"Bug Fixes","text":"<ul> <li>Prevent cyclic alias creation when expanding wildcards (a77e4e8 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash and show hint when wildcard expansion fails (336faf6 by Timoth\u00e9e Mazzucotelli).</li> <li>Register top module after inspection (86454ec by Timoth\u00e9e Mazzucotelli).</li> <li>Set alias attributes early (2ac1a9b by Timoth\u00e9e Mazzucotelli).</li> <li>Allow writing attributes on aliases (c8f736e by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on inspection of functions signatures (051e337 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on inspection of method descriptors' docstrings (09571bb by Timoth\u00e9e Mazzucotelli).</li> <li>Fix stats computing (handle stubs and namespace packages) (a81f8dc by Timoth\u00e9e Mazzucotelli).</li> <li>Support documenting multiple items for optional tuples (727456d by Timoth\u00e9e Mazzucotelli). Issue #117</li> <li>Fix comparing names with strings (37ae0a2 by Timoth\u00e9e Mazzucotelli). Issue #114</li> <li>Fix deepcopy crashing because of <code>__getattr__</code> (11b023b by Timoth\u00e9e Mazzucotelli). Issue #73, PR #119</li> </ul>"},{"location":"changelog/#code-refactoring_4","title":"Code Refactoring","text":"<ul> <li>Prevent reloading of failed modules (8ef14ab by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>only_known_modules</code> parameter to <code>external</code> (5f816c6 by Timoth\u00e9e Mazzucotelli).</li> <li>Rework alias creation decision in the inspector (f434943 by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve alias chain recursively (6cdd3b2 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't try to stubs-merge identical modules (7099971 by Timoth\u00e9e Mazzucotelli).</li> <li>Load properties as attributes (5c97a45 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#9</li> <li>Use a cyclic relationship map for inspection (9a2a711 by Timoth\u00e9e Mazzucotelli). PR #115</li> </ul>"},{"location":"changelog/#0241-2022-11-18","title":"0.24.1 - 2022-11-18","text":"<p>Compare with 0.24.0</p>"},{"location":"changelog/#bug-fixes_12","title":"Bug Fixes","text":"<ul> <li>Support nested namespace packages (d571f8f by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0240-2022-11-13","title":"0.24.0 - 2022-11-13","text":"<p>Compare with 0.23.0</p> <p>The \"Breaking Changes\" and \"Deprecations\" sections are proudly written with the help of our new API breakage detection feature ! Many thanks to Talley Lambert (@tlambert03) for the initial code allowing to compare two Griffe trees.</p>"},{"location":"changelog/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>All parameters of the <code>load_git</code> function, except <code>module</code>, are now keyword-only.</li> <li>Parameter <code>try_relative_path</code> of the <code>load_git</code> function was removed.</li> <li>Parameter <code>commit</code> was renamed <code>ref</code> in the <code>load_git</code> function.</li> <li>Parameter <code>commit</code> was renamed <code>ref</code> in the <code>tmp_worktree</code> helper, which will probably become private later.</li> <li>Parameters <code>ref</code> and <code>repo</code> switched positions in the <code>tmp_worktree</code> helper.</li> <li>All parameters of the <code>resolve_aliases</code> method are now keyword-only.</li> <li>Parameters <code>only_exported</code> and <code>only_known_modules</code> of the <code>resolve_module_aliases</code>     method were removed. This method is most probably not used by anyone, and will probably be made private in the future.</li> </ul>"},{"location":"changelog/#deprecations_1","title":"Deprecations","text":"<ul> <li> <p>Parameters <code>only_exported</code> and <code>only_known_modules</code> of the <code>resolve_aliases</code>     method are deprecated in favor of their inverted counter-part <code>implicit</code> and <code>external</code> parameters.</p> <ul> <li>Example before: <code>loader.resolve_aliases(only_exported=True, only_known_modules=True)</code></li> <li>Example after: <code>loader.resolve_aliases(implicit=False, external=False)</code></li> </ul> </li> </ul>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Add CLI command to check for API breakages (90bded4 by Timoth\u00e9e Mazzucotelli). Issue #75, PR #105</li> <li>Add function to find API breaking changes (a4f1280 by Talley Lambert and Timoth\u00e9e Mazzucotelli). Issue #75, PR #105</li> </ul>"},{"location":"changelog/#bug-fixes_13","title":"Bug Fixes","text":"<ul> <li>Fix labels mismatch staticmethod-classmethod in inspector (25060f6 by Timoth\u00e9e Mazzucotelli). Issue #111</li> <li>Prevent infinite loop while looking for package's parent folder (f297f1a by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#72</li> <li>Fix comparing names and expressions (07bffff by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_5","title":"Code Refactoring","text":"<ul> <li>Rename some parameters in Git module (9ad7a2c by Timoth\u00e9e Mazzucotelli).</li> <li>Set parameters as keyword-only (44c01be by Timoth\u00e9e Mazzucotelli).</li> <li>Remove stars from parameters names (91dce14 by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor CLI to use subcommands (760b091 by Timoth\u00e9e Mazzucotelli). PR #110</li> <li>Rename parameters used when resolving aliases (3d3a4eb by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0230-2022-10-26","title":"0.23.0 - 2022-10-26","text":"<p>Compare with 0.22.2</p>"},{"location":"changelog/#features_4","title":"Features","text":"<ul> <li>Support <code>typing_extensions.overload</code> (c29fad5 by Nyuan Zhang). PR #108</li> </ul>"},{"location":"changelog/#bug-fixes_14","title":"Bug Fixes","text":"<ul> <li>Log debug instead of errors when failing to parse NumPy annotations for additional sections (568ff60 by Sigurd Spieckermann). Issue #93, PR #109</li> <li>Don't strip too many parentheses around a call node (bb5c5e7 by Timoth\u00e9e Mazzucotelli). PR #107</li> <li>Guard against more alias resolution errors (2be135d by Timoth\u00e9e Mazzucotelli). Issue #83, PR #103</li> </ul>"},{"location":"changelog/#0222-2022-09-24","title":"0.22.2 - 2022-09-24","text":"<p>Compare with 0.22.1</p>"},{"location":"changelog/#bug-fixes_15","title":"Bug Fixes","text":"<ul> <li>Log debug instead of errors when failing to parse Numpy annotations (75eeeda by Timoth\u00e9e Mazzucotelli). Issue #93</li> <li>Don't crash on unsupported module names (containing dots) (6a57194 by Timoth\u00e9e Mazzucotelli). Issue #94</li> <li>Show correct docstring line numbers on Python 3.7 (edd4b6d by Timoth\u00e9e Mazzucotelli). Issue #98</li> <li>Fix parsing of Numpy docstring with an Examples section at the end (3114727 by Timoth\u00e9e Mazzucotelli). Issue #97</li> <li>Don't crash on unsupported item in <code>__all__</code> (log a warning instead) (9e5df0a by Timoth\u00e9e Mazzucotelli). Issue #92</li> <li>Prevent infinite recursion while expanding exports (68446f7 by Timoth\u00e9e Mazzucotelli).</li> <li>Add missing check while expanding wildcards (7e816ed by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0221-2022-09-10","title":"0.22.1 - 2022-09-10","text":"<p>Compare with 0.22.0</p>"},{"location":"changelog/#bug-fixes_16","title":"Bug Fixes","text":"<ul> <li>Always use <code>encoding=\"utf8\"</code> when reading text files (3b279bf by Rudolf Byker). Issue #99, PR #100</li> </ul>"},{"location":"changelog/#0220-2022-06-28","title":"0.22.0 - 2022-06-28","text":"<p>Compare with 0.21.0</p>"},{"location":"changelog/#features_5","title":"Features","text":"<ul> <li>Support forward references (245daea by Timoth\u00e9e Mazzucotelli). Issue #86</li> </ul>"},{"location":"changelog/#code-refactoring_6","title":"Code Refactoring","text":"<ul> <li>Safely parse annotations and values (b023e2b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0210-2022-06-25","title":"0.21.0 - 2022-06-25","text":"<p>Compare with 0.20.0</p>"},{"location":"changelog/#features_6","title":"Features","text":"<ul> <li>Add <code>load_git</code> function allowing to load data from a specific git ref (b2c3946 by Talley Lambert). Issue #75, PR #76</li> </ul>"},{"location":"changelog/#bug-fixes_17","title":"Bug Fixes","text":"<ul> <li>Fix detecting and merging stubs for single-file packages (6a82542 by Talley Lambert). Issue #77, PR #78</li> <li>Fix parsing ExtSlice nodes when getting values (b2fe968 by Timoth\u00e9e Mazzucotelli). Issue #87</li> <li>Don't trigger alias resolution when merging stubs (2b88627 by Timoth\u00e9e Mazzucotelli). Issue #89</li> <li>Fix handling of .pth files (f212dd3 by Gabriel Dugny). Issue #84, PR #85</li> </ul>"},{"location":"changelog/#0200-2022-06-03","title":"0.20.0 - 2022-06-03","text":"<p>Compare with 0.19.3</p>"},{"location":"changelog/#features_7","title":"Features","text":"<ul> <li>Add <code>as_json</code> and <code>from_json</code> convenience methods on objects (5c3d751 by Talley Lambert). PR #74</li> </ul>"},{"location":"changelog/#bug-fixes_18","title":"Bug Fixes","text":"<ul> <li>Fix unparsing of f-strings (9ca74bd by Timoth\u00e9e Mazzucotelli). Issue #80</li> <li>Don't crash when overwriting a submodule with a wildcard imported attribute (bfad1cc by Timoth\u00e9e Mazzucotelli). Issue #72, #79, mkdocstrings/mkdocstrings#438</li> </ul>"},{"location":"changelog/#0193-2022-05-26","title":"0.19.3 - 2022-05-26","text":"<p>Compare with 0.19.2</p>"},{"location":"changelog/#bug-fixes_19","title":"Bug Fixes","text":"<ul> <li>Support USub and UAdd nodes in annotations (1169c51 by Timoth\u00e9e Mazzucotelli). Issue #71</li> </ul>"},{"location":"changelog/#0192-2022-05-18","title":"0.19.2 - 2022-05-18","text":"<p>Compare with 0.19.1</p>"},{"location":"changelog/#bug-fixes_20","title":"Bug Fixes","text":"<ul> <li>Don't crash on single line docstrings with trailing whitespace (Google) (8d9ccd5 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0191-2022-05-07","title":"0.19.1 - 2022-05-07","text":"<p>Compare with 0.19.0</p>"},{"location":"changelog/#bug-fixes_21","title":"Bug Fixes","text":"<ul> <li>Don't crash on nested functions in <code>__init__</code> methods (cd5af43 by Timoth\u00e9e Mazzucotelli). Issue #68</li> </ul>"},{"location":"changelog/#0190-2022-05-06","title":"0.19.0 - 2022-05-06","text":"<p>Compare with 0.18.0</p>"},{"location":"changelog/#features_8","title":"Features","text":"<ul> <li>Add <code>load</code> shortcut function for convenience (f38a42d by Timoth\u00e9e Mazzucotelli).</li> <li>Support loading (and merging) <code>*.pyi</code> files (41518f4 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#404</li> <li>Improve support for call nodes in annotations (45e5bf5 by Timoth\u00e9e Mazzucotelli). Issue #66</li> <li>Support <code>dataclass</code> decorators on classes (f579431 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_7","title":"Code Refactoring","text":"<ul> <li>Handle absence of values (190585d by Timoth\u00e9e Mazzucotelli).</li> <li>Simplify decorators to labels function (04e768f by Timoth\u00e9e Mazzucotelli).</li> <li>Always sort labels when serializing (bd2504b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0180-2022-04-19","title":"0.18.0 - 2022-04-19","text":"<p>Compare with 0.17.0</p>"},{"location":"changelog/#features_9","title":"Features","text":"<ul> <li>Add CLI option to disallow inspection (8f71a07 by Timoth\u00e9e Mazzucotelli).</li> <li>Support complex <code>__all__</code> assignments (9a2128b by Timoth\u00e9e Mazzucotelli). Issue #40</li> <li>Inherit class parameters from <code>__init__</code> method (e195593 by Fran\u00e7ois Rozet). Issue mkdocstrings/python#19, PR #65.   It allows to write \"Parameters\" sections in the docstring of the class itself.</li> </ul>"},{"location":"changelog/#performance-improvements","title":"Performance Improvements","text":"<ul> <li>Avoid using <code>__len__</code> as boolean method (d465493 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_22","title":"Bug Fixes","text":"<ul> <li>Don't crash on unhandle <code>__all__</code> assignments (cbc103c by Timoth\u00e9e Mazzucotelli).</li> <li>Handle empty packages names in CLI (52b51c4 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash on Google parameters sections found in non-function docstrings (4a417bc by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#19</li> </ul>"},{"location":"changelog/#code-refactoring_8","title":"Code Refactoring","text":"<ul> <li>Improve \"unknown parameter\" messages (7191799 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#423</li> <li>Set property label on <code>@cached_property</code>-decoratored methods (bc068f8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0170-2022-04-15","title":"0.17.0 - 2022-04-15","text":"<p>Compare with 0.16.0</p>"},{"location":"changelog/#features_10","title":"Features","text":"<ul> <li>Handle properties setters and deleters (50a4490 by Timoth\u00e9e Mazzucotelli).</li> <li>Handle <code>typing.overload</code> decorator (927bbd9 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#308</li> <li>Set labels on functions using decorators (1c1feb2 by Timoth\u00e9e Mazzucotelli). Issue #47</li> <li>Add <code>runtime</code> attribute to objects/aliases and handle type guarded objects (2f2a04e by Timoth\u00e9e Mazzucotelli). Issue #42</li> <li>Support pkg-style namespace packages (efba0c6 by Timoth\u00e9e Mazzucotelli). Issue #58</li> </ul>"},{"location":"changelog/#code-refactoring_9","title":"Code Refactoring","text":"<ul> <li>Remove useless attribute (c4a92b7 by Timoth\u00e9e Mazzucotelli).</li> <li>Improve Google warnings (641089a by Timoth\u00e9e Mazzucotelli).</li> <li>Remove useless import nodes generic visits (f83fc8e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0160-2022-04-09","title":"0.16.0 - 2022-04-09","text":"<p>Compare with 0.15.1</p>"},{"location":"changelog/#features_11","title":"Features","text":"<ul> <li>Warn about unknown parameters in Numpy docstrings (23f63f2 by Timoth\u00e9e Mazzucotelli).</li> <li>Warn about unknown parameters in Google docstrings (72be993 by Kevin Musgrave). Issue mkdocstrings/mkdocstrings#408, PR #63</li> </ul>"},{"location":"changelog/#bug-fixes_23","title":"Bug Fixes","text":"<ul> <li>Don't crash on unhandled AST nodes while parsing text annotations (f3be3a6 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#416</li> </ul>"},{"location":"changelog/#0151-2022-04-08","title":"0.15.1 - 2022-04-08","text":"<p>Compare with 0.15.0</p>"},{"location":"changelog/#bug-fixes_24","title":"Bug Fixes","text":"<ul> <li>Don't overwrite existing (lower) members when expanding wildcards (9ff86e3 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't insert admonition before current section (Google parser) (8d8a46f by Timoth\u00e9e Mazzucotelli).</li> <li>Handle aliases chains in <code>has_docstrings</code> method (77c6943 by Timoth\u00e9e Mazzucotelli).</li> <li>Actually check for docstrings recursively (15f4193 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0150-2022-04-03","title":"0.15.0 - 2022-04-03","text":"<p>Compare with 0.14.1</p>"},{"location":"changelog/#features_12","title":"Features","text":"<ul> <li>Support <code>ignore_init_summary</code> in Numpy parser (f8cd147 by Timoth\u00e9e Mazzucotelli). Issue #44</li> <li>Enable cross-references for Numpy docstrings annotations (e32a73c by Timoth\u00e9e Mazzucotelli). Issues #11, #12, #13, #14, #15, #16, #17, #18</li> <li>Retrieve annotations from parent in Numpy parser (8d4eae3 by Timoth\u00e9e Mazzucotelli). Issues #29, #30, #31, #32</li> <li>Parse annotations in Iterator/Generator for Google docstrings (f0129ef by Timoth\u00e9e Mazzucotelli). Issue #28</li> </ul>"},{"location":"changelog/#bug-fixes_25","title":"Bug Fixes","text":"<ul> <li>Fix missing \"receives\" entry in Google parser (35d63fb by Timoth\u00e9e Mazzucotelli).</li> <li>Fix serialization of Windows paths (b7e8da8 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_10","title":"Code Refactoring","text":"<ul> <li>Be less strict on spacing around \":\" in Numpy docstrings (aa592b5 by Timoth\u00e9e Mazzucotelli).</li> <li>Be less strict in Numpy regular expressions (603dc0e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename variables in Numpy module (4407244 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0141-2022-04-01","title":"0.14.1 - 2022-04-01","text":"<p>Compare with 0.14.0</p>"},{"location":"changelog/#bug-fixes_26","title":"Bug Fixes","text":"<ul> <li>Retrieve default value for non-string parameters (15952ed by ThomasPJ). Issue #59, issue mkdocstrings/python#8, PR #60</li> <li>Prevent infinite recursion while expanding wildcards (428628f by Timoth\u00e9e Mazzucotelli). Issue #57</li> </ul>"},{"location":"changelog/#0140-2022-03-06","title":"0.14.0 - 2022-03-06","text":"<p>Compare with 0.13.2</p>"},{"location":"changelog/#features_13","title":"Features","text":"<ul> <li>Ignore <code>__doc__</code> from parent classes (10aa59e by Will Da Silva). Issue #55, PR #56</li> </ul>"},{"location":"changelog/#0132-2022-03-01","title":"0.13.2 - 2022-03-01","text":"<p>Compare with 0.13.1</p>"},{"location":"changelog/#bug-fixes_27","title":"Bug Fixes","text":"<ul> <li>Fix type regex in Numpy parser (3a10fda by Timoth\u00e9e Mazzucotelli).</li> <li>Current module must not be available in its members' scope (54f9688 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow named sections after numpydoc examples (a44d9c6 by Lucina). PR #54</li> </ul>"},{"location":"changelog/#0131-2022-02-24","title":"0.13.1 - 2022-02-24","text":"<p>Compare with 0.13.0</p>"},{"location":"changelog/#bug-fixes_28","title":"Bug Fixes","text":"<ul> <li>Don't cut through wildcard-expanded aliases chains (65dafa4 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix docstrings warnings when there's no parent module (e080549 by Timoth\u00e9e Mazzucotelli). Issue #51</li> </ul>"},{"location":"changelog/#code-refactoring_11","title":"Code Refactoring","text":"<ul> <li>Use proper classes for docstrings sections (46eddac by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/python#3, PR #52</li> </ul>"},{"location":"changelog/#0130-2022-02-23","title":"0.13.0 - 2022-02-23","text":"<p>Compare with 0.12.6</p>"},{"location":"changelog/#features_14","title":"Features","text":"<ul> <li>Implement <code>trim_doctest_flags</code> for Google and Numpy (8057153 by Jeremy Goh). Issue mkdocstrings/mkdocstrings#386, PR #48</li> </ul>"},{"location":"changelog/#bug-fixes_29","title":"Bug Fixes","text":"<ul> <li>Rename keyword parameters to keyword arguments (ce3eb6b by Jeremy Goh).</li> </ul>"},{"location":"changelog/#0126-2022-02-18","title":"0.12.6 - 2022-02-18","text":"<p>Compare with 0.12.5</p>"},{"location":"changelog/#bug-fixes_30","title":"Bug Fixes","text":"<ul> <li>Support starred parameters in Numpy docstrings (27f0fc2 by Timoth\u00e9e Mazzucotelli). Issue #43</li> </ul>"},{"location":"changelog/#0125-2022-02-17","title":"0.12.5 - 2022-02-17","text":"<p>Compare with 0.12.4</p>"},{"location":"changelog/#bug-fixes_31","title":"Bug Fixes","text":"<ul> <li>Fix getting line numbers on aliases (351750e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0124-2022-02-16","title":"0.12.4 - 2022-02-16","text":"<p>Compare with 0.12.3</p>"},{"location":"changelog/#bug-fixes_32","title":"Bug Fixes","text":"<ul> <li>Update target path when changing alias target (5eda646 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix relative imports to absolute with wildcards (69500dd by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> <li>Fix accessing members using tuples (87ff1df by Timoth\u00e9e Mazzucotelli).</li> <li>Fix recursive wildcard expansion (60e6edf by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> <li>Only export submodules if they were imported (98c72db by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#382</li> </ul>"},{"location":"changelog/#0123-2022-02-15","title":"0.12.3 - 2022-02-15","text":"<p>Compare with 0.12.2</p>"},{"location":"changelog/#bug-fixes_33","title":"Bug Fixes","text":"<ul> <li>Always decode source as UTF8 (563469b by Timoth\u00e9e Mazzucotelli).</li> <li>Fix JSON encoder and decoder (3e768d6 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_12","title":"Code Refactoring","text":"<ul> <li>Improve error handling (7b15a51 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0122-2022-02-13","title":"0.12.2 - 2022-02-13","text":"<p>Compare with 0.12.1</p>"},{"location":"changelog/#bug-fixes_34","title":"Bug Fixes","text":"<ul> <li>Fix JSON unable to serialize docstring kind values (91e6719 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_13","title":"Code Refactoring","text":"<ul> <li>Make attribute labels more explicit (19eac2e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0121-2022-02-12","title":"0.12.1 - 2022-02-12","text":"<p>Compare with 0.11.7</p>"},{"location":"changelog/#features_15","title":"Features","text":"<ul> <li>Add <code>ignore_init_summary</code> option to the Google parser (81f0333 by Timoth\u00e9e Mazzucotelli).</li> <li>Add <code>is_KIND</code> properties on objects (17a08cd by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0117-2022-02-12","title":"0.11.7 - 2022-02-12","text":"<p>Compare with 0.11.6</p>"},{"location":"changelog/#bug-fixes_35","title":"Bug Fixes","text":"<ul> <li>Keep only first assignment in conditions (0104440 by Timoth\u00e9e Mazzucotelli).</li> <li>Support invert unary op in annotations (734ef55 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix handling of missing modules during dynamic imports (7a3b383 by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings/mkdocstrings#380</li> <li>Fix getting lines of compiled modules (899461b by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_14","title":"Code Refactoring","text":"<ul> <li>Get annotation with the same property on functions (ecc7bba by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0116-2022-02-10","title":"0.11.6 - 2022-02-10","text":"<p>Compare with 0.11.5</p>"},{"location":"changelog/#bug-fixes_36","title":"Bug Fixes","text":"<ul> <li>Fix infinite loop in Google parser (8b7b97b by Timoth\u00e9e Mazzucotelli). Issue #38</li> </ul>"},{"location":"changelog/#0115-2022-02-08","title":"0.11.5 - 2022-02-08","text":"<p>Compare with 0.11.4</p>"},{"location":"changelog/#bug-fixes_37","title":"Bug Fixes","text":"<ul> <li>Fix building title and kind of Google admonitions (87ab56c by Timoth\u00e9e Mazzucotelli). Issue mkdocstrings#379</li> </ul>"},{"location":"changelog/#0114-2022-02-07","title":"0.11.4 - 2022-02-07","text":"<p>Compare with 0.11.3</p>"},{"location":"changelog/#bug-fixes_38","title":"Bug Fixes","text":"<ul> <li>Don't trigger alias resolution while checking docstrings presence (dda72ea by Timoth\u00e9e Mazzucotelli). Issue #37</li> </ul>"},{"location":"changelog/#0113-2022-02-05","title":"0.11.3 - 2022-02-05","text":"<p>Compare with 0.11.2</p>"},{"location":"changelog/#bug-fixes_39","title":"Bug Fixes","text":"<ul> <li>Fix getting params defaults on Python 3.7 (0afd867 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0112-2022-02-03","title":"0.11.2 - 2022-02-03","text":"<p>Compare with 0.11.1</p>"},{"location":"changelog/#code-refactoring_15","title":"Code Refactoring","text":"<ul> <li>Factorize docstring annotation parser (19609be by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0111-2022-02-01","title":"0.11.1 - 2022-02-01","text":"<p>Compare with 0.11.0</p>"},{"location":"changelog/#code-refactoring_16","title":"Code Refactoring","text":"<ul> <li>Rename RST parser to Sphinx (a612cb1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0110-2022-01-31","title":"0.11.0 - 2022-01-31","text":"<p>Compare with 0.10.0</p>"},{"location":"changelog/#features_16","title":"Features","text":"<ul> <li>Support matrix multiplication operator in visitor (6129e17 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_40","title":"Bug Fixes","text":"<ul> <li>Fix name resolution for inspected data (ed3e7e5 by Timoth\u00e9e Mazzucotelli).</li> <li>Make importer actually able to import any nested object (d007219 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_17","title":"Code Refactoring","text":"<ul> <li>Always use search paths to import modules (a9a378f by Timoth\u00e9e Mazzucotelli).</li> <li>Split out module finder (7290642 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#0100-2022-01-14","title":"0.10.0 - 2022-01-14","text":"<p>Compare with 0.9.0</p>"},{"location":"changelog/#bug-fixes_41","title":"Bug Fixes","text":"<ul> <li>Fix infinite recursion errors in alias resolver (133b4e4 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix inspection of nodes children (aliases or not) (bb354f2 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix relative to absolute import conversion (464c39e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_18","title":"Code Refactoring","text":"<ul> <li>Rename some CLI options (1323268 by Timoth\u00e9e Mazzucotelli).</li> <li>Return the loader the to main function (9c6317e by Timoth\u00e9e Mazzucotelli).</li> <li>Improve logging messages (b8eb16e by Timoth\u00e9e Mazzucotelli).</li> <li>Skip inspection of some debug packages (4ee8968 by Timoth\u00e9e Mazzucotelli).</li> <li>Return ... instead of Ellipsis (f9ae31d by Timoth\u00e9e Mazzucotelli).</li> <li>Catch attribute errors when cross-referencing docstring annotations (288803a by Timoth\u00e9e Mazzucotelli).</li> <li>Support dict methods in lines collection (1b0cb94 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features_17","title":"Features","text":"<ul> <li>Compute and show some stats (1b8d0a1 by Timoth\u00e9e Mazzucotelli).</li> <li>Add CLI options for alias resolution (87a59cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support Google raises annotations cross-refs (8006ae1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#090-2022-01-04","title":"0.9.0 - 2022-01-04","text":"<p>Compare with 0.8.0</p>"},{"location":"changelog/#features_18","title":"Features","text":"<ul> <li>Loader option to only follow aliases in known modules (879d91b by Timoth\u00e9e Mazzucotelli).</li> <li>Use aliases when inspecting too (60439ee by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_42","title":"Bug Fixes","text":"<ul> <li>Handle more errors when loading modules (1aa571a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle more errors when getting signature (2db85e7 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix checking parent truthfulness (6129e50 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting subscript value (1699f12 by Timoth\u00e9e Mazzucotelli).</li> <li>Support yield nodes (7d536d5 by Timoth\u00e9e Mazzucotelli).</li> <li>Exclude some special low-level members that cause cyclic issues (b54ab34 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix transforming elements of signatures to annotations (e278c11 by Timoth\u00e9e Mazzucotelli).</li> <li>Detect cyclic aliases and prevent resolution errors (de5dd12 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't crash while trying to get the representation of an attribute value (77ac55d by Timoth\u00e9e Mazzucotelli).</li> <li>Fix building value for joined strings (6154b69 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix prevention of cycles while building objects nodes (48062ac by Timoth\u00e9e Mazzucotelli).</li> <li>Better handle relative imports (91b42de by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google parser missing lines ending with colon (2f7969c by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_19","title":"Code Refactoring","text":"<ul> <li>Improve alias resolution robustness (e708139 by Timoth\u00e9e Mazzucotelli).</li> <li>Remove async loader for now (acc5ecf by Timoth\u00e9e Mazzucotelli).</li> <li>Improve handling of Google admonitions (8aa5ed0 by Timoth\u00e9e Mazzucotelli).</li> <li>Better handling of import errors and system exits while inspecting modules (7ba1589 by Timoth\u00e9e Mazzucotelli).</li> <li>Empty generic visit/inspect methods in base classes (338760e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#080-2022-01-02","title":"0.8.0 - 2022-01-02","text":"<p>Compare with 0.7.1</p>"},{"location":"changelog/#features_19","title":"Features","text":"<ul> <li>Support getting attribute annotation from parent in RST docstring parser (25db61a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle relative imports (62b0927 by Timoth\u00e9e Mazzucotelli).</li> <li>Support wildcard imports (77a3cb7 by Timoth\u00e9e Mazzucotelli).</li> <li>Support configuring log level (CLI/env var) (839d78e by Timoth\u00e9e Mazzucotelli).</li> <li>Support loading <code>*.py[cod]</code> and <code>*.so</code> modules (cd98a6f by Timoth\u00e9e Mazzucotelli).</li> <li>Support inspecting builtin functions/methods (aa1fce3 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_20","title":"Code Refactoring","text":"<ul> <li>Handle extensions errors (11278ca by Timoth\u00e9e Mazzucotelli).</li> <li>Don't always try to find a module as a relative  path (e6df277 by Timoth\u00e9e Mazzucotelli).</li> <li>Improve loggers patching (f4b262a by Timoth\u00e9e Mazzucotelli).</li> <li>Improve dynamic imports (2998195 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#071-2021-12-28","title":"0.7.1 - 2021-12-28","text":"<p>Compare with 0.7.0</p>"},{"location":"changelog/#code-refactoring_21","title":"Code Refactoring","text":"<ul> <li>Only log warning if async mode is used (356e848 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#070-2021-12-28","title":"0.7.0 - 2021-12-28","text":"<p>Compare with 0.6.0</p>"},{"location":"changelog/#features_20","title":"Features","text":"<ul> <li>Support more nodes on Python 3.7 (7f2c4ec by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_22","title":"Code Refactoring","text":"<ul> <li>Don't crash on syntax errors and log an error (10bb6b1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#060-2021-12-27","title":"0.6.0 - 2021-12-27","text":"<p>Compare with 0.5.0</p>"},{"location":"changelog/#features_21","title":"Features","text":"<ul> <li>Support more AST nodes (cd1b305 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_23","title":"Code Refactoring","text":"<ul> <li>Use annotation getter for base classes (8b1a7ed by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#050-2021-12-20","title":"0.5.0 - 2021-12-20","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#features_22","title":"Features","text":"<ul> <li>Add support for Python 3.7 (4535adc by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_43","title":"Bug Fixes","text":"<ul> <li>Don't propagate aliases of an alias (8af48f8 by Timoth\u00e9e Mazzucotelli).</li> <li>Don't reassign members defined in except clauses (d918b4e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#040-2021-11-28","title":"0.4.0 - 2021-11-28","text":"<p>Compare with 0.3.0</p>"},{"location":"changelog/#features_23","title":"Features","text":"<ul> <li>Add a prototype 'hybrid' extension (8cb3c16 by Timoth\u00e9e Mazzucotelli).</li> <li>Allow passing extensions config as JSON on the CLI (9a7fa8b by Timoth\u00e9e Mazzucotelli).</li> <li>Support names for returns, yields and receives sections items (1c5a4c9 by Timoth\u00e9e Mazzucotelli).</li> <li>Store aliases on each object (91ba643 by Timoth\u00e9e Mazzucotelli).</li> <li>Support in[tro]spection (3a0587d by Timoth\u00e9e Mazzucotelli).</li> <li>Support multiple return, yield and receive items (0fc70cb by Timoth\u00e9e Mazzucotelli).</li> <li>Support namespace packages (2414c8e by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_44","title":"Bug Fixes","text":"<ul> <li>Fix extensions loader (78fb70b by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid visiting/inspecting multiple times (75a8a8b by Timoth\u00e9e Mazzucotelli).</li> <li>Set modules collection attribute earlier (592c0bd by Timoth\u00e9e Mazzucotelli).</li> <li>Support inequality nodes (b0ed247 by Timoth\u00e9e Mazzucotelli).</li> <li>Handle Div nodes for values (272e4d6 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_24","title":"Code Refactoring","text":"<ul> <li>Set log level to INFO (718e73e by Timoth\u00e9e Mazzucotelli).</li> <li>Add target setter (7f0064c by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize conditions (15ab876 by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid recursion loops (ea6acec by Timoth\u00e9e Mazzucotelli).</li> <li>Update aliases when replacing a member (99a0f8b by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize code (31fcdb1 by Timoth\u00e9e Mazzucotelli).</li> <li>Replace DocstringException with DocstringRaise (d5ed87a by Timoth\u00e9e Mazzucotelli).</li> <li>Refactor loaders (d9b94bb by Timoth\u00e9e Mazzucotelli).</li> <li>Improve typing (e08bcfa by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#030-2021-11-21","title":"0.3.0 - 2021-11-21","text":"<p>Compare with 0.2.0</p>"},{"location":"changelog/#features_24","title":"Features","text":"<ul> <li>Handle aliases and their resolution (67ae903 by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve annotations in docstrings (847384a by Timoth\u00e9e Mazzucotelli).</li> <li>Resolve annotations (6451eff by Timoth\u00e9e Mazzucotelli).</li> <li>Add lines property to objects (7daf7db by Timoth\u00e9e Mazzucotelli).</li> <li>Allow setting docstring parser and options on each object (07a1d2e by Timoth\u00e9e Mazzucotelli).</li> <li>Get attributes annotations from parent (003b990 by Timoth\u00e9e Mazzucotelli).</li> <li>Draft extensions loader (17ccd03 by Timoth\u00e9e Mazzucotelli).</li> <li>Add properties to objects (0ec301a by Timoth\u00e9e Mazzucotelli).</li> <li>Handle .pth files when searching modules (2a2e182 by Timoth\u00e9e Mazzucotelli).</li> <li>Add <code>default</code> property to docstring parameters (6298ba3 by Timoth\u00e9e Mazzucotelli).</li> <li>Accept RST and Numpy parsers (1cf147d by Timoth\u00e9e Mazzucotelli).</li> <li>Support data (attributes/variables) (dce84d1 by Timoth\u00e9e Mazzucotelli).</li> <li>Add Numpy-style parser (ad5b72d by Timoth\u00e9e Mazzucotelli).</li> <li>Support more section kinds in Google-style (9d3d047 by Timoth\u00e9e Mazzucotelli).</li> <li>Add docstring section kinds (b270483 by Timoth\u00e9e Mazzucotelli).</li> <li>Accept initial arguments when creating container (90c5956 by Timoth\u00e9e Mazzucotelli).</li> <li>Add an RST-style docstring parser (742e7b2 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#performance-improvements_1","title":"Performance Improvements","text":"<ul> <li>Improve JSON encoder perfs (6a78eb0 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#bug-fixes_45","title":"Bug Fixes","text":"<ul> <li>Handle serialization of Posix paths (3a66b95 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix list annotation getter (5ae800a by Timoth\u00e9e Mazzucotelli).</li> <li>Show accurate line number in Google warnings (2953590 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix assignment names getters (6990846 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix async loader (passing parent) (57e866e by Timoth\u00e9e Mazzucotelli).</li> <li>Fix exception name (4b8b85d by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google sections titles logic (87dd329 by Timoth\u00e9e Mazzucotelli).</li> <li>Prepend current module to base classes (still needs resolution) (a4b1dee by Timoth\u00e9e Mazzucotelli).</li> <li>Fix Google admonition regex (3902e74 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix docstring getter (1442eba by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting arguments defaults in the Google-style parser (67adbaf by Timoth\u00e9e Mazzucotelli).</li> <li>Fix getting arguments annotations in the Google-style parser (8bcbfba by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring_25","title":"Code Refactoring","text":"<ul> <li>Export parsers and main function in docstrings module (96469da by Timoth\u00e9e Mazzucotelli).</li> <li>Remove top exports (cd76694 by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize exceptions (7f9b805 by Timoth\u00e9e Mazzucotelli).</li> <li>Avoid circular import (ef27dcd by Timoth\u00e9e Mazzucotelli).</li> <li>Rename index to [new] offset (c07cc7d by Timoth\u00e9e Mazzucotelli).</li> <li>Reorganize code (5f4fff2 by Timoth\u00e9e Mazzucotelli).</li> <li>Use keyword only parameters (d34edd6 by Timoth\u00e9e Mazzucotelli).</li> <li>Default to no parsing for serialization (8fecd9e by Timoth\u00e9e Mazzucotelli).</li> <li>Always extend AST (c227ae6 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default for kwargs parameters (7a0b85e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename visitor method (3e0c43c by Timoth\u00e9e Mazzucotelli).</li> <li>Improve typing (ac86f17 by Timoth\u00e9e Mazzucotelli).</li> <li>Fix typo (a9ed6e9 by Timoth\u00e9e Mazzucotelli).</li> <li>Rewrite ParameterKind (90249df by Timoth\u00e9e Mazzucotelli).</li> <li>Add bool methods to docstrings and objects (548f72e by Timoth\u00e9e Mazzucotelli).</li> <li>Allow setting docstring parser and options on each docstring (752e084 by Timoth\u00e9e Mazzucotelli).</li> <li>Skip attribute assignments (e9cc2cd by Timoth\u00e9e Mazzucotelli).</li> <li>Improve visitor getters (2ea88c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Use relative filepath in docstring warnings (e894df7 by Timoth\u00e9e Mazzucotelli).</li> <li>Set submodules parent earlier (53767c0 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename Data to Attribute (febc12e by Timoth\u00e9e Mazzucotelli).</li> <li>Rename arguments to parameters (957856c by Timoth\u00e9e Mazzucotelli).</li> <li>Improve annotation support (5b2262f by Timoth\u00e9e Mazzucotelli).</li> <li>Always set parent (cae85de by Timoth\u00e9e Mazzucotelli).</li> <li>Factorize function handling (dfece1c by Timoth\u00e9e Mazzucotelli).</li> <li>Privatize stuff, fix loggers (5513ed5 by Timoth\u00e9e Mazzucotelli).</li> <li>Use keyword only arguments (e853fe9 by Timoth\u00e9e Mazzucotelli).</li> <li>Set default values for Argument arguments (d5cccaa by Timoth\u00e9e Mazzucotelli).</li> <li>Swallow extra parsing options (3d9ebe7 by Timoth\u00e9e Mazzucotelli).</li> <li>Rename <code>start_index</code> argument to <code>offset</code> (dd88358 by Timoth\u00e9e Mazzucotelli).</li> <li>Reuse parsers warn function (03dfdd3 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#020-2021-09-25","title":"0.2.0 - 2021-09-25","text":"<p>Compare with 0.1.0</p>"},{"location":"changelog/#features_25","title":"Features","text":"<ul> <li>Add Google-style docstring parser (cdefccc by Timoth\u00e9e Mazzucotelli).</li> <li>Support all kinds of functions arguments (c177562 by Timoth\u00e9e Mazzucotelli).</li> <li>Initial support for class decorators and bases (8e229aa by Timoth\u00e9e Mazzucotelli).</li> <li>Add functions decorators support (fee304d by Timoth\u00e9e Mazzucotelli).</li> <li>Add async loader (3218bd0 by Timoth\u00e9e Mazzucotelli).</li> <li>Add relative file path and package properties (d26ee1f by Timoth\u00e9e Mazzucotelli).</li> <li>Add search and output option to the CLI (3b37692 by Timoth\u00e9e Mazzucotelli).</li> <li>Load docstrings and functions arguments (cdf29a3 by Timoth\u00e9e Mazzucotelli).</li> <li>Support paths in loader (8f4df75 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#performance-improvements_2","title":"Performance Improvements","text":"<ul> <li>Avoid name lookups in visitor (00de148 by Timoth\u00e9e Mazzucotelli).</li> <li>Factorize and improve main and extensions visitors (9b27b56 by Timoth\u00e9e Mazzucotelli).</li> <li>Delegate children computation at runtime (8d54c87 by Timoth\u00e9e Mazzucotelli).</li> <li>Cache dataclasses properties (2d7447d by Timoth\u00e9e Mazzucotelli).</li> <li>Optimize node linker (03f955e by Timoth\u00e9e Mazzucotelli).</li> <li>Optimize docstring getter (4a05516 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#010-2021-09-09","title":"0.1.0 - 2021-09-09","text":"<p>Compare with first commit</p>"},{"location":"changelog/#features_26","title":"Features","text":"<ul> <li>Add initial code (8cbdf7a by Timoth\u00e9e Mazzucotelli).</li> <li>Generate project from copier-pdm template (7ea73ad by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"checking/","title":"Checking for API breakages","text":"<p>Griffe is able to compare two snapshots of your project to detect API breakages between the old and the new snapshot. By snapshot we mean a specific point in your Git history. For example, you can ask Griffe to compare your current code against a specific tag.</p> <p>By default, Griffe will compare the current code to the latest tag:</p> <pre><code>$ griffe check mypackage\n</code></pre> <p>To specify another Git reference to check against, use the <code>--against</code> or <code>-a</code> option:</p> <pre><code>$ griffe check mypackage -a 0.2.0\n</code></pre> <p>You can specify a Git tag, commit (hash), or even a branch: Griffe will create a worktree at this reference in a temporary directory, and clean it up after finishing.</p> <p>If you want to also specify the base reference to use (instead of the current code), use the <code>--base</code> or <code>-b</code> option. Some examples:</p> <pre><code>$ griffe check mypackage -b HEAD -a 2.0.0\n$ griffe check mypackage -b 2.0.0 -a 1.0.0\n$ griffe check mypackage -b fix-issue-90 -a 1.2.3 $ griffe check mypackage -b 8afcfd6e </code></pre> <p>Important:</p> <p>Remember that the base is the most recent reference, and the one we compare it against is the oldest one.</p> <p>The package name you pass to <code>griffe check</code> must be found relatively to the repository root. For Griffe to find packages in subfolders, pass the parent subfolder to the  <code>--search</code> or <code>-s</code> option. Example for <code>src</code>-layouts:</p> <pre><code>$ griffe check -s src griffe\n</code></pre> <p>Example in a monorepo, within a deeper file tree:</p> <pre><code>$ griffe check -s back/services/identity-provider/src identity_provider\n</code></pre>"},{"location":"checking/#detected-breakages","title":"Detected breakages","text":"<p>In this section, we will describe the breakages that Griffe detects, giving some code examples and hints on how to properly communicate breakages with deprecation messages before actually releasing them.</p> <p>Obviously, these explanations and the value of the hints we provide depend on your definition of what is a public Python API. There is no clear and generally agreed upon definition of \"public Python API\". A public Python API might vary from one project to another.  In essence, your public API is what you say it is.</p> <p>However, we do have conventions like prefixing objects with an underscore to tell users these objects are part of the private API, or internals, and therefore should not be used. For the rest, Griffe can detect changes that will trigger immediate errors in your users code', and changes that might cause issues in your users' code. Although the latter sound less impactful, they do have a serious impact, because they can silently change the behavior of your users' code, leading to issues that are hard to detect, understand and fix.</p> <p>Knowing that every change is a breaking change, the more we detect and document (potentially) breaking changes in our changelogs, the better.</p>"},{"location":"checking/#parameter-moved","title":"Parameter moved","text":"<p>Positional parameter was moved.</p> <p>Moving the order of positional parameters can silently break your users' code.</p> before<pre><code># your code\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: no immediate error, broken behavior\ngreet(\"hello\", \"world\")\n</code></pre> <p>Note</p> <p>Moving required parameters around is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The function expects a number of arguments, and the developer pass it this same number of arguments: the contract is fulfilled. But parameters very often have specific meaning, and changing their order will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>If you often add, move or remove parameters, consider making them keyword-only, so that their order doesn't matter.</p> before<pre><code>def greet(*, prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> after<pre><code>def greet(*, name, prefix):\n    print(prefix + \" \" + name)\n\n# still working as expected\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre>"},{"location":"checking/#parameter-removed","title":"Parameter removed","text":"<p>Parameter was removed.</p> <p>Removing a parameter can immediately break your users' code.</p> before<pre><code># your code\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\n# user's code: immediate error\ngreet(\"hello\", \"world\")\n\n# even with keyword parameters: immediate error\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> <p>Hint</p> <p>Allow a deprecation period for the removed parameter by swallowing it in a variadic positional parameter, a variadic keyword parameter, or both.</p> positional-onlykeyword-onlypositional or keyword before<pre><code># your parameters are positional-only parameters (difficult deprecation)\ndef greet(prefix, name, /):\n    print(prefix + \" \" + name)\n\ngreet(\"hello\", \"world\")\n</code></pre> after<pre><code># swallow prefix using a variadic positional parameter\ndef greet(*args):\n    if len(args) == 2:\n        prefix, name = args\n    elif len(args) == 1:\n        prefix = None\n        name = args[0]\n    else:\n        raise ValueError(\"missing parameter 'name'\")\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(\"hello\", \"world\")\n</code></pre> before<pre><code># your parameters are keyword-only parameters (easy deprecation)\ndef greet(*, prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> after<pre><code># swallow prefix using a variadic keyword parameter\ndef greet(name, **kwargs):\n    prefix = kwargs.get(\"prefix\", None)\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre> before<pre><code># your parameters are positional or keyword parameters (very difficult deprecation)\ndef greet(prefix, name):\n    print(prefix + \" \" + name)\n\ngreet(\"hello\", name=\"world\")\n</code></pre> after<pre><code># no other choice than swallowing both forms...\n# ignoring the deprecated parameter becomes quite complex\ndef greet(*args, **kwargs):\n    if len(args) == 2:\n        prefix, name = args\n    elif len(args) == 1:\n        prefix = None\n        name = args[0]\n    if \"name\" in kwargs:\n        name = kwargs[\"name\"]\n    if \"prefix\" in kwargs:\n        prefix = kwargs[\"prefix\"]\n    if prefix is not None:\n        warnings.warn(DeprecationWarning, \"prefix is deprecated\")\n    print(\"hello \" + name)\n\n# still working as expected\ngreet(\"hello\", \"world\")\ngreet(\"hello\", name=\"world\")\ngreet(prefix=\"hello\", name=\"world\")\n</code></pre>"},{"location":"checking/#parameter-changed-kind","title":"Parameter changed kind","text":"<p>Parameter kind was changed</p> <p>Changing the kind of a parameter to another (positional-only, keyword-only, positional or keyword, variadic positional, variadic keyword) can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\ndef greet2(name):\n    print(\"hello \" + name)\n\n# user's code: all working fine\ngreet(\"tim\")\ngreet(name=\"tim\")\ngreet2(\"tim\")\ngreet2(name=\"tim\")\n</code></pre> after<pre><code># your code\ndef greet(name, /):\n    print(\"hello \" + name)\n\ndef greet2(*, name):\n    print(\"hello \" + name)\n\n# user's code: working as expected\ngreet(\"tim\")\ngreet2(name=\"tim\")\n\n# immediate error\ngreet(name=\"tim\")\ngreet2(\"tim\")\n</code></pre> <p>Hint</p> <p>Although it actually is a breaking change, changing your positional or keyword parameters' kind to keyword-only makes your public function more robust to future changes (forward-compatibility).</p> <p>For functions with lots of optional parameters, and a few (one or two) required parameters, it can be a good idea to accept the required parameters as positional or keyword, while accepting the optional parameters as keyword-only parameters:</p> <pre><code>def greet(name, *, punctuation=False, bold=False, italic=False):\n    ...\n\n# simple cases are easy to write\ngreet(\"tim\")\ngreet(\"tiff\")\n\n# complex cases are never ambiguous\ngreet(\"tim\", italic=True, bold=True)\ngreet(name=\"tiff\", bold=True, punctuation=True)\n</code></pre> <p>Positional-only parameters are useful in some specific cases, such as when a function takes two or more numeric values, and their order does not matter, and naming the parameters would not make sense:</p> <pre><code>def multiply3(a, b, c, /):\n    return a * b * c\n\n# all the following are equivalent\nmultiply3(4, 2, 3)\nmultiply3(4, 3, 2)\nmultiply3(2, 3, 4)\n# etc.\n</code></pre>"},{"location":"checking/#parameter-changed-default","title":"Parameter changed default","text":"<p>Parameter default was changed</p> <p>Changing the default value of a parameter can silently break your users' code.</p> before<pre><code># your code\ndef compute_something(value: int, to_float=True):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n\n# user's code: condition is entered\nif isinstance(compute_something(7), float):\n    ...\n</code></pre> after<pre><code># your code\ndef compute_something(value: int, to_float=False):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n\n# user's code: condition is not entered anymore\nif isinstance(compute_something(7), float):\n    ...\n</code></pre> <p>Note</p> <p>Changing default value of parameters is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. Not using the parameter still provides the argument with a default value: the contract is fulfilled. But default values very often have specific meaning, and changing them will silently lead (no immediate error) to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>Allow a deprecation period for the old default value by using a sentinel value to detect when the parameter wasn't used by the user:</p> in the coming release<pre><code>_sentinel = object()\n\ndef compute_something(value: int, to_float=_sentinel):\n    value = ...\n    if to_float is _sentinel:\n        to_float = True\n        warnings.warn(\n            DeprecationWarning,\n            \"default value of 'to_float' will change from True to False, \"\n            \"please provide 'to_float=True' if you want to retain the current behavior\"\n        )\n    if to_float:\n        return float(value)\n    return value\n</code></pre> <p>In a later release you can remove the sentinel, the deprecation warning, and set <code>False</code> as default to <code>to_float</code>.</p> in a later release<pre><code>def compute_something(value: int, to_float=False):\n    value = ...\n    if to_float:\n        return float(value)\n    return value\n</code></pre>"},{"location":"checking/#parameter-changed-required","title":"Parameter changed required","text":"<p>Parameter is now required</p> <p>Changing an optional parameter to a required one (by removing its default value) can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name, prefix=\"hello\"):\n    print(prefix + \" \" + name)\n\n# user's code\ngreet(\"tiff\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: immediate error\ngreet(\"tiff\")\n</code></pre> <p>Hint</p> <p>Allow a deprecation period for the default value by using a sentinel value to detect when the parameter wasn't used by the user:</p> in the coming release<pre><code>_sentinel = object()\n\ndef greet(name, prefix=_sentinel):\n    if prefix is _sentinel:\n        prefix = \"hello\"\n        warnings.warn(DeprecationWarning, \"'prefix' will become required in the next release\")\n    print(prefix + \" \" + name)\n</code></pre> <p>In a later release you can remove the sentinel, the deprecation warning, and the default value of <code>prefix</code>.</p> in a later release<pre><code>def greet(name, prefix):\n    print(prefix + \" \" + name)\n</code></pre>"},{"location":"checking/#parameter-added-required","title":"Parameter added required","text":"<p>Parameter was added as required</p> <p>Adding a new, required parameter can immediately break your users' code.</p> before<pre><code># your code\ndef greet(name):\n    print(\"hello \" + name)\n\n# user's code\ngreet(\"tiff\")\n</code></pre> after<pre><code># your code\ndef greet(name, prefix):\n    print(prefix + \" \" + name)\n\n# user's code: immediate error\ngreet(\"tiff\")\n</code></pre> <p>Hint</p> <p>You can delay (or avoid) and inform your users about the upcoming breakage by temporarily (or permanently) providing a default value for the new parameter:</p> in the coming release<pre><code>def greet(name, prefix=\"hello\"):\n    print(prefix + \" \" + name)\n</code></pre>"},{"location":"checking/#return-changed-type","title":"Return changed type","text":"<p>Return types are incompatible</p> <p>Not yet supported!</p> <p> Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.</p>"},{"location":"checking/#object-removed","title":"Object removed","text":"<p>Public object was removed</p> <p>Removing a public object from a module can immediately break your users' code.</p> before<pre><code># your/module.py\nspecial_thing = \"hey\"\n\n# user/module.py\nfrom your.module import special_thing\n\n# other/user/module.py\nfrom your import module\nprint(module.special_thing)\n</code></pre> after<pre><code># user/module.py: import error\nfrom your.module import special_thing\n\n# other/user/module.py: attribute error\nfrom your import module\nprint(module.special_thing)\n</code></pre> <p>Hint</p> <p>Allow a deprecation period by declaring a module-level <code>__getattr__</code> function that returns the given object while warning about its deprecation:</p> <pre><code>def __getattr__(name):\n    if name == \"special_thing\":\n        warnings.warn(DeprecationWarning, \"'special_thing' is deprecated and will be removed\")\n        return \"hey\"\n</code></pre>"},{"location":"checking/#object-changed-kind","title":"Object changed kind","text":"<p>Public object points to a different kind of object</p> <p>Changing the kind (attribute, function, class, module) of a public object can silently break your users' code.</p> before<pre><code># your code\nclass Factory:\n    def __call__(self, ...):\n        ...\n\nfactory = Factory(...)\n\n# user's code: condition is entered\nif isinstance(factory, Factory):\n    ...\n</code></pre> after<pre><code># your code\nclass Factory:\n    ...\n\ndef factory(...):\n    ...\n\n# user's code: condition is not entered anymore\nif isinstance(factory, Factory):\n    ...\n</code></pre> <p>Note</p> <p>Changing the kind of an object is not really an API breakage, depending on our definition of API, since this won't always raise immediate errors like <code>TypeError</code>. The object is still here and accessed: the contract is fulfilled. But developers sometimes rely on the kind of an object, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p>"},{"location":"checking/#attribute-changed-type","title":"Attribute changed type","text":"<p>Attribute types are incompatible</p> <p>Not yet supported!</p> <p> Telling if a type construct is compatible with another one is not trivial, especially statically. Support for this will be implemented later.</p>"},{"location":"checking/#attribute-changed-value","title":"Attribute changed value","text":"<p>Attribute value was changed</p> <p>Changing the value of an attribute can silently break your users' code.</p> before<pre><code># your code\nPY_VERSION = os.getenv(\"PY_VERSION\")\n\n# user's code: condition is entered\nif PY_VERSION is None:\n    ...\n</code></pre> after<pre><code># your code\nPY_VERSION = os.getenv(\"PY_VERSION\", \"3.8\")\n\n# user's code: condition is not entered anymore\nif PY_VERSION is None:\n    ...\n</code></pre> <p>Note</p> <p>Changing the value of an attribute is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The attribute is still here and accessed: the contract is fulfilled. But developers heavily rely on the value of public attributes, so changing it will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p> <p>Hint</p> <p>Make sure to document the change of value of the attribute in your changelog, particularly the previous and new range of values it can take.</p>"},{"location":"checking/#class-removed-base","title":"Class removed base","text":"<p>Base class was removed</p> <p>Removing a class from another class' bases can silently break your users' code.</p> before<pre><code># your code\nclass A: ...\nclass B: ...\nclass C(A, B): ...\n\n# user's code: condition is entered\nif B in klass.__bases__:\n    ...\n</code></pre> after<pre><code># your code\nclass A: ...\nclass B: ...\nclass C(A): ...\n\n# user's code: condition is not entered anymore\nif B in klass.__bases__:\n    ...\n</code></pre> <p>Note</p> <p>Unless inherited members are lost in the process, removing a class base is not really an API breakage, depending on our definition of API, since this won't raise immediate errors like <code>TypeError</code>. The class is here, its members as well: the contract is fulfilled. But developers sometimes rely on the actual bases of a class, so changing them will lead to incorrect behavior, potentially making it difficult to detect, understand and fix the issue. That is why it is important to warn developers about such changes.</p>"},{"location":"checking/#output-style","title":"Output style","text":"<p>By default, Griffe will print each detected breakage on a single line, on <code>stderr</code>:</p> <pre><code>$ griffe check griffe -ssrc -b0.24.0 -a0.23.0\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported): Parameter default was changed: True -&gt; None\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules): Parameter default was changed: True -&gt; None\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(max_iterations): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_exported): Parameter was removed\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_known_modules): Parameter was removed\nsrc/griffe/git.py:39: tmp_worktree(commit): Parameter was removed\nsrc/griffe/git.py:39: tmp_worktree(repo): Positional parameter was moved: position: from 2 to 1 (-1)\nsrc/griffe/git.py:75: load_git(commit): Parameter was removed\nsrc/griffe/git.py:75: load_git(repo): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(submodules): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(try_relative_path): Parameter was removed\nsrc/griffe/git.py:75: load_git(extensions): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(search_paths): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(docstring_parser): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(docstring_options): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(lines_collection): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(modules_collection): Parameter kind was changed: positional or keyword -&gt; keyword-only\nsrc/griffe/git.py:75: load_git(allow_inspection): Parameter kind was changed: positional or keyword -&gt; keyword-only\n\n</code></pre> <p>Depending on the detected breakages, the lines might be hard to read (being too compact), so <code>griffe check</code> also accepts a <code>--verbose</code> or <code>-v</code> option to add some space to the output:</p> <pre><code>$ griffe check griffe -ssrc -b0.24.0 -a0.23.0 --verbose\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_exported):\nParameter default was changed:\n  Old: True\n  New: None\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(only_known_modules):\nParameter default was changed:\n  Old: True\n  New: None\n\nsrc/griffe/loader.py:156: GriffeLoader.resolve_aliases(max_iterations):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/loader.py:308: GriffeLoader.resolve_module_aliases(only_exported):\nParameter was removed\n\nsrc/griffe/loader.py:308: \nGriffeLoader.resolve_module_aliases(only_known_modules):\nParameter was removed\n\nsrc/griffe/git.py:39: tmp_worktree(commit):\nParameter was removed\n\nsrc/griffe/git.py:39: tmp_worktree(repo):\nPositional parameter was moved:\n  Details: position: from 1 to 0 (-1)\n\nsrc/griffe/git.py:75: load_git(commit):\nParameter was removed\n\nsrc/griffe/git.py:75: load_git(repo):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(submodules):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(try_relative_path):\nParameter was removed\n\nsrc/griffe/git.py:75: load_git(extensions):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(search_paths):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(docstring_parser):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(docstring_options):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(lines_collection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(modules_collection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\nsrc/griffe/git.py:75: load_git(allow_inspection):\nParameter kind was changed:\n  Old: positional or keyword\n  New: keyword-only\n\n</code></pre>"},{"location":"cli_reference/","title":"CLI reference","text":""},{"location":"cli_reference/#griffe","title":"griffe","text":"<p>Signatures for entire Python programs. </p> <p>Global Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit. Commands also accept the -h/--help option.</li> </ul> <p>Commands:</p>"},{"location":"cli_reference/#dump","title":"dump","text":"<p>Load package-signatures and dump them as JSON.</p> <p>Search Options:</p> <ul> <li><code>-s</code>, <code>--search</code>: Paths to search packages into.</li> </ul> <p>Loading Options:</p> <ul> <li><code>-e</code>, <code>--extensions</code>: A list of extensions to use.</li> <li><code>-X</code>, <code>--no-inspection</code>: Disallow inspection of builtin/compiled/not found modules. Default: <code>True</code>.</li> </ul> <p>Dump Options:</p> <ul> <li><code>packages</code> <code>PACKAGE</code>: Packages to find, load and dump.</li> <li><code>-f</code>, <code>--full</code>: Whether to dump full data in JSON.</li> <li><code>-o</code>, <code>--output</code>: Output file. Supports templating to output each package in its own file, with <code>{package}</code>. Default: <code>sys.stdout</code>.</li> <li><code>-d</code>, <code>--docstyle</code>: The docstring style to parse.</li> <li><code>-D</code>, <code>--docopts</code>: The options for the docstring parser.</li> <li><code>-y</code>, <code>--sys-path</code>: Whether to append <code>sys.path</code> to search paths specified with <code>-s</code>.</li> <li><code>-r</code>, <code>--resolve-aliases</code>: Whether to resolve aliases.</li> <li><code>-I</code>, <code>--resolve-implicit</code>: Whether to resolve implicitely exported aliases as well. Aliases are explicitely exported when defined in <code>__all__</code>.</li> <li><code>-U</code>, <code>--resolve-external</code>: Whether to resolve aliases pointing to external/unknown modules (not loaded directly).</li> <li><code>-S</code>, <code>--stats</code>: Show statistics at the end.</li> </ul> <p>Debugging Options:</p> <ul> <li><code>-L</code>, <code>--log-level</code> <code>LEVEL</code>: Set the log level: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. Default: <code>INFO</code>.</li> </ul> <p>Common Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit.</li> </ul>"},{"location":"cli_reference/#check","title":"check","text":"<p>Check for API breakages or possible improvements.</p> <p>Search Options:</p> <ul> <li><code>-s</code>, <code>--search</code>: Paths to search packages into.</li> </ul> <p>Loading Options:</p> <ul> <li><code>-e</code>, <code>--extensions</code>: A list of extensions to use.</li> <li><code>-X</code>, <code>--no-inspection</code>: Disallow inspection of builtin/compiled/not found modules. Default: <code>True</code>.</li> </ul> <p>Debugging Options:</p> <ul> <li><code>-L</code>, <code>--log-level</code> <code>LEVEL</code>: Set the log level: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code>. Default: <code>INFO</code>.</li> </ul> <p>Common Options:</p> <ul> <li><code>-h</code>, <code>--help</code>: Show this help message and exit.</li> </ul> <p>Check Options:</p> <ul> <li><code>package</code> <code>PACKAGE</code>: Package to find, load and check, as path.</li> <li><code>-a</code>, <code>--against</code> <code>REF</code>: Older Git reference (commit, branch, tag) to check against. Default: load latest tag.</li> <li><code>-b</code>, <code>--base-ref</code> <code>BASE_REF</code>: Git reference (commit, branch, tag) to check. Default: load current code.</li> <li><code>-v</code>, <code>--verbose</code>: Verbose output.</li> </ul>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pawamoy@pm.me. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd griffe\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install pdm\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>pdm install</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>pdm run griffe [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following:</p> <ol> <li><code>export PYTHON_VERSIONS=</code>: this will run the task    with only the current Python version</li> <li>run the task directly with <code>pdm run duty TASK</code></li> </ol> <p>The Makefile detects if a virtual environment is activated, so <code>make</code> will work the same with the virtualenv activated or not.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git checkout -b feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash master\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":"<p><p>These projects were used to build griffe. Thank you!</p> <p><code>python</code> | <code>pdm</code> | <code>copier-pdm</code></p> </p>"},{"location":"credits/#exec-2--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>cached-property</code> A decorator for caching properties in classes. <code>; python_version &lt; '3.8'</code> <code>1.5.2</code> ? <code>colorama</code> Cross-platform colored terminal text. <code>&gt;=0.4</code> <code>0.4.6</code> BSD License"},{"location":"credits/#exec-2--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License <code>ansimarkup</code> Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License <code>attrs</code> Classes Without Boilerplate <code>&gt;=17.4.0</code> <code>23.1.0</code> MIT License <code>babel</code> Internationalization utilities <code>&gt;=2.10.3</code> <code>2.12.1</code> BSD <code>beautifulsoup4</code> Screen-scraping library <code>4.12.2</code> MIT License <code>black</code> The uncompromising code formatter. <code>&gt;=23.1</code> <code>23.3.0</code> MIT <code>blacken-docs</code> Run Black on Python code blocks in documentation files. <code>&gt;=1.13</code> <code>1.13.0</code> MIT <code>cached-property</code> A decorator for caching properties in classes. <code>&gt;=1.5; python_version &lt; \"3.8\"</code> <code>1.5.2</code> ? <code>certifi</code> Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2022.12.7</code> MPL-2.0 <code>charset-normalizer</code> The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&lt;4,&gt;=2</code> <code>3.1.0</code> MIT <code>click</code> Composable command line interface toolkit <code>&gt;=8.0.0</code> <code>8.1.3</code> BSD-3-Clause <code>colorama</code> Cross-platform colored terminal text. <code>; platform_system == \"Windows\"</code> <code>0.4.6</code> BSD License <code>coverage</code> Code coverage measurement for Python <code>[toml]&gt;=5.2.1</code> <code>7.2.5</code> Apache-2.0 <code>csscompressor</code> A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD <code>cssselect</code> cssselect parses CSS3 Selectors and translates them to XPath 1.0 <code>&gt;=1.2.0</code> <code>1.2.0</code> BSD <code>dparse</code> A parser for Python dependency files <code>&gt;=0.6.2</code> <code>0.6.2</code> MIT license <code>duty</code> A simple task runner. <code>&gt;=0.10</code> <code>0.11.0</code> ISC <code>exceptiongroup</code> Backport of PEP 654 (exception groups) <code>&gt;=1.0.0rc8; python_version &lt; \"3.11\"</code> <code>1.1.1</code> MIT License <code>execnet</code> execnet: rapid multi-Python deployment <code>&gt;=1.1</code> <code>1.9.0</code> MIT <code>failprint</code> Run a command, print its output only if it fails. <code>&gt;=0.11</code> <code>0.11.1</code> ISC <code>ghp-import</code> Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License <code>git-changelog</code> Automatic Changelog generator using Jinja2 templates. <code>&gt;=1.0</code> <code>1.0.0</code> ISC <code>gitdb</code> Git Object Database <code>&lt;5,&gt;=4.0.1</code> <code>4.0.10</code> BSD License <code>gitpython</code> GitPython is a Python library used to interact with Git repositories <code>3.1.31</code> BSD <code>htmlmin2</code> An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD <code>hypothesis</code> A library for property-based testing <code>[lark]&gt;=6.58.1</code> <code>6.75.2</code> MPL-2.0 <code>hypothesmith</code> Hypothesis strategies for generating Python programs, something like CSmith <code>&gt;=0.2.0</code> <code>0.2.3</code> MPL 2.0 <code>idna</code> Internationalized Domain Names in Applications (IDNA) <code>&lt;4,&gt;=2.5</code> <code>3.4</code> BSD License <code>importlib-metadata</code> Read metadata from Python packages <code>; python_version &lt; \"3.8\"</code> <code>6.6.0</code> Apache Software License <code>importlib-resources</code> Read resources from Python packages <code>&gt;=1.4.0; python_version &lt; \"3.9\"</code> <code>5.12.0</code> Apache Software License <code>iniconfig</code> brain-dead simple config-ini parsing <code>2.0.0</code> MIT License <code>jinja2</code> A very fast and expressive template engine. <code>&lt;4,&gt;=2.11</code> <code>3.1.2</code> BSD-3-Clause <code>jsmin</code> JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License <code>jsonschema</code> An implementation of JSON Schema validation for Python <code>&gt;=4.17.3</code> <code>4.17.3</code> MIT <code>lark</code> a modern parsing library <code>&gt;=0.10.1</code> <code>1.1.5</code> MIT <code>libcst</code> A concrete syntax tree with AST-like properties for Python 3.5, 3.6, 3.7, 3.8, 3.9, and 3.10 programs. <code>&gt;=0.4.0</code> <code>0.4.9</code> MIT <code>lxml</code> Powerful and Pythonic XML processing library combining libxml2/libxslt with the ElementTree API. <code>&gt;=4.6</code> <code>4.9.2</code> BSD-3-Clause <code>markdown</code> Python implementation of Markdown. <code>&lt;4.0.0,&gt;=3.3.3</code> <code>3.3.7</code> BSD License <code>markdown-callouts</code> Markdown extension: a classier syntax for admonitions <code>&gt;=0.2</code> <code>0.3.0</code> MIT <code>markdown-exec</code> Utilities to execute code blocks in Markdown files. <code>&gt;=0.5</code> <code>1.6.0.1.0.0</code> ISC <code>markdown-it-py</code> Python port of markdown-it. Markdown parsing, done right! <code>&lt;3.0.0,&gt;=2.2.0</code> <code>2.2.0</code> MIT License <code>markdown2</code> A fast and complete Python implementation of Markdown <code>&gt;=2.4.3</code> <code>2.4.8</code> MIT <code>markupsafe</code> Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>2.1.2</code> BSD-3-Clause <code>mdurl</code> Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License <code>mergedeep</code> A deep merge function for \ud83d\udc0d. <code>&gt;=1.3.4</code> <code>1.3.4</code> MIT License <code>mkdocs</code> Project documentation with Markdown. <code>&gt;=1.3</code> <code>1.4.3</code> BSD License <code>mkdocs-coverage</code> MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=0.2</code> <code>0.2.7</code> ISC <code>mkdocs-gen-files</code> MkDocs plugin to programmatically generate documentation pages during the build <code>&gt;=0.3</code> <code>0.5.0</code> MIT License <code>mkdocs-git-committers-plugin-2</code> An MkDocs plugin to create a list of contributors on the page <code>&gt;=1.1</code> <code>1.1.2</code> MIT <code>mkdocs-literate-nav</code> MkDocs plugin to specify the navigation in Markdown instead of YAML <code>&gt;=0.4</code> <code>0.6.0</code> MIT License <code>mkdocs-material</code> Documentation that simply works <code>&gt;=7.3</code> <code>9.1.9+insiders.4.32.6</code> MIT License <code>mkdocs-material-extensions</code> Extension pack for Python Markdown and MkDocs Material. <code>&gt;=1.1</code> <code>1.1.1</code> MIT License <code>mkdocs-minify-plugin</code> An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.6.4</code> <code>0.6.4</code> MIT <code>mkdocstrings</code> Automatic documentation from sources, for MkDocs. <code>[python]&gt;=0.18</code> <code>0.21.2</code> ISC <code>mkdocstrings-python</code> A Python handler for mkdocstrings. <code>&gt;=0.5.2</code> <code>0.10.0</code> ISC <code>mypy</code> Optional static typing for Python <code>&gt;=0.910</code> <code>1.2.0</code> MIT License <code>mypy-extensions</code> Type system extensions for programs checked with the mypy type checker. <code>&gt;=0.4.3</code> <code>1.0.0</code> MIT License <code>packaging</code> Core utilities for Python packages <code>&gt;=22.0</code> <code>23.1</code> BSD License <code>paginate</code> Divides large result sets into pages for easier browsing <code>&gt;=0.5.6</code> <code>0.5.6</code> MIT <code>pathspec</code> Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.11.1</code> Mozilla Public License 2.0 (MPL 2.0) <code>pipdeptree</code> Command line utility to show dependency tree of packages. <code>&gt;=2.3</code> <code>2.7.0</code> MIT License <code>pkgutil-resolve-name</code> Resolve a name to an object. <code>&gt;=1.3.10; python_version &lt; \"3.9\"</code> <code>1.3.10</code> MIT License <code>platformdirs</code> A small Python package for determining appropriate platform-specific dirs, e.g. a \"user data dir\". <code>&gt;=2</code> <code>3.5.0</code> MIT License <code>pluggy</code> plugin and hook calling mechanisms for python <code>&lt;2.0,&gt;=0.12</code> <code>1.0.0</code> MIT <code>ptyprocess</code> Run a subprocess in a pseudo terminal <code>~=0.6; sys_platform != \"win32\"</code> <code>0.7.0</code> ISC License (ISCL) <code>pygments</code> Pygments is a syntax highlighting package written in Python. <code>&gt;=2.14</code> <code>2.15.1</code> BSD-2-Clause <code>pymdown-extensions</code> Extension pack for Python Markdown. <code>&gt;=9</code> <code>9.11</code> MIT License <code>pyquery</code> A jquery-like library for python <code>&gt;=1.2</code> <code>2.0.0</code> BSD <code>pyrsistent</code> Persistent/Functional/Immutable data structures <code>!=0.17.0,!=0.17.1,!=0.17.2,&gt;=0.14.0</code> <code>0.19.3</code> MIT <code>pytest</code> pytest: simple powerful testing with Python <code>&gt;=6.2</code> <code>7.3.1</code> MIT <code>pytest-cov</code> Pytest plugin for measuring coverage. <code>&gt;=3.0</code> <code>4.0.0</code> MIT <code>pytest-randomly</code> Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.10</code> <code>3.12.0</code> MIT <code>pytest-xdist</code> pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=2.4</code> <code>3.2.1</code> MIT <code>python-dateutil</code> Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.8.2</code> Dual License <code>pytz</code> World timezone definitions, modern and historical <code>&gt;=2015.7; python_version &lt; \"3.9\"</code> <code>2023.3</code> MIT <code>pyyaml</code> YAML parser and emitter for Python <code>&gt;=5.2</code> <code>6.0</code> MIT <code>pyyaml-env-tag</code> A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>0.1</code> MIT License <code>readtime</code> Calculates the time some text takes the average human to read, based on Medium's read time forumula <code>&gt;=2.0</code> <code>2.0.0</code> BSD <code>regex</code> Alternative regular expression module, to replace re. <code>&gt;=2022.4.24</code> <code>2023.5.5</code> Apache Software License <code>requests</code> Python HTTP for Humans. <code>2.30.0</code> Apache 2.0 <code>rich</code> Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.6.0</code> <code>13.3.5</code> MIT <code>ruamel-yaml</code> ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order <code>&gt;=0.17.21</code> <code>0.17.24</code> MIT license <code>ruamel-yaml-clib</code> C version of reader, parser and emitter for ruamel.yaml derived from libyaml <code>&gt;=0.2.7; platform_python_implementation == \"CPython\" and python_version &lt; \"3.12\"</code> <code>0.2.7</code> MIT <code>ruff</code> An extremely fast Python linter, written in Rust. <code>&gt;=0.0.246</code> <code>0.0.265</code> MIT <code>safety</code> Checks installed dependencies for known vulnerabilities and licenses. <code>&gt;=2</code> <code>2.3.4</code> MIT license <code>semver</code> Python helper for Semantic Versioning (http://semver.org/) <code>~=2.13</code> <code>2.13.0</code> BSD <code>setuptools</code> Easily download, build, install, upgrade, and uninstall Python packages <code>&gt;=19.3</code> <code>67.7.2</code> MIT License <code>six</code> Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.16.0</code> MIT <code>smmap</code> A pure Python implementation of a sliding window memory map manager <code>&lt;6,&gt;=3.0.1</code> <code>5.0.0</code> BSD <code>soupsieve</code> A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.4.1</code> MIT License <code>toml</code> Python Library for Tom's Obvious, Minimal Language <code>&gt;=0.10</code> <code>0.10.2</code> MIT <code>tomli</code> A lil' TOML parser <code>&gt;=1.1.0; python_version &lt; \"3.11\"</code> <code>2.0.1</code> MIT License <code>typed-ast</code> a fork of Python 2 and 3 ast modules with type comment support <code>&gt;=1.4.2; python_version &lt; \"3.8\" and implementation_name == \"cpython\"</code> <code>1.5.4</code> ? <code>types-markdown</code> Typing stubs for Markdown <code>&gt;=3.3</code> <code>3.4.2.8</code> Apache-2.0 license <code>types-pyyaml</code> Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.9</code> Apache-2.0 license <code>types-toml</code> Typing stubs for toml <code>&gt;=0.10</code> <code>0.10.8.6</code> Apache-2.0 license <code>typing-extensions</code> Backported and Experimental Type Hints for Python 3.7+ <code>&gt;=3.10.0.0; python_version &lt; \"3.10\"</code> <code>4.5.0</code> Python Software Foundation License <code>typing-inspect</code> Runtime inspection utilities for typing module. <code>&gt;=0.4.0</code> <code>0.8.0</code> MIT <code>urllib3</code> HTTP library with thread-safe connection pooling, file post, and more. <code>&lt;3,&gt;=1.21.1</code> <code>2.0.2</code> MIT License <code>watchdog</code> Filesystem events monitoring <code>&gt;=2.0</code> <code>3.0.0</code> Apache License 2.0 <code>zipp</code> Backport of pathlib-compatible object wrapper for zip files <code>&gt;=0.5</code> <code>3.15.0</code> MIT License <p>More credits from the author</p>"},{"location":"docstrings/","title":"Docstrings","text":"<p>Griffe provides different docstring parsers allowing to extract even more structured data from source code.</p> <p>The available parsers are:</p> <ul> <li><code>google</code>, to parse Google-style docstrings,     see Napoleon's documentation</li> <li><code>numpy</code>, to parse Numpydoc docstrings,     see Numpydoc's documentation</li> <li><code>sphinx</code>, to parse Sphinx-style docstrings,     see Sphinx's documentation</li> </ul>"},{"location":"docstrings/#syntax","title":"Syntax","text":"<p>Most of the time, the syntax specified in the aforementioned docs is supported. In some cases, the original syntax is not supported, or is supported but with subtle differences. We will try to document these differences in the following sections.</p> <p>No assumption is made on the markup used in docstrings: it's retrieved as regular text. Tooling making use of Griffe can then choose to render the text as if it is Markdown, or AsciiDoc, or reStructuredText, etc..</p>"},{"location":"docstrings/#google-style","title":"Google-style","text":"<p>Sections are written like this:</p> <pre><code>section identifier: optional section title\n    section contents\n</code></pre> <p>All sections identifiers are case-insensitive. All sections support multiple lines in descriptions, as well as blank lines.</p> <p>Some sections also support documenting multiple items. When multiple items are supported, each item description can use multiple lines, and continuation lines must be indented once more so that the parser is able to differentiate items.</p> <pre><code>def foo(a, b):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n            Continuation line 1.\n\n            Continuation line 2.\n        b: Here's b.\n    \"\"\"\n</code></pre> <p>It's possible to start a description with a newline if you find it less confusing:</p> <pre><code>def foo(a, b):\n\"\"\"Foo.\n\n    Parameters:\n        a:\n            Here's a.\n            Continuation line 1.\n\n            Continuation line 2.\n        b: Here's b.\n    \"\"\"\n</code></pre>"},{"location":"docstrings/#attributes","title":"Attributes","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Attributes sections allow to document attributes of a module, class, or class instance. They should be used in modules and classes docstrings only.</p> <pre><code>\"\"\"My module.\n\nAttributes:\n    foo: Description for `foo`.\n    bar: Description for `bar`.\n\"\"\"\n\nfoo: int = 0\nbar: bool = True\n\n\nclass MyClass:\n\"\"\"My class.\n\n    Attributes:\n        foofoo: Description for `foofoo`.\n        barbar: Description for `barbar`.\n    \"\"\"\n\n    foofoo: int = 0\n\n    def __init__(self):\n        self.barbar: bool = True\n</code></pre> <p>Type annotations are fetched from the related attributes definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My module.\n\nAttributes:\n    foo (Integer): Description for `foo`.\n    bar (Boolean): Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting an attribute with <code>attr_name (attr_type): Attribute description</code>, <code>attr_type</code> will be resolved using the scope of the docstrings' parent object (class or module). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#deprecated","title":"Deprecated","text":"<p>Deprecated sections allow to document a deprecation that happened at a particular version. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nDeprecated:\n    1.2: The `foo` attribute is deprecated.\n\"\"\"\n\nfoo: int = 0\n</code></pre>"},{"location":"docstrings/#examples","title":"Examples","text":"<p>Examples sections allow to add examples of Python code without the use of markup code blocks. They are a mix of prose and interactive console snippets. They can be used in every docstring.</p> <pre><code>\"\"\"My module.\n\nExamples:\n    Some explanation of what is possible.\n\n    &gt;&gt;&gt; print(\"hello!\")\n    hello!\n\n    Blank lines delimit prose vs. console blocks.\n\n    &gt;&gt;&gt; a = 0\n    &gt;&gt;&gt; a += 1\n    &gt;&gt;&gt; a\n    1\n\"\"\"\n</code></pre> <p>Not the same as Example sections.</p> <p>Example (singular) sections are parsed as admonitions. Console code blocks will only be understood in Examples (plural) sections.</p>"},{"location":"docstrings/#parameters","title":"Parameters","text":"<ul> <li>Aliases: Args, Arguments, Params</li> <li>Multiple items allowed</li> </ul> <p>Parameters sections allow to document parameters of a function. They are typically used in functions docstrings, but can also be used in dataclasses docstrings.</p> <pre><code>def foo(a: int, b: str):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n    \"\"\"\n</code></pre> <pre><code>from dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n    \"\"\"\n\n    foo: int\n    bar: str\n</code></pre> <p>Type annotations are fetched from the related parameters definitions. You can override those by adding types between parentheses before the colon:</p> <pre><code>\"\"\"My function.\n\nParameters:\n    foo (Integer): Description for `foo`.\n    bar (String): Description for `bar`.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>When documenting a parameter with <code>param_name (param_type): Parameter description</code>, <code>param_type</code> will be resolved using the scope of the function (or class). For example, a type of <code>list[str]</code> will be parsed just as if it was an actual Python annotation. You can therefore use complex types (available in the current scope) in docstrings, for example <code>Optional[Union[int, Tuple[float, float]]]</code>.</p>"},{"location":"docstrings/#other-parameters","title":"Other Parameters","text":"<ul> <li>Aliases: Keyword Args, Keyword Arguments, Other Args, Other Arguments, Other Params</li> <li>Multiple items allowed</li> </ul> <p>Other parameters sections allow to document secondary parameters such as variadic keyword arguments, or parameters that should be of lesser interest to the user. They are used the same way Parameters sections are, but can also be useful in decorators / to document returned callables.</p> <pre><code>def foo(a, b, **kwargs):\n\"\"\"Foo.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n\n    Other parameters:\n        c (int): Here's c.\n        d (bool): Here's d.\n    \"\"\"\n</code></pre> <pre><code>def foo(a, b):\n\"\"\"Returns a callable.\n\n    Parameters:\n        a: Here's a.\n        b: Here's b.\n\n    Other parameters: Parameters of the returned callable:\n        c (int): Here's c.\n        d (bool): Here's d.\n    \"\"\"\n\n    def inner(c, d):\n        ...\n\n    return inner\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See the same tip for parameters.</p>"},{"location":"docstrings/#raises","title":"Raises","text":"<ul> <li>Aliases: Exceptions</li> <li>Multiple items allowed</li> </ul> <p>Raises sections allow to document exceptions that are raised by a function. They are usually only used in functions docstrings.</p> <pre><code>def foo(a: int):\n\"\"\"Foo.\n\n    Parameters:\n        a: A value.\n\n    Raises:\n        ValueError: When `a` is less than 0.\n    \"\"\"\n    if a &lt; 0:\n        raise ValueError(\"message\")\n</code></pre> <p>Exceptions names are resolved using the function's scope.</p> <p><code>ValueError</code> and other built-in exceptions are resolved as such. You can document custom exception, using the names available in the current scope, for example <code>my_exceptions.MyCustomException</code> or <code>MyCustomException</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#receives","title":"Receives","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Receives sections allow to document values that can be sent to generators using their <code>send</code> method. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Generator\n\n\ndef foo() -&gt; Generator[int, str, None]:\n\"\"\"Foo.\n\n    Receives:\n        reverse: Reverse the generator if `\"reverse\"` is received.\n\n    Yields:\n        Integers from 0 to 9.\n\n    Examples:\n        &gt;&gt;&gt; gen = foo()\n        &gt;&gt;&gt; next(gen)\n        0\n        &gt;&gt;&gt; next(gen)\n        1\n        &gt;&gt;&gt; next(gen)\n        2\n        &gt;&gt;&gt; gen.send(\"reverse\")\n        2\n        &gt;&gt;&gt; next(gen)\n        1\n        &gt;&gt;&gt; next(gen)\n        0\n        &gt;&gt;&gt; next(gen)\n        Traceback (most recent call last):\n          File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n        StopIteration\n    \"\"\"\n    for i in range(10):\n        received = yield i\n        if received == \"reverse\":\n            for j in range(i, -1, -1):\n                yield j\n            break\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code>. If your generator is able to receive tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; Generator[int, tuple[str, bool], None]:\n\"\"\"Foo.\n\n    Receives:\n        mode: Some mode.\n        flag: Some flag.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReceives:\n    mode (ModeEnum): Some mode.\n    flag (int): Some flag.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#returns","title":"Returns","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Returns sections allow to document values returned by functions. They should be used only in functions docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>import random\n\n\ndef foo() -&gt; int:\n\"\"\"Foo.\n\n    Returns:\n        A random integer.\n    \"\"\"\n    return random.randint(0, 100)\n</code></pre> <p>Type annotations are fetched from the function return annotation. If your function returns tuples of values, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>def foo() -&gt; tuple[bool, float]:\n\"\"\"Foo.\n\n    Returns:\n        success: Whether it succeeded.\n        precision: Final precision.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nReturns:\n    success (int): Whether it succeeded.\n    precision (Decimal): Final precision.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' function scope.</p> <p>See previous tips for types in docstrings.</p> <p>Continuation lines for a single returned item must still be indented.</p> <p>Even when your function returns a single value, you must indent continuation lines of its description so that the parser does not think you are documenting multiple items.</p>"},{"location":"docstrings/#warns","title":"Warns","text":"<ul> <li>Aliases: Warnings</li> <li>Multiple items allowed</li> </ul> <p>Warns sections allow to document warnings emitted by the following code. They are usually only used in functions docstrings.</p> <pre><code>import warnings\n\n\ndef foo():\n\"\"\"Foo.\n\n    Warns:\n        UserWarning: To annoy users.\n    \"\"\"\n    warnings.warn(\"Just messing with you.\", UserWarning)\n</code></pre> <p>Warnings names are resolved using the function's scope.</p> <p><code>UserWarning</code> and other built-in warnings are resolved as such. You can document custom warnings, using the names available in the current scope, for example <code>my_warnings.MyCustomWarning</code> or <code>MyCustomWarning</code> directly, depending on what you imported/defined in the current module.</p>"},{"location":"docstrings/#yields","title":"Yields","text":"<ul> <li>Multiple items allowed</li> </ul> <p>Yields sections allow to document values that generator yield. They should be used only in generators docstrings. Documented items can be given a name when it makes sense.</p> <pre><code>from typing import Iterator\n\n\ndef foo() -&gt; Iterator[int]:\n\"\"\"Foo.\n\n    Yields:\n        Integers from 0 to 9.\n    \"\"\"\n    for i in range(10):\n        yield i\n</code></pre> <p>Type annotations are fetched from the function return annotation when the annotation is <code>typing.Generator</code> or <code>typing.Iterator</code>. If your generator yields tuples, you can document each item of the tuple separately, and the type annotation will be fetched accordingly:</p> <pre><code>from datetime import datetime\n\n\ndef foo() -&gt; Iterator[tuple[float, float, datetime]]:\n\"\"\"Foo.\n\n    Yields:\n        x: Absissa.\n        y: Ordinate.\n        t: Time.\n\n    ...\n    \"\"\"\n    ...\n</code></pre> <p>Type annotations can as usual be overridden using types in parentheses in the docstring itself:</p> <pre><code>\"\"\"Foo.\n\nYields:\n    x (int): Absissa.\n    y (int): Ordinate.\n    t (int): Timestamp.\n\"\"\"\n</code></pre> <p>Types in docstrings are resolved using the docstrings' parent scope.</p> <p>See previous tips for types in docstrings.</p>"},{"location":"docstrings/#parsers-features","title":"Parsers features","text":"<p>Want to contribute?</p> <p>Each red cross is a link to an issue on the bugtracker. You will find some guidance on how to add support for the corresponding item.</p> <p>The sections are easier to deal in that order:</p> <ul> <li>Deprecated (single item, version and text)</li> <li>Raises, Warns (multiple items, no names, single type each)</li> <li>Attributes, Other Parameters, Parameters (multiple items, one name and one optional type each)</li> <li>Returns (multiple items, optional name and/or type each, annotation to split when multiple names)</li> <li>Receives, Yields (multiple items, optional name and/or type each, several types of annotations to split when multiple names)</li> </ul> <p>\"Examples\" section are a bit different as they require to parse the examples. But you can probably reuse the code in the Google parser. We can probably even factorize the examples parsing into a single function.</p> <p>You can tackle several items at once in a single PR, as long as they relate to a single parser or a single section (a line or a column of the following tables).</p>"},{"location":"docstrings/#sections","title":"Sections","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u2705 Deprecated \u2705 \u2705<sup>1</sup> \u274c Examples \u2705 \u2705 \u274c Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises \u2705 \u2705 \u2705 Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c"},{"location":"docstrings/#getting-annotationsdefaults-from-parent","title":"Getting annotations/defaults from parent","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u2705 Raises / / / Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u2705 Warns / / / Yields \u2705 \u2705 \u274c"},{"location":"docstrings/#cross-references-for-annotations-in-docstrings","title":"Cross-references for annotations in docstrings","text":"Section Google Numpy Sphinx Attributes \u2705 \u2705 \u274c Deprecated / / / Examples / / / Other Parameters \u2705 \u2705 \u274c Parameters \u2705 \u2705 \u274c Raises \u2705 \u2705 \u274c Receives \u2705 \u2705 \u274c Returns \u2705 \u2705 \u274c Warns \u2705 \u2705 \u274c Yields \u2705 \u2705 \u274c"},{"location":"docstrings/#parsing-options","title":"Parsing options","text":"Option Google Numpy Sphinx Ignore <code>__init__</code> summary \u2705 \u2705 \u274c Trim doctest flags \u2705 \u2705 \u274c Warn about unknown params \u2705 \u2705 \u274c <ol> <li> <p>Support for a regular section instead of the RST directive specified in the Numpydoc styleguide.\u00a0\u21a9</p> </li> </ol>"},{"location":"dumping/","title":"Dumping packages' signatures as JSON","text":"<p>Griffe can be used to load packages' signatures and output them as JSON on the standard output or in writable files.</p> <p>Pass the names of packages to the <code>griffe dump</code> command:</p> <pre><code>$ griffe dump httpx fastapi\n{\n  \"httpx\": {\n    \"name\": \"httpx\",\n    ...\n  },\n  \"fastapi\": {\n    \"name\": \"fastapi\",\n    ...\n  }\n}\n</code></pre> <p>It will output a JSON-serialized version of the packages' signatures.</p> <p>Try it out on Griffe itself:</p> <pre><code>$ griffe dump griffe\n{\n  \"griffe\": {\n    \"name\": \"griffe\",\n    ...\n  }\n}\n</code></pre> <p>To output in a file instead of standard output, use the <code>--output</code> or <code>-o</code> option:</p> <pre><code>$ griffe dump griffe -o griffe.json\n</code></pre> <p>If you load multiple packages' signatures, you can dump each in its own file with a templated filepath:</p> <pre><code>$ griffe dump griffe -o './dumps/{package}.json'\n</code></pre> <p>By default, Griffe will search in <code>sys.path</code>, so if you installed it through pipx, there are few chances it will find your packages. To explicitly specify search paths, use the <code>-s, --search &lt;PATH&gt;</code> option. You can use it multiple times. You can also add the search paths to the <code>PYTHONPATH</code> environment variable. If Griffe can't find the packages, it will fail with a <code>ModuleNotFoundError</code>.</p> <p>For an example of what real data looks like, see the full Griffe JSON dump. </p>"},{"location":"extensions/","title":"Extensions","text":"<p>You can pass extensions to the loader to augment its capacities:</p> <pre><code>from griffe.loader import GriffeLoader\nfrom griffe.extensions import VisitorExtension, Extensions, When\n\n# import extensions\nfrom some.package import TheirExtension\n\n\n# or define your own\nclass ClassStartsAtOddLineNumberExtension(VisitorExtension):\n    when = When.after_all\n\n    def visit_classdef(self, node) -&gt; None:\n        if node.lineno % 2 == 1:\n            self.visitor.current.labels.add(\"starts at odd line number\")\n\n\nextensions = Extensions(TheirExtension, ClassStartsAtOddLineNumberExtension)\ngriffe = GriffeLoader(extensions=extensions)\nfastapi = griffe.load_module(\"fastapi\")\n</code></pre> <p>Extensions are subclasses of a custom version of <code>ast.NodeVisitor</code>. Griffe uses a node visitor as well, that we will call the main visitor. The extensions are instantiated with a reference to this main visitor, so they can benefit from its capacities (navigating the nodes, getting the current class or module, etc.).</p> <p>Each time a node is visited, the main visitor will make the extensions visit the node as well. Implement the <code>visit_&lt;NODE_TYPE_LOWER&gt;</code> methods to visit nodes of certain types, and act on their properties. See the full list of AST nodes.</p> <p>Important note</p> <p>Because the main visitor recursively walks the tree itself, calling extensions on each node, you must not visit child nodes in your <code>.visit_*</code> methods! Otherwise, nodes down the tree will be visited twice or more: once by the main visitor, and as many times more as your extension is called. Let the main visitor do the walking, and just take care of the current node, without handling its children.</p> <p>You can access the main visitor state and data through the <code>.visitor</code> attribute, and the nodes instances are extended with additional attributes and properties:</p> <pre><code>class MyExtension(Extension):\n    def visit_functiondef(self, node) -&gt; None:\n        node.parent  # the parent node\n        node.children  # the list of children nodes\n        node.siblings  # all the siblings nodes, from top to bottom\n        node.previous_siblings  # only the previous siblings, from closest to top\n        node.next_siblings  # only the next siblings, from closest to bottom\n        node.previous  # first previous sibling\n        node.next  # first next sibling\n\n        self.visitor  # the main visitor\n        self.visitor.current  # the current data object\n        self.visitor.current.kind  # the kind of object: module, class, function, attribute\n</code></pre> <p>See the data classes (<code>Module</code>, <code>Class</code>, <code>Function</code> and <code>Attribute</code>) for a complete description of their methods and attributes.</p> <p>Extensions are run at certain moments while walking the Abstract Syntax Tree (AST):</p> <ul> <li>before the visit/inspection: <code>When.before_all</code>.   The current node has been grafted to its parent.   If this node represents a data object, the object (<code>self.visitor.current</code>/<code>self.inspector.current</code>) is not yet instantiated.</li> <li>before the children visit/inspection: <code>When.before_children</code>.   If this node represents a data object, the object (<code>self.visitor.current</code>/<code>self.inspector.current</code>) is now instantiated.   Children have not yet been visited/inspected.</li> <li>after the children visit/inspection: <code>When.after_children</code>.   Children have now been visited/inspected.</li> <li>after the visit/inspection: <code>When.after_all</code></li> </ul> <p>See the <code>When</code> enumeration.</p> <p>To tell the main visitor to run your extension at a certain time, set its <code>when</code> attribute:</p> <pre><code>class MyExtension(Extension):\n    when = When.after_children\n</code></pre> <p>By default, it will run the extension after the visit/inspection of the node: that's when the full data for this node and its children is loaded.</p>"},{"location":"extensions/#ast-nodes","title":"AST nodes","text":"<p> <ul> <li><code>Add</code></li> <li><code>alias</code></li> <li><code>And</code></li> <li><code>AnnAssign</code></li> <li><code>arg</code></li> <li><code>arguments</code></li> <li><code>Assert</code></li> <li><code>Assign</code></li> <li><code>AsyncFor</code></li> <li><code>AsyncFunctionDef</code></li> <li><code>AsyncWith</code></li> <li><code>Attribute</code></li> <li><code>AugAssign</code></li> <li><code>Await</code></li> <li><code>BinOp</code></li> <li><code>BitAnd</code></li> <li><code>BitOr</code></li> <li><code>BitXor</code></li> <li><code>BoolOp</code></li> <li><code>Break</code></li> <li><code>Bytes</code><sup>1</sup></li> <li><code>Call</code></li> <li><code>ClassDef</code></li> <li><code>Compare</code></li> <li><code>comprehension</code></li> <li><code>Constant</code></li> <li><code>Continue</code></li> <li><code>Del</code></li> <li><code>Delete</code></li> </ul> <p> <ul> <li><code>Dict</code></li> <li><code>DictComp</code></li> <li><code>Div</code></li> <li><code>Ellipsis</code><sup>1</sup></li> <li><code>Eq</code></li> <li><code>ExceptHandler</code></li> <li><code>Expr</code></li> <li><code>Expression</code><sup>1</sup></li> <li><code>ExtSlice</code><sup>2</sup></li> <li><code>FloorDiv</code></li> <li><code>For</code></li> <li><code>FormattedValue</code></li> <li><code>FunctionDef</code></li> <li><code>GeneratorExp</code></li> <li><code>Global</code></li> <li><code>Gt</code></li> <li><code>GtE</code></li> <li><code>If</code></li> <li><code>IfExp</code></li> <li><code>Import</code></li> <li><code>ImportFrom</code></li> <li><code>In</code></li> <li><code>Index</code><sup>2</sup></li> <li><code>Interactive</code><sup>3</sup></li> <li><code>Invert</code></li> <li><code>Is</code></li> <li><code>IsNot</code></li> <li><code>JoinedStr</code></li> <li><code>keyword</code></li> </ul> <p> <ul> <li><code>Lambda</code></li> <li><code>List</code></li> <li><code>ListComp</code></li> <li><code>Load</code></li> <li><code>LShift</code></li> <li><code>Lt</code></li> <li><code>LtE</code></li> <li><code>Match</code></li> <li><code>MatchAs</code></li> <li><code>match_case</code></li> <li><code>MatchClass</code></li> <li><code>MatchMapping</code></li> <li><code>MatchOr</code></li> <li><code>MatchSequence</code></li> <li><code>MatchSingleton</code></li> <li><code>MatchStar</code></li> <li><code>MatchValue</code></li> <li><code>MatMult</code></li> <li><code>Mod</code></li> <li><code>Module</code><sup>3</sup></li> <li><code>Mult</code></li> <li><code>Name</code></li> <li><code>NameConstant</code><sup>1</sup></li> <li><code>NamedExpr</code></li> <li><code>Nonlocal</code></li> <li><code>Not</code></li> <li><code>NotEq</code></li> <li><code>NotIn</code></li> <li><code>Num</code><sup>1</sup></li> </ul> <p> <ul> <li><code>Or</code></li> <li><code>Pass</code></li> <li><code>pattern</code><sup>3</sup></li> <li><code>Pow</code></li> <li><code>Print</code><sup>4</sup></li> <li><code>Raise</code></li> <li><code>Return</code></li> <li><code>RShift</code></li> <li><code>Set</code></li> <li><code>SetComp</code></li> <li><code>Slice</code></li> <li><code>Starred</code></li> <li><code>Store</code></li> <li><code>Str</code><sup>1</sup></li> <li><code>Sub</code></li> <li><code>Subscript</code></li> <li><code>Try</code></li> <li><code>TryExcept</code><sup>5</sup></li> <li><code>TryFinally</code><sup>6</sup></li> <li><code>Tuple</code></li> <li><code>UAdd</code></li> <li><code>UnaryOp</code></li> <li><code>USub</code></li> <li><code>While</code></li> <li><code>With</code></li> <li><code>withitem</code></li> <li><code>Yield</code></li> <li><code>YieldFrom</code></li> </ul> <p></p> <ol> <li> <p>Deprecated since Python 3.8.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Deprecated since Python 3.9.\u00a0\u21a9\u21a9</p> </li> <li> <p>Not documented.\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p><code>print</code> became a builtin (instead of a keyword) in Python 3.\u00a0\u21a9</p> </li> <li> <p>Now <code>ExceptHandler</code>, in the <code>handlers</code> attribute of <code>Try</code> nodes.\u00a0\u21a9</p> </li> <li> <p>Now a list of expressions in the <code>finalbody</code> attribute of <code>Try</code> nodes.\u00a0\u21a9</p> </li> </ol>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2021, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"loading/","title":"Loading data with Python","text":"<p>Griffe provides a shortcut function for simple needs:</p> <pre><code>import griffe\n\nmkdocs = griffe.load(\"mkdocs\")\n</code></pre> <p>The <code>load</code> function accepts a number of parameters.</p> <p>For more complex needs, create and use a loader:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader()\nmkdocs = loader.load_module(\"mkdocs\")\n</code></pre> <p>Similarly, the <code>GriffeLoader</code> accepts a number of parameters to configure how the modules are found and loaded.</p> <p>If you don't want to recurse in the submodules:</p> <pre><code>mkdocs = loader.load_module(\"mkdocs\", submodules=False)\n</code></pre>"},{"location":"loading/#navigating-into-the-loaded-objects","title":"Navigating into the loaded objects","text":"<p>Both the <code>load</code> function and the <code>GriffeLoader.load_module</code> method return a <code>Module</code> instance. There are several ways to access members of an object:</p> <ul> <li>through its <code>members</code> attribute, which is a dictionary,   with the usual <code>keys()</code>, <code>values()</code> and <code>items()</code> methods.</li> <li>thanks to its <code>__getitem__</code> method. For example <code>griffe[\"dataclasses\"]</code>   returns the <code>Module</code> instance representing Griffe's <code>dataclasses</code> module.   Since this module also has members, you can chain calls: <code>griffe[\"dataclasses\"][\"Module\"]</code>.   Conveniently, you can chain the names with dots in a single call: <code>griffe[\"dataclasses.Module\"]</code>.   You can even pass a tuple instead of a string: <code>griffe[(\"dataclasses\", \"Module\")]</code>.</li> <li>through the <code>modules</code>,   <code>classes</code>,   <code>functions</code> and   <code>attributes</code> properties,   which take care of filtering members based on their kind, and return dictionaries.</li> </ul> <p>Most of the time, you will only use classes from the <code>griffe.dataclasses</code> and <code>griffe.docstrings.dataclasses</code> modules.</p>"},{"location":"parsing_docstrings/","title":"Using Griffe as a docstring-parsing library","text":"<p>You can use Griffe to parse arbitrary docstrings. You don't have to load anything through the Griffe loader. You need to import the <code>parse</code> function, the <code>Parser</code> enumeration, and the <code>Docstring</code> class. Then you can build a <code>Docstring</code> instance and call <code>parse</code> on it, choosing the parsing-style to use:</p> <pre><code>from griffe.dataclasses import Docstring\nfrom griffe.docstrings.parsers import Parser, parse\n\ntext = \"Hello I'm a docstring!\"\ndocstring = Docstring(text, lineno=1)\nparsed = parse(docstring, Parser.google)\n</code></pre> <p>If you want to take advantage of the parsers ability to fetch annotations from the object from which the docstring originates, you can manually create the parent objects and link them to the docstring:</p> <pre><code>from griffe.dataclasses import Docstring, Function, Parameters, Parameter, ParameterKind\nfrom griffe.docstrings.parsers import Parser, parse\n\nfunction = Function(\n    \"func\",\n    parameters=Parameters(\n        Parameter(\"param1\", annotation=\"str\", kind=ParameterKind.positional_or_keyword),\n        Parameter(\"param2\", annotation=\"int\", kind=ParameterKind.keyword_only),\n    ),\n)\ntext = \"\"\"\nHello I'm a docstring!\n\nParameters:\n    param1: Description.\n    param2: Description.\n\"\"\"\ndocstring = Docstring(text, lineno=1, parent=function)\nparsed = parse(docstring, Parser.google)\n</code></pre> <p>With this the parser will fetch the <code>str</code> and <code>int</code> annotations from the parent function's parameters.</p>"},{"location":"usage/","title":"Usage","text":"<p>Redirecting...</p>"},{"location":"reference/griffe/","title":"Index","text":"<p>griffe package.</p> <p>Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API.</p>"},{"location":"reference/griffe/#griffe.load","title":"load","text":"<pre><code>load(\n    module,\n    *,\n    submodules=True,\n    try_relative_path=True,\n    extensions=None,\n    search_paths=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n    allow_inspection=True\n)\n</code></pre> <p>Load and return a module.</p> <p>Example: <pre><code>import griffe\n\nmodule = griffe.load(...)\n</code></pre></p> <p>This is a shortcut for:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader(...)\nmodule = loader.load_module(...)\n</code></pre> <p>See the documentation for the loader: <code>GriffeLoader</code>.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>)         \u2013 <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>)         \u2013 <p>Whether to try finding the module as a relative path.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module.\n\n    Example:\n    ```python\n    import griffe\n\n    module = griffe.load(...)\n    ```\n\n    This is a shortcut for:\n\n    ```python\n    from griffe.loader import GriffeLoader\n\n    loader = GriffeLoader(...)\n    module = loader.load_module(...)\n    ```\n\n    See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader].\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    return GriffeLoader(\n        extensions=extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n        allow_inspection=allow_inspection,\n    ).load_module(\n        module=module,\n        submodules=submodules,\n        try_relative_path=try_relative_path,\n    )\n</code></pre>"},{"location":"reference/griffe/#griffe.load_git","title":"load_git","text":"<pre><code>load_git(\n    module,\n    *,\n    ref=\"HEAD\",\n    repo=\".\",\n    submodules=True,\n    extensions=None,\n    search_paths=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n    allow_inspection=True\n)\n</code></pre> <p>Load and return a module from a specific Git reference.</p> <p>This function will create a temporary git worktree at the requested reference before loading <code>module</code> with <code>griffe.load</code>.</p> <p>This function requires that the <code>git</code> executable is installed.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module path, relative to the repository root.</p> </li> <li> ref             (<code>str</code>)         \u2013 <p>A Git reference such as a commit, tag or branch.</p> </li> <li> repo             (<code>str | Path</code>)         \u2013 <p>Path to the repository (i.e. the directory containing the <code>.git</code> directory)</p> </li> <li> submodules             (<code>bool</code>)         \u2013 <p>Whether to recurse on the submodules.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into (relative to the repository root).</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/git.py</code> <pre><code>def load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module from a specific Git reference.\n\n    This function will create a temporary\n    [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference\n    before loading `module` with [`griffe.load`][griffe.loader.load].\n\n    This function requires that the `git` executable is installed.\n\n    Parameters:\n        module: The module path, relative to the repository root.\n        ref: A Git reference such as a commit, tag or branch.\n        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)\n        submodules: Whether to recurse on the submodules.\n        extensions: The extensions to use.\n        search_paths: The paths to search into (relative to the repository root).\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    with tmp_worktree(repo, ref) as worktree:\n        search_paths = [worktree / path for path in search_paths or [\".\"]]\n        if isinstance(module, Path):\n            module = worktree / module\n        return loader.load(\n            module=module,\n            submodules=submodules,\n            try_relative_path=False,\n            extensions=extensions,\n            search_paths=search_paths,\n            docstring_parser=docstring_parser,\n            docstring_options=docstring_options,\n            lines_collection=lines_collection,\n            modules_collection=modules_collection,\n            allow_inspection=allow_inspection,\n        )\n</code></pre>"},{"location":"reference/griffe/cli/","title":"cli","text":"<p>Module that contains the command line application.</p>"},{"location":"reference/griffe/cli/#griffe.cli.check","title":"check","text":"<pre><code>check(\n    package,\n    against=None,\n    against_path=None,\n    *,\n    base_ref=None,\n    extensions=None,\n    search_paths=None,\n    allow_inspection=True,\n    verbose=False\n)\n</code></pre> <p>Load packages data and dump it as JSON.</p> <p>Parameters:</p> <ul> <li> package             (<code>str | Path</code>)         \u2013 <p>The package to load and check.</p> </li> <li> against             (<code>str | None</code>)         \u2013 <p>Older Git reference (commit, branch, tag) to check against.</p> </li> <li> against_path             (<code>str | Path | None</code>)         \u2013 <p>Path when the \"against\" reference is checked out.</p> </li> <li> base_ref             (<code>str | None</code>)         \u2013 <p>Git reference (commit, branch, tag) to check.</p> </li> <li> extensions             (<code>Sequence[str | dict[str, Any] | Extension | type[Extension]] | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> <li> verbose             (<code>bool</code>)         \u2013 <p>Use a verbose output.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p><code>0</code> for success, <code>1</code> for failure.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def check(\n    package: str | Path,\n    against: str | None = None,\n    against_path: str | Path | None = None,\n    *,\n    base_ref: str | None = None,\n    extensions: Sequence[str | dict[str, Any] | Extension | type[Extension]] | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    allow_inspection: bool = True,\n    verbose: bool = False,\n) -&gt; int:\n\"\"\"Load packages data and dump it as JSON.\n\n    Parameters:\n        package: The package to load and check.\n        against: Older Git reference (commit, branch, tag) to check against.\n        against_path: Path when the \"against\" reference is checked out.\n        base_ref: Git reference (commit, branch, tag) to check.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n        verbose: Use a verbose output.\n\n    Returns:\n        `0` for success, `1` for failure.\n    \"\"\"\n    colorama.deinit()\n    colorama.init()\n\n    search_paths = list(search_paths) if search_paths else []\n\n    against = against or _get_latest_tag(package)\n    against_path = against_path or package\n    repository = _get_repo_root(against_path)\n\n    try:\n        loaded_extensions = load_extensions(extensions or ())\n    except ExtensionError as error:\n        logger.exception(str(error))  # noqa: TRY401\n        return 1\n\n    old_package = load_git(\n        against_path,\n        ref=against,\n        repo=repository,\n        extensions=loaded_extensions,\n        search_paths=search_paths,\n        allow_inspection=allow_inspection,\n    )\n    if base_ref:\n        new_package = load_git(\n            package,\n            ref=base_ref,\n            repo=repository,\n            extensions=loaded_extensions,\n            search_paths=search_paths,\n            allow_inspection=allow_inspection,\n        )\n    else:\n        new_package = load(\n            package,\n            try_relative_path=True,\n            extensions=loaded_extensions,\n            search_paths=search_paths,\n            allow_inspection=allow_inspection,\n        )\n\n    style = ExplanationStyle.VERBOSE if verbose else ExplanationStyle.ONE_LINE\n    breakages = list(find_breaking_changes(old_package, new_package))\n    for breakage in breakages:\n        print(breakage.explain(style=style), file=sys.stderr)\n    if breakages:\n        return 1\n    return 0\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.dump","title":"dump","text":"<pre><code>dump(\n    packages,\n    *,\n    output=None,\n    full=False,\n    docstring_parser=None,\n    docstring_options=None,\n    extensions=None,\n    resolve_aliases=False,\n    resolve_implicit=False,\n    resolve_external=False,\n    search_paths=None,\n    append_sys_path=False,\n    allow_inspection=True,\n    stats=False\n)\n</code></pre> <p>Load packages data and dump it as JSON.</p> <p>Parameters:</p> <ul> <li> packages             (<code>Sequence[str]</code>)         \u2013 <p>The packages to load and dump.</p> </li> <li> output             (<code>str | IO | None</code>)         \u2013 <p>Where to output the JSON-serialized data.</p> </li> <li> full             (<code>bool</code>)         \u2013 <p>Whether to output full or minimal data.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> resolve_aliases             (<code>bool</code>)         \u2013 <p>Whether to resolve aliases (indirect objects references).</p> </li> <li> resolve_implicit             (<code>bool</code>)         \u2013 <p>Whether to resolve every alias or only the explicitly exported ones.</p> </li> <li> resolve_external             (<code>bool</code>)         \u2013 <p>Whether to load additional, unspecified modules to resolve aliases.</p> </li> <li> extensions             (<code>Sequence[str | dict[str, Any] | Extension | type[Extension]] | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into.</p> </li> <li> append_sys_path             (<code>bool</code>)         \u2013 <p>Whether to append the contents of <code>sys.path</code> to the search paths.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> <li> stats             (<code>bool</code>)         \u2013 <p>Whether to compute and log stats about loading.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p><code>0</code> for success, <code>1</code> for failure.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def dump(\n    packages: Sequence[str],\n    *,\n    output: str | IO | None = None,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    extensions: Sequence[str | dict[str, Any] | Extension | type[Extension]] | None = None,\n    resolve_aliases: bool = False,\n    resolve_implicit: bool = False,\n    resolve_external: bool = False,\n    search_paths: Sequence[str | Path] | None = None,\n    append_sys_path: bool = False,\n    allow_inspection: bool = True,\n    stats: bool = False,\n) -&gt; int:\n\"\"\"Load packages data and dump it as JSON.\n\n    Parameters:\n        packages: The packages to load and dump.\n        output: Where to output the JSON-serialized data.\n        full: Whether to output full or minimal data.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        resolve_aliases: Whether to resolve aliases (indirect objects references).\n        resolve_implicit: Whether to resolve every alias or only the explicitly exported ones.\n        resolve_external: Whether to load additional, unspecified modules to resolve aliases.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        append_sys_path: Whether to append the contents of `sys.path` to the search paths.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n        stats: Whether to compute and log stats about loading.\n\n    Returns:\n        `0` for success, `1` for failure.\n    \"\"\"\n    per_package_output = False\n    if isinstance(output, str) and output.format(package=\"package\") != output:\n        per_package_output = True\n\n    search_paths = list(search_paths) if search_paths else []\n    if append_sys_path:\n        search_paths.extend(sys.path)\n\n    try:\n        loaded_extensions = load_extensions(extensions or ())\n    except ExtensionError as error:\n        logger.exception(str(error))  # noqa: TRY401\n        return 1\n\n    loader = _load_packages(\n        packages,\n        extensions=loaded_extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        resolve_aliases=resolve_aliases,\n        resolve_implicit=resolve_implicit,\n        resolve_external=resolve_external,\n        allow_inspection=allow_inspection,\n    )\n    data_packages = loader.modules_collection.members\n\n    started = datetime.now(tz=timezone.utc)\n    if per_package_output:\n        for package_name, data in data_packages.items():\n            serialized = data.as_json(indent=2, full=full)\n            _print_data(serialized, output.format(package=package_name))  # type: ignore[union-attr]\n    else:\n        serialized = json.dumps(data_packages, cls=JSONEncoder, indent=2, full=full)\n        _print_data(serialized, output)\n    elapsed = datetime.now(tz=timezone.utc) - started\n\n    if stats:\n        logger.info(_format_stats({\"time_spent_serializing\": elapsed.microseconds, **loader.stats()}))\n\n    return 0 if len(data_packages) == len(packages) else 1\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.get_parser","title":"get_parser","text":"<pre><code>get_parser()\n</code></pre> <p>Return the CLI argument parser.</p> <p>Returns:</p> <ul> <li> <code>argparse.ArgumentParser</code>         \u2013 <p>An argparse parser.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n\"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    usage = \"%(prog)s [GLOBAL_OPTS...] COMMAND [COMMAND_OPTS...]\"\n    description = \"Signatures for entire Python programs. \"\n    \"Extract the structure, the frame, the skeleton of your project, \"\n    \"to generate API documentation or find breaking changes in your API.\"\n    parser = argparse.ArgumentParser(add_help=False, usage=usage, description=description, prog=\"griffe\")\n\n    main_help = \"Show this help message and exit. Commands also accept the -h/--help option.\"\n    subcommand_help = \"Show this help message and exit.\"\n\n    global_options = parser.add_argument_group(title=\"Global options\")\n    global_options.add_argument(\"-h\", \"--help\", action=\"help\", help=main_help)\n\n    def add_common_options(subparser: argparse.ArgumentParser) -&gt; None:\n        common_options = subparser.add_argument_group(title=\"Common options\")\n        common_options.add_argument(\"-h\", \"--help\", action=\"help\", help=subcommand_help)\n        search_options = subparser.add_argument_group(title=\"Search options\")\n        search_options.add_argument(\n            \"-s\",\n            \"--search\",\n            dest=\"search_paths\",\n            action=\"append\",\n            type=Path,\n            help=\"Paths to search packages into.\",\n        )\n        loading_options = subparser.add_argument_group(title=\"Loading options\")\n        loading_options.add_argument(\n            \"-e\",\n            \"--extensions\",\n            default={},\n            type=json.loads,\n            help=\"A list of extensions to use.\",\n        )\n        loading_options.add_argument(\n            \"-X\",\n            \"--no-inspection\",\n            dest=\"allow_inspection\",\n            action=\"store_false\",\n            default=True,\n            help=\"Disallow inspection of builtin/compiled/not found modules.\",\n        )\n        debug_options = subparser.add_argument_group(title=\"Debugging options\")\n        debug_options.add_argument(\n            \"-L\",\n            \"--log-level\",\n            metavar=\"LEVEL\",\n            default=DEFAULT_LOG_LEVEL,\n            choices=_level_choices,\n            type=str.upper,\n            help=\"Set the log level: `DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`.\",\n        )\n\n    # ========= SUBPARSERS ========= #\n    subparsers = parser.add_subparsers(\n        dest=\"subcommand\",\n        title=\"Commands\",\n        metavar=\"COMMAND\",\n        prog=\"griffe\",\n        required=True,\n    )\n\n    def add_subparser(command: str, text: str, **kwargs: Any) -&gt; argparse.ArgumentParser:\n        return subparsers.add_parser(command, add_help=False, help=text, description=text, **kwargs)\n\n    # ========= DUMP PARSER ========= #\n    dump_parser = add_subparser(\"dump\", \"Load package-signatures and dump them as JSON.\")\n    dump_options = dump_parser.add_argument_group(title=\"Dump options\")\n    dump_options.add_argument(\"packages\", metavar=\"PACKAGE\", nargs=\"+\", help=\"Packages to find, load and dump.\")\n    dump_options.add_argument(\n        \"-f\",\n        \"--full\",\n        action=\"store_true\",\n        default=False,\n        help=\"Whether to dump full data in JSON.\",\n    )\n    dump_options.add_argument(\n        \"-o\",\n        \"--output\",\n        default=sys.stdout,\n        help=\"Output file. Supports templating to output each package in its own file, with `{package}`.\",\n    )\n    dump_options.add_argument(\n        \"-d\",\n        \"--docstyle\",\n        dest=\"docstring_parser\",\n        default=None,\n        type=Parser,\n        help=\"The docstring style to parse.\",\n    )\n    dump_options.add_argument(\n        \"-D\",\n        \"--docopts\",\n        dest=\"docstring_options\",\n        default={},\n        type=json.loads,\n        help=\"The options for the docstring parser.\",\n    )\n    dump_options.add_argument(\n        \"-y\",\n        \"--sys-path\",\n        dest=\"append_sys_path\",\n        action=\"store_true\",\n        help=\"Whether to append `sys.path` to search paths specified with `-s`.\",\n    )\n    dump_options.add_argument(\n        \"-r\",\n        \"--resolve-aliases\",\n        action=\"store_true\",\n        help=\"Whether to resolve aliases.\",\n    )\n    dump_options.add_argument(\n        \"-I\",\n        \"--resolve-implicit\",\n        action=\"store_true\",\n        help=\"Whether to resolve implicitely exported aliases as well. \"\n        \"Aliases are explicitely exported when defined in `__all__`.\",\n    )\n    dump_options.add_argument(\n        \"-U\",\n        \"--resolve-external\",\n        action=\"store_true\",\n        help=\"Whether to resolve aliases pointing to external/unknown modules (not loaded directly).\",\n    )\n    dump_options.add_argument(\n        \"-S\",\n        \"--stats\",\n        action=\"store_true\",\n        help=\"Show statistics at the end.\",\n    )\n    add_common_options(dump_parser)\n\n    # ========= CHECK PARSER ========= #\n    check_parser = add_subparser(\"check\", \"Check for API breakages or possible improvements.\")\n    check_options = check_parser.add_argument_group(title=\"Check options\")\n    check_options.add_argument(\"package\", metavar=\"PACKAGE\", help=\"Package to find, load and check, as path.\")\n    check_options.add_argument(\n        \"-a\",\n        \"--against\",\n        metavar=\"REF\",\n        help=\"Older Git reference (commit, branch, tag) to check against. Default: load latest tag.\",\n    )\n    check_options.add_argument(\n        \"-b\",\n        \"--base-ref\",\n        metavar=\"BASE_REF\",\n        help=\"Git reference (commit, branch, tag) to check. Default: load current code.\",\n    )\n    check_options.add_argument(\"-v\", \"--verbose\", action=\"store_true\", help=\"Verbose output.\")\n    add_common_options(check_parser)\n\n    return parser\n</code></pre>"},{"location":"reference/griffe/cli/#griffe.cli.main","title":"main","text":"<pre><code>main(args=None)\n</code></pre> <p>Run the main program.</p> <p>This function is executed when you type <code>griffe</code> or <code>python -m griffe</code>.</p> <p>Parameters:</p> <ul> <li> args             (<code>list[str] | None</code>)         \u2013 <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>An exit code.</p> </li> </ul> Source code in <code>src/griffe/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n\"\"\"Run the main program.\n\n    This function is executed when you type `griffe` or `python -m griffe`.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code.\n    \"\"\"\n    parser = get_parser()\n    opts: argparse.Namespace = parser.parse_args(args)\n    opts_dict = opts.__dict__\n    subcommand = opts_dict.pop(\"subcommand\")\n\n    log_level = opts_dict.pop(\"log_level\", DEFAULT_LOG_LEVEL)\n    try:\n        level = getattr(logging, log_level)\n    except AttributeError:\n        choices = \"', '\".join(_level_choices)\n        print(\n            f\"griffe: error: invalid log level '{log_level}' (choose from '{choices}')\",\n            file=sys.stderr,\n        )\n        return 1\n    else:\n        logging.basicConfig(format=\"%(levelname)-10s %(message)s\", level=level)\n\n    commands: dict[str, Callable[..., int]] = {\"check\": check, \"dump\": dump}\n    return commands[subcommand](**opts_dict)\n</code></pre>"},{"location":"reference/griffe/collections/","title":"collections","text":"<p>This module stores collections of data, useful during parsing.</p>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection","title":"LinesCollection","text":"<pre><code>LinesCollection()\n</code></pre> <p>A simple dictionary containing the modules source code lines.</p> Source code in <code>src/griffe/collections.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the collection.\"\"\"\n    self._data: dict[Path, list[str]] = {}\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return the collection items.</p> <p>Returns:</p> <ul> <li> <code>ItemsView</code>         \u2013 <p>The collection items.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def items(self) -&gt; ItemsView:\n\"\"\"Return the collection items.\n\n    Returns:\n        The collection items.\n    \"\"\"\n    return self._data.items()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return the collection keys.</p> <p>Returns:</p> <ul> <li> <code>KeysView</code>         \u2013 <p>The collection keys.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def keys(self) -&gt; KeysView:\n\"\"\"Return the collection keys.\n\n    Returns:\n        The collection keys.\n    \"\"\"\n    return self._data.keys()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.tokens","title":"tokens  <code>cached</code>","text":"<pre><code>tokens(path)\n</code></pre> <p>Tokenize the code.</p> <p>Parameters:</p> <ul> <li> path             (<code>Path</code>)         \u2013 <p>The filepath to get the tokens of.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[tokenize.TokenInfo], defaultdict]</code>         \u2013 <p>A token list and a mapping of tokens by line number.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>@lru_cache(maxsize=None)  # noqa: B019\ndef tokens(self, path: Path) -&gt; tuple[list[tokenize.TokenInfo], defaultdict]:\n\"\"\"Tokenize the code.\n\n    Parameters:\n        path: The filepath to get the tokens of.\n\n    Returns:\n        A token list and a mapping of tokens by line number.\n    \"\"\"\n    readline = BytesIO(\"\\n\".join(self[path]).encode()).readline\n    tokens = list(tokenize.tokenize(readline))\n    token_table = defaultdict(list)  # mapping line numbers to token numbers\n    for index, token in enumerate(tokens):\n        token_table[token.start[0]].append(index)\n    return tokens, token_table\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.LinesCollection.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return the collection values.</p> <p>Returns:</p> <ul> <li> <code>ValuesView</code>         \u2013 <p>The collection values.</p> </li> </ul> Source code in <code>src/griffe/collections.py</code> <pre><code>def values(self) -&gt; ValuesView:\n\"\"\"Return the collection values.\n\n    Returns:\n        The collection values.\n    \"\"\"\n    return self._data.values()\n</code></pre>"},{"location":"reference/griffe/collections/#griffe.collections.ModulesCollection","title":"ModulesCollection","text":"<pre><code>ModulesCollection()\n</code></pre> <p>         Bases: <code>GetMembersMixin</code>, <code>SetMembersMixin</code></p> <p>A collection of modules, allowing easy access to members.</p> Source code in <code>src/griffe/collections.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the collection.\"\"\"\n    self.members: dict[str, Module] = {}\n</code></pre>"},{"location":"reference/griffe/dataclasses/","title":"dataclasses","text":"<p>This module contains the data classes that represent Python objects.</p> <p>The different objects are modules, classes, functions, and attribute (variables like module/class/instance attributes).</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias","title":"Alias","text":"<pre><code>Alias(\n    name,\n    target,\n    *,\n    lineno=None,\n    endlineno=None,\n    runtime=True,\n    parent=None\n)\n</code></pre> <p>         Bases: <code>ObjectAliasMixin</code></p> <p>This class represents an alias, or indirection, to an object declared in another module.</p> <p>Aliases represent objects that are in the scope of a module or class, but were imported from another module.</p> <p>They behave almost exactly like regular objects, to a few exceptions:</p> <ul> <li>line numbers are those of the alias, not the target</li> <li>the path is the alias path, not the canonical one</li> <li>the name can be different from the target's</li> <li>if the target can be resolved, the kind is the target's kind</li> <li>if the target cannot be resolved, the kind becomes Kind.ALIAS</li> </ul> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The alias name.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The alias starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The alias ending line number.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013 <p>The alias parent.</p> </li> <li> target_path             (<code>str</code>)         \u2013 <p>The alias target path.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The alias name.</p> </li> <li> target             (<code>str | Object | Alias</code>)         \u2013 <p>If it's a string, the target resolution is delayed until accessing the target property. If it's an object, or even another alias, the target is immediately set.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The alias starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The alias ending line number.</p> </li> <li> runtime             (<code>bool</code>)         \u2013 <p>Whether this alias is present at runtime or not.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013 <p>The alias parent.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    target: str | Object | Alias,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    parent: Module | Class | None = None,\n) -&gt; None:\n\"\"\"Initialize the alias.\n\n    Parameters:\n        name: The alias name.\n        target: If it's a string, the target resolution is delayed until accessing the target property.\n            If it's an object, or even another alias, the target is immediately set.\n        lineno: The alias starting line number.\n        endlineno: The alias ending line number.\n        runtime: Whether this alias is present at runtime or not.\n        parent: The alias parent.\n    \"\"\"\n    self.name: str = name\n    self.alias_lineno: int | None = lineno\n    self.alias_endlineno: int | None = endlineno\n    self.runtime: bool = runtime\n    self._parent: Module | Class | None = parent\n    self._passed_through: bool = False\n    if isinstance(target, str):\n        self._target: Object | Alias | None = None\n        self.target_path: str = target\n    else:\n        self._target = target\n        self.target_path = target.path\n        self._update_target_aliases()\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.endlineno","title":"endlineno  <code>property</code>","text":"<pre><code>endlineno: int | None\n</code></pre> <p>Return the target endlineno or the alias endlineno.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>         \u2013 <p>The target endlineno or the alias endlineno.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.final_target","title":"final_target  <code>property</code>","text":"<pre><code>final_target: Object\n</code></pre> <p>Resolve and return the final target, if possible.</p> <p>This will iterate through the targets until a non-alias object is found.</p> <p>Returns:</p> <ul> <li> <code>Object</code>         \u2013 <p>The final target.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this alias' target has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this alias' target or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: Kind\n</code></pre> <p>Return the target's kind, or Kind.ALIAS if the target cannot be resolved.</p> <p>Returns:</p> <ul> <li> <code>Kind</code>         \u2013 <p>A kind.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.lineno","title":"lineno  <code>property</code>","text":"<pre><code>lineno: int | None\n</code></pre> <p>Return the target lineno or the alias lineno.</p> <p>Returns:</p> <ul> <li> <code>int | None</code>         \u2013 <p>The target lineno or the alias lineno.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.modules_collection","title":"modules_collection  <code>cached</code> <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to the alias parents.</p> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013 <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.parent","title":"parent  <code>property</code> <code>writable</code>","text":"<pre><code>parent: Module | Class | None\n</code></pre> <p>Return the parent of this alias.</p> <p>Returns:</p> <ul> <li> <code>Module | Class | None</code>         \u2013 <p>The parent.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.path","title":"path  <code>cached</code> <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path / import path of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolved","title":"resolved  <code>property</code>","text":"<pre><code>resolved: bool\n</code></pre> <p>Tell whether this alias' target is resolved.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.target","title":"target  <code>property</code> <code>writable</code>","text":"<pre><code>target: Object | Alias\n</code></pre> <p>Resolve and return the target, if possible.</p> <p>Upon accessing this property, if the target is not already resolved, a lookup is done using the modules collection to find the target.</p> <p>Returns:</p> <ul> <li> <code>Object | Alias</code>         \u2013 <p>The resolved target.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.wildcard","title":"wildcard  <code>cached</code> <code>property</code>","text":"<pre><code>wildcard: str | None\n</code></pre> <p>Return the module on which the wildcard import is performed (if any).</p> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013 <p>The wildcard imported module, or None.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.as_dict","title":"as_dict","text":"<pre><code>as_dict(*, full=False, **kwargs)\n</code></pre> <p>Return this alias' data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>)         \u2013 <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this alias' data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\n        \"kind\": Kind.ALIAS,\n        \"name\": self.name,\n        \"target_path\": self.target_path,\n    }\n\n    if full:\n        base[\"path\"] = self.path\n\n    if self.alias_lineno:\n        base[\"lineno\"] = self.alias_lineno\n    if self.alias_endlineno:\n        base[\"endlineno\"] = self.alias_endlineno\n\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Alias.resolve_target","title":"resolve_target","text":"<pre><code>resolve_target()\n</code></pre> <p>Resolve the target.</p> <p>Raises:</p> <ul> <li> <code>AliasResolutionError</code>           \u2013         <p>When the target cannot be resolved. It happens when the target does not exist, or could not be loaded (unhandled dynamic object?), or when the target is from a module that was not loaded and added to the collection.</p> </li> <li> <code>CyclicAliasError</code>           \u2013         <p>When the resolved target is the alias itself.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve_target(self) -&gt; None:\n\"\"\"Resolve the target.\n\n    Raises:\n        AliasResolutionError: When the target cannot be resolved.\n            It happens when the target does not exist,\n            or could not be loaded (unhandled dynamic object?),\n            or when the target is from a module that was not loaded\n            and added to the collection.\n        CyclicAliasError: When the resolved target is the alias itself.\n    \"\"\"\n    if self._passed_through:\n        raise CyclicAliasError([self.target_path])\n    self._passed_through = True\n    try:\n        self._resolve_target()\n    finally:\n        self._passed_through = False\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute","title":"Attribute","text":"<pre><code>Attribute(*args, value=None, annotation=None, **kwargs)\n</code></pre> <p>         Bases: <code>Object</code></p> <p>The class representing a Python module/class/instance attribute.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> value             (<code>str | None</code>)         \u2013 <p>The attribute value, if any.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The attribute annotation, if any.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    value: str | None = None,\n    annotation: str | Name | Expression | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        value: The attribute value, if any.\n        annotation: The attribute annotation, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.value: str | None = value\n    self.annotation: str | Name | Expression | None = annotation\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Attribute.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # type: ignore[override]\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    if self.value is not None:\n        base[\"value\"] = self.value\n    if self.annotation is not None:\n        base[\"annotation\"] = self.annotation\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class","title":"Class","text":"<pre><code>Class(*args, bases=None, decorators=None, **kwargs)\n</code></pre> <p>         Bases: <code>Object</code></p> <p>The class representing a Python class.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> bases             (<code>list[Name | Expression | str] | None</code>)         \u2013 <p>The list of base classes, if any.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>)         \u2013 <p>The class decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    bases: list[Name | Expression | str] | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the class.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        bases: The list of base classes, if any.\n        decorators: The class decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.bases: list[Name | Expression | str] = bases or []\n    self.decorators: list[Decorator] = decorators or []\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.parameters","title":"parameters  <code>property</code>","text":"<pre><code>parameters: Parameters\n</code></pre> <p>Return the parameters of this class' <code>__init__</code> method, if any.</p> <p>Returns:</p> <ul> <li> <code>Parameters</code>         \u2013 <p>The parameters containter.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Class.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this class' data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # type: ignore[override]\n\"\"\"Return this class' data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"bases\"] = self.bases\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator","title":"Decorator","text":"<pre><code>Decorator(value, *, lineno, endlineno)\n</code></pre> <p>This class represents decorators.</p> <p>Attributes:</p> <ul> <li> lineno             (<code>int | None</code>)         \u2013 <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The ending line number.</p> </li> </ul> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013 <p>The decorator code.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The ending line number.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, value: str, *, lineno: int | None, endlineno: int | None) -&gt; None:\n\"\"\"Initialize the decorator.\n\n    Parameters:\n        value: The decorator code.\n        lineno: The starting line number.\n        endlineno: The ending line number.\n    \"\"\"\n    self.value: str = value\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Decorator.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this decorator's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this decorator's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"value\": self.value,\n        \"lineno\": self.lineno,\n        \"endlineno\": self.endlineno,\n    }\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring","title":"Docstring","text":"<pre><code>Docstring(\n    value,\n    *,\n    lineno=None,\n    endlineno=None,\n    parent=None,\n    parser=None,\n    parser_options=None\n)\n</code></pre> <p>This class represents docstrings.</p> <p>Attributes:</p> <ul> <li> value             (<code>str</code>)         \u2013 <p>The actual documentation string, cleaned up.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>)         \u2013 <p>The parent object on which this docstring is attached.</p> </li> </ul> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013 <p>The docstring value.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The starting line number.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The ending line number.</p> </li> <li> parent             (<code>Object | None</code>)         \u2013 <p>The parent object on which this docstring is attached.</p> </li> <li> parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> parser_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    value: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    parent: Object | None = None,\n    parser: Parser | None = None,\n    parser_options: dict[str, Any] | None = None,\n) -&gt; None:\n\"\"\"Initialize the docstring.\n\n    Parameters:\n        value: The docstring value.\n        lineno: The starting line number.\n        endlineno: The ending line number.\n        parent: The parent object on which this docstring is attached.\n        parser: The docstring parser to use. By default, no parsing is done.\n        parser_options: Additional docstring parsing options.\n    \"\"\"\n    self.value: str = inspect.cleandoc(value.rstrip())\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.parent: Object | None = parent\n    self.parser: Parser | None = parser\n    self.parser_options: dict[str, Any] = parser_options or {}\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.lines","title":"lines  <code>cached</code> <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Returns the lines of the docstring.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013 <p>The docstring's lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parsed","title":"parsed  <code>cached</code> <code>property</code>","text":"<pre><code>parsed: list[DocstringSection]\n</code></pre> <p>Return the docstring, parsed into structured data.</p> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>The parsed docstring as a list of sections.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.as_dict","title":"as_dict","text":"<pre><code>as_dict(*, full=False, docstring_parser=None, **kwargs)\n</code></pre> <p>Return this docstring's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>)         \u2013 <p>Whether to return full info, or just base info.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to parse the docstring with. By default, no parsing is done.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization or docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, docstring_parser: Parser | None = None, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this docstring's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        docstring_parser: The docstring parser to parse the docstring with. By default, no parsing is done.\n        **kwargs: Additional serialization or docstring parsing options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base: dict[str, Any] = {\n        \"value\": self.value,\n        \"lineno\": self.lineno,\n        \"endlineno\": self.endlineno,\n    }\n    if full:\n        base[\"parsed\"] = self.parse(docstring_parser, **kwargs)\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Docstring.parse","title":"parse","text":"<pre><code>parse(parser=None, **options)\n</code></pre> <p>Parse the docstring into structured data.</p> <p>Parameters:</p> <ul> <li> parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. In order: use the given parser, or the self parser, or no parser (return a single text section).</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>The parsed docstring as a list of sections.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def parse(self, parser: Parser | None = None, **options: Any) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring into structured data.\n\n    Parameters:\n        parser: The docstring parser to use.\n            In order: use the given parser, or the self parser, or no parser (return a single text section).\n        **options: Additional docstring parsing options.\n\n    Returns:\n        The parsed docstring as a list of sections.\n    \"\"\"\n    return parse(self, parser or self.parser, **(options or self.parser_options))\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function","title":"Function","text":"<pre><code>Function(\n    *args,\n    parameters=None,\n    returns=None,\n    decorators=None,\n    **kwargs\n)\n</code></pre> <p>         Bases: <code>Object</code></p> <p>The class representing a Python function.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> parameters             (<code>Parameters | None</code>)         \u2013 <p>The function parameters.</p> </li> <li> returns             (<code>str | Name | Expression | None</code>)         \u2013 <p>The function return annotation.</p> </li> <li> decorators             (<code>list[Decorator] | None</code>)         \u2013 <p>The function decorators, if any.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    parameters: Parameters | None = None,\n    returns: str | Name | Expression | None = None,\n    decorators: list[Decorator] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the function.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        parameters: The function parameters.\n        returns: The function return annotation.\n        decorators: The function decorators, if any.\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.parameters: Parameters = parameters or Parameters()\n    self.returns: str | Name | Expression | None = returns\n    self.decorators: list[Decorator] = decorators or []\n    self.setter: Function | None = None\n    self.deleter: Function | None = None\n    self.overloads: list[Function] | None = None\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.annotation","title":"annotation  <code>property</code>","text":"<pre><code>annotation: str | Name | Expression | None\n</code></pre> <p>Return the return annotation.</p> <p>Returns:</p> <ul> <li> <code>str | Name | Expression | None</code>         \u2013 <p>The function return annotation.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Function.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this function's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # type: ignore[override]\n\"\"\"Return this function's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"decorators\"] = [dec.as_dict(**kwargs) for dec in self.decorators]\n    base[\"parameters\"] = [param.as_dict(**kwargs) for param in self.parameters]\n    base[\"returns\"] = self.returns\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Kind","title":"Kind","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enumeration of the different objects kinds.</p> <p>Attributes:</p> <ul> <li> MODULE             (<code>str</code>)         \u2013 <p>The module kind.</p> </li> <li> CLASS             (<code>str</code>)         \u2013 <p>The class kind.</p> </li> <li> FUNCTION             (<code>str</code>)         \u2013 <p>The function kind.</p> </li> <li> ATTRIBUTE             (<code>str</code>)         \u2013 <p>The attribute kind.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module","title":"Module","text":"<pre><code>Module(*args, filepath=None, **kwargs)\n</code></pre> <p>         Bases: <code>Object</code></p> <p>The class representing a Python module.</p> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> <li> filepath             (<code>Path | list[Path] | None</code>)         \u2013 <p>The module file path (directory for namespace [sub]packages, none for builtin modules).</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>See <code>griffe.dataclasses.Object</code>.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, *args: Any, filepath: Path | list[Path] | None = None, **kwargs: Any) -&gt; None:\n\"\"\"Initialize the module.\n\n    Parameters:\n        *args: See [`griffe.dataclasses.Object`][].\n        filepath: The module file path (directory for namespace [sub]packages, none for builtin modules).\n        **kwargs: See [`griffe.dataclasses.Object`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._filepath: Path | list[Path] | None = filepath\n    self.overloads: dict[str, list[Function]] = defaultdict(list)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.filepath","title":"filepath  <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Get the file path of this module.</p> <p>Raises:</p> <ul> <li> <code>BuiltinModuleError</code>           \u2013         <p>When the instance filepath is None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013 <p>The module's file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_init_module","title":"is_init_module  <code>cached</code> <code>property</code>","text":"<pre><code>is_init_module: bool\n</code></pre> <p>Tell if this module is an <code>__init__.py</code> module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_package","title":"is_namespace_package  <code>cached</code> <code>property</code>","text":"<pre><code>is_namespace_package: bool\n</code></pre> <p>Tell if this module is a namespace package (top folder, no <code>__init__.py</code>).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_namespace_subpackage","title":"is_namespace_subpackage  <code>cached</code> <code>property</code>","text":"<pre><code>is_namespace_subpackage: bool\n</code></pre> <p>Tell if this module is a namespace subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_package","title":"is_package  <code>cached</code> <code>property</code>","text":"<pre><code>is_package: bool\n</code></pre> <p>Tell if this module is a package (top module).</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.is_subpackage","title":"is_subpackage  <code>cached</code> <code>property</code>","text":"<pre><code>is_subpackage: bool\n</code></pre> <p>Tell if this module is a subpackage.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Module.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this module's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # type: ignore[override]\n\"\"\"Return this module's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = super().as_dict(**kwargs)\n    base[\"filepath\"] = str(self._filepath) if self._filepath else None\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object","title":"Object","text":"<pre><code>Object(\n    name,\n    *,\n    lineno=None,\n    endlineno=None,\n    runtime=True,\n    docstring=None,\n    parent=None,\n    lines_collection=None,\n    modules_collection=None\n)\n</code></pre> <p>         Bases: <code>GetMembersMixin</code>, <code>SetMembersMixin</code>, <code>ObjectAliasMixin</code>, <code>SerializationMixin</code></p> <p>An abstract class representing a Python object.</p> <p>Attributes:</p> <ul> <li> kind             (<code>Kind</code>)         \u2013 <p>The object kind.</p> </li> <li> name             (<code>str</code>)         \u2013 <p>The object name.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The object ending line (inclusive), or None for modules.</p> </li> <li> docstring             (<code>Docstring | None</code>)         \u2013 <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013 <p>The object parent, or None if it is the top module.</p> </li> <li> members             (<code>dict[str, Object | Alias]</code>)         \u2013 <p>The object members.</p> </li> <li> labels             (<code>set[str]</code>)         \u2013 <p>The object labels.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The object name, as declared in the code.</p> </li> <li> lineno             (<code>int | None</code>)         \u2013 <p>The object starting line, or None for modules. Lines start at 1.</p> </li> <li> endlineno             (<code>int | None</code>)         \u2013 <p>The object ending line (inclusive), or None for modules.</p> </li> <li> runtime             (<code>bool</code>)         \u2013 <p>Whether this object is present at runtime or not.</p> </li> <li> docstring             (<code>Docstring | None</code>)         \u2013 <p>The object docstring.</p> </li> <li> parent             (<code>Module | Class | None</code>)         \u2013 <p>The object parent.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    lineno: int | None = None,\n    endlineno: int | None = None,\n    runtime: bool = True,\n    docstring: Docstring | None = None,\n    parent: Module | Class | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the object.\n\n    Parameters:\n        name: The object name, as declared in the code.\n        lineno: The object starting line, or None for modules. Lines start at 1.\n        endlineno: The object ending line (inclusive), or None for modules.\n        runtime: Whether this object is present at runtime or not.\n        docstring: The object docstring.\n        parent: The object parent.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    self.name: str = name\n    self.lineno: int | None = lineno\n    self.endlineno: int | None = endlineno\n    self.docstring: Docstring | None = docstring\n    self.parent: Module | Class | None = parent\n    self.members: dict[str, Object | Alias] = {}\n    self.labels: set[str] = set()\n    self.imports: dict[str, str] = {}\n    self.exports: set[str] | list[str | Name] | None = None\n    self.aliases: dict[str, Alias] = {}\n    self.runtime: bool = runtime\n    self._lines_collection: LinesCollection | None = lines_collection\n    self._modules_collection: ModulesCollection | None = modules_collection\n\n    # attach the docstring to this object\n    if docstring:\n        docstring.parent = self\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.attributes","title":"attributes  <code>property</code>","text":"<pre><code>attributes: dict[str, Attribute]\n</code></pre> <p>Return the attribute members.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Attribute]</code>         \u2013 <p>A dictionary of attributes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.canonical_path","title":"canonical_path  <code>cached</code> <code>property</code>","text":"<pre><code>canonical_path: str\n</code></pre> <p>Return the full dotted path of this object.</p> <p>The canonical path is the path where the object was defined (not imported).</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.classes","title":"classes  <code>property</code>","text":"<pre><code>classes: dict[str, Class]\n</code></pre> <p>Return the class members.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Class]</code>         \u2013 <p>A dictionary of classes.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filepath","title":"filepath  <code>cached</code> <code>property</code>","text":"<pre><code>filepath: Path | list[Path]\n</code></pre> <p>Return the file path where this object was defined.</p> <p>Returns:</p> <ul> <li> <code>Path | list[Path]</code>         \u2013 <p>A file path or a list of directories.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.functions","title":"functions  <code>property</code>","text":"<pre><code>functions: dict[str, Function]\n</code></pre> <p>Return the function members.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Function]</code>         \u2013 <p>A dictionary of functions.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstring","title":"has_docstring  <code>property</code>","text":"<pre><code>has_docstring: bool\n</code></pre> <p>Tell if this object has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_docstrings","title":"has_docstrings  <code>property</code>","text":"<pre><code>has_docstrings: bool\n</code></pre> <p>Tell if this object or any of its members has a non-empty docstring.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_attribute","title":"is_attribute  <code>property</code>","text":"<pre><code>is_attribute: bool\n</code></pre> <p>Tell if this object is an attribute.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_class","title":"is_class  <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this object is a class.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_function","title":"is_function  <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this object is a function.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_module","title":"is_module  <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this object is a module.</p>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines","title":"lines  <code>cached</code> <code>property</code>","text":"<pre><code>lines: list[str]\n</code></pre> <p>Return the lines containing the source of this object.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013 <p>A list of lines.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.lines_collection","title":"lines_collection  <code>cached</code> <code>property</code>","text":"<pre><code>lines_collection: LinesCollection\n</code></pre> <p>Return the lines collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LinesCollection</code>         \u2013 <p>A lines collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.module","title":"module  <code>cached</code> <code>property</code>","text":"<pre><code>module: Module\n</code></pre> <p>Return the parent module of this object.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When the object is not a module and does not have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules","title":"modules  <code>property</code>","text":"<pre><code>modules: dict[str, Module]\n</code></pre> <p>Return the module members.</p> <p>Returns:</p> <ul> <li> <code>dict[str, Module]</code>         \u2013 <p>A dictionary of modules.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.modules_collection","title":"modules_collection  <code>cached</code> <code>property</code>","text":"<pre><code>modules_collection: ModulesCollection\n</code></pre> <p>Return the modules collection attached to this object or its parents.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When no modules collection can be found in the object or its parents.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ModulesCollection</code>         \u2013 <p>A modules collection.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.package","title":"package  <code>cached</code> <code>property</code>","text":"<pre><code>package: Module\n</code></pre> <p>Return the absolute top module (the package) of this object.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>The parent module.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.path","title":"path  <code>cached</code> <code>property</code>","text":"<pre><code>path: str\n</code></pre> <p>Return the dotted path of this object.</p> <p>On regular objects (not aliases), the path is the canonical path.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A dotted path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_filepath","title":"relative_filepath  <code>cached</code> <code>property</code>","text":"<pre><code>relative_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the current working directory.</p> <p>If this object's file path is not relative to the current working directory, return its absolute path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013 <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.relative_package_filepath","title":"relative_package_filepath  <code>cached</code> <code>property</code>","text":"<pre><code>relative_package_filepath: Path\n</code></pre> <p>Return the file path where this object was defined, relative to the top module path.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When the relative path could not be computed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Path</code>         \u2013 <p>A file path.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.source","title":"source  <code>cached</code> <code>property</code>","text":"<pre><code>source: str\n</code></pre> <p>Return the source code of this object.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The source code.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.as_dict","title":"as_dict","text":"<pre><code>as_dict(*, full=False, **kwargs)\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>)         \u2013 <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\n        \"kind\": self.kind,\n        \"name\": self.name,\n    }\n\n    if full:\n        base.update(\n            {\n                \"path\": self.path,\n                \"filepath\": self.filepath,\n                \"relative_filepath\": self.relative_filepath,\n                \"relative_package_filepath\": self.relative_package_filepath,\n            },\n        )\n\n    if self.lineno:\n        base[\"lineno\"] = self.lineno\n    if self.endlineno:\n        base[\"endlineno\"] = self.endlineno\n    if self.docstring:\n        base[\"docstring\"] = self.docstring\n\n    # doing this last for a prettier JSON dump\n    base[\"labels\"] = self.labels\n    base[\"members\"] = [member.as_dict(full=full, **kwargs) for member in self.members.values()]\n\n    return base\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.filter_members","title":"filter_members","text":"<pre><code>filter_members(*predicates)\n</code></pre> <p>Filter and return members based on predicates.</p> <p>Parameters:</p> <ul> <li> *predicates             (<code>Callable[[Object | Alias], bool]</code>)         \u2013 <p>A list of predicates, i.e. callables accepting a member as argument and returning a boolean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Object | Alias]</code>         \u2013 <p>A dictionary of members.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def filter_members(self, *predicates: Callable[[Object | Alias], bool]) -&gt; dict[str, Object | Alias]:\n\"\"\"Filter and return members based on predicates.\n\n    Parameters:\n        *predicates: A list of predicates, i.e. callables accepting a member as argument and returning a boolean.\n\n    Returns:\n        A dictionary of members.\n    \"\"\"\n    if not predicates:\n        return self.members\n    members: dict[str, Object | Alias] = {}\n    for name, member in self.members.items():\n        if all(predicate(member) for predicate in predicates):\n            members[name] = member\n    return members\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.has_labels","title":"has_labels","text":"<pre><code>has_labels(labels)\n</code></pre> <p>Tell if this object has all the given labels.</p> <p>Parameters:</p> <ul> <li> labels             (<code>set[str]</code>)         \u2013 <p>A set of labels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def has_labels(self, labels: set[str]) -&gt; bool:\n\"\"\"Tell if this object has all the given labels.\n\n    Parameters:\n        labels: A set of labels.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return all(label in self.labels for label in labels)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.is_kind","title":"is_kind","text":"<pre><code>is_kind(kind)\n</code></pre> <p>Tell if this object is of the given kind.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str | Kind | set[str | Kind]</code>)         \u2013 <p>An instance or set of kinds (strings or enumerations).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When an empty set is given as argument.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def is_kind(self, kind: str | Kind | set[str | Kind]) -&gt; bool:\n\"\"\"Tell if this object is of the given kind.\n\n    Parameters:\n        kind: An instance or set of kinds (strings or enumerations).\n\n    Raises:\n        ValueError: When an empty set is given as argument.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if isinstance(kind, set):\n        if not kind:\n            raise ValueError(\"kind must not be an empty set\")\n        return self.kind in (knd if isinstance(knd, Kind) else Kind(knd) for knd in kind)\n    if isinstance(kind, str):\n        kind = Kind(kind)\n    return self.kind is kind\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.member_is_exported","title":"member_is_exported","text":"<pre><code>member_is_exported(member, *, explicitely=True)\n</code></pre> <p>Tell if a member of this object is \"exported\".</p> <p>By exported, we mean that the object is included in the <code>__all__</code> attribute of its parent module or class. When <code>_all__</code> is not defined, we consider the member to be implicitely exported, unless it's a module and it was not imported, and unless it's not defined at runtime.</p> <p>Parameters:</p> <ul> <li> member             (<code>Object | Alias</code>)         \u2013 <p>The member to verify.</p> </li> <li> explicitely             (<code>bool</code>)         \u2013 <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def member_is_exported(self, member: Object | Alias, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if a member of this object is \"exported\".\n\n    By exported, we mean that the object is included in the `__all__` attribute\n    of its parent module or class. When `_all__` is not defined,\n    we consider the member to be *implicitely* exported,\n    unless it's a module and it was not imported,\n    and unless it's not defined at runtime.\n\n    Parameters:\n        member: The member to verify.\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    if not member.runtime:\n        return False\n    if self.exports is None:\n        return not explicitely and (member.is_alias or not member.is_module or member.name in self.imports)\n    return member.name in self.exports\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Object.resolve","title":"resolve","text":"<pre><code>resolve(name)\n</code></pre> <p>Resolve a name within this object's and parents' scope.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The name to resolve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NameResolutionError</code>           \u2013         <p>When the name could not be resolved.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The resolved name.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def resolve(self, name: str) -&gt; str:\n\"\"\"Resolve a name within this object's and parents' scope.\n\n    Parameters:\n        name: The name to resolve.\n\n    Raises:\n        NameResolutionError: When the name could not be resolved.\n\n    Returns:\n        The resolved name.\n    \"\"\"\n    if name in self.members:\n        if self.members[name].is_alias:\n            return self.members[name].target_path  # type: ignore[union-attr]\n        return self.members[name].path\n    if name in self.imports:\n        return self.imports[name]\n    if self.parent is None:\n        # could be a built-in\n        raise NameResolutionError(f\"{name} could not be resolved in the scope of {self.path}\")\n    if name == self.parent.name and not self.parent.is_module:\n        return self.parent.path\n    return self.parent.resolve(name)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter","title":"Parameter","text":"<pre><code>Parameter(\n    name, *, annotation=None, kind=None, default=None\n)\n</code></pre> <p>This class represent a function parameter.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The parameter name.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The parameter annotation, if any.</p> </li> <li> kind             (<code>ParameterKind | None</code>)         \u2013 <p>The parameter kind.</p> </li> <li> default             (<code>str | None</code>)         \u2013 <p>The parameter default, if any.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The parameter name.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The parameter annotation, if any.</p> </li> <li> kind             (<code>ParameterKind | None</code>)         \u2013 <p>The parameter kind.</p> </li> <li> default             (<code>str | None</code>)         \u2013 <p>The parameter default, if any.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    annotation: str | Name | Expression | None = None,\n    kind: ParameterKind | None = None,\n    default: str | None = None,\n) -&gt; None:\n\"\"\"Initialize the parameter.\n\n    Parameters:\n        name: The parameter name.\n        annotation: The parameter annotation, if any.\n        kind: The parameter kind.\n        default: The parameter default, if any.\n    \"\"\"\n    self.name: str = name\n    self.annotation: str | Name | Expression | None = annotation\n    self.kind: ParameterKind | None = kind\n    self.default: str | None = default\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.required","title":"required  <code>property</code>","text":"<pre><code>required: bool\n</code></pre> <p>Tell if this parameter is required.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameter.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this parameter's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this parameter's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"name\": self.name,\n        \"annotation\": self.annotation,\n        \"kind\": self.kind,\n        \"default\": self.default,\n    }\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.ParameterKind","title":"ParameterKind","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enumeration of the different parameter kinds.</p> <p>Attributes:</p> <ul> <li> positional_only             (<code>str</code>)         \u2013 <p>Positional-only parameter.</p> </li> <li> positional_or_keyword             (<code>str</code>)         \u2013 <p>Positional or keyword parameter.</p> </li> <li> var_positional             (<code>str</code>)         \u2013 <p>Variadic positional parameter.</p> </li> <li> keyword_only             (<code>str</code>)         \u2013 <p>Keyword-only parameter.</p> </li> <li> var_keyword             (<code>str</code>)         \u2013 <p>Variadic keyword parameter.</p> </li> </ul>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters","title":"Parameters","text":"<pre><code>Parameters(*parameters)\n</code></pre> <p>This class is a container for parameters.</p> <p>It allows to get parameters using their position (index) or their name.</p> <p>Parameters:</p> <ul> <li> *parameters             (<code>Parameter</code>)         \u2013 <p>The initial parameters to add to the container.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def __init__(self, *parameters: Parameter) -&gt; None:\n\"\"\"Initialize the parameters container.\n\n    Parameters:\n        *parameters: The initial parameters to add to the container.\n    \"\"\"\n    self._parameters_list: list[Parameter] = []\n    self._parameters_dict: dict[str, Parameter] = {}\n    for parameter in parameters:\n        self.add(parameter)\n</code></pre>"},{"location":"reference/griffe/dataclasses/#griffe.dataclasses.Parameters.add","title":"add","text":"<pre><code>add(parameter)\n</code></pre> <p>Add a parameter to the container.</p> <p>Parameters:</p> <ul> <li> parameter             (<code>Parameter</code>)         \u2013 <p>The function parameter to add.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When a parameter with the same name is already present.</p> </li> </ul> Source code in <code>src/griffe/dataclasses.py</code> <pre><code>def add(self, parameter: Parameter) -&gt; None:\n\"\"\"Add a parameter to the container.\n\n    Parameters:\n        parameter: The function parameter to add.\n\n    Raises:\n        ValueError: When a parameter with the same name is already present.\n    \"\"\"\n    if parameter.name not in self._parameters_dict:\n        self._parameters_dict[parameter.name] = parameter\n        self._parameters_list.append(parameter)\n    else:\n        raise ValueError(f\"parameter {parameter.name} already present\")\n</code></pre>"},{"location":"reference/griffe/diff/","title":"diff","text":"<p>This module exports \"breaking changes\" related utilities.</p>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedTypeBreakage","title":"AttributeChangedTypeBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for attributes whose type changed.</p>"},{"location":"reference/griffe/diff/#griffe.diff.AttributeChangedValueBreakage","title":"AttributeChangedValueBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for attributes whose value changed.</p>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage","title":"Breakage","text":"<pre><code>Breakage(obj, old_value, new_value, details='')\n</code></pre> <p>Breakages can explain what broke from a version to another.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object</code>)         \u2013 <p>The object related to the breakage.</p> </li> <li> old_value             (<code>Any</code>)         \u2013 <p>The old value.</p> </li> <li> new_value             (<code>Any</code>)         \u2013 <p>The new, incompatible value.</p> </li> <li> details             (<code>str</code>)         \u2013 <p>Some details about the breakage.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def __init__(self, obj: Object, old_value: Any, new_value: Any, details: str = \"\") -&gt; None:\n\"\"\"Initialize the breakage.\n\n    Parameters:\n        obj: The object related to the breakage.\n        old_value: The old value.\n        new_value: The new, incompatible value.\n        details: Some details about the breakage.\n    \"\"\"\n    self.obj = obj\n    self.old_value = old_value\n    self.new_value = new_value\n    self.details = details\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.as_dict","title":"as_dict","text":"<pre><code>as_dict(*, full=False, **kwargs)\n</code></pre> <p>Return this object's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>)         \u2013 <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def as_dict(self, *, full: bool = False, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this object's data as a dictionary.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"kind\": self.kind,\n        \"object_path\": self.obj.path,\n        \"old_value\": self.old_value,\n        \"new_value\": self.new_value,\n    }\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.Breakage.explain","title":"explain","text":"<pre><code>explain(style=ExplanationStyle.ONE_LINE)\n</code></pre> <p>Explain the breakage by showing old and new value.</p> <p>Parameters:</p> <ul> <li> style             (<code>ExplanationStyle</code>)         \u2013 <p>The explanation style to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>An explanation.</p> </li> </ul> Source code in <code>src/griffe/diff.py</code> <pre><code>def explain(self, style: ExplanationStyle = ExplanationStyle.ONE_LINE) -&gt; str:\n\"\"\"Explain the breakage by showing old and new value.\n\n    Parameters:\n        style: The explanation style to use.\n\n    Returns:\n        An explanation.\n    \"\"\"\n    return getattr(self, f\"_explain_{style.value}\")()\n</code></pre>"},{"location":"reference/griffe/diff/#griffe.diff.BreakageKind","title":"BreakageKind","text":"<p>         Bases: <code>enum.Enum</code></p> <p>An enumeration of the possible breakages.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ClassRemovedBaseBreakage","title":"ClassRemovedBaseBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for removed base classes.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ExplanationStyle","title":"ExplanationStyle","text":"<p>         Bases: <code>enum.Enum</code></p> <p>An enumeration of the possible styles for explanations.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectChangedKindBreakage","title":"ObjectChangedKindBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for objects whose kind changed.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ObjectRemovedBreakage","title":"ObjectRemovedBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for removed objects.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterAddedRequiredBreakage","title":"ParameterAddedRequiredBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for new parameters added as required.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedDefaultBreakage","title":"ParameterChangedDefaultBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters whose default value changed.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedKindBreakage","title":"ParameterChangedKindBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters whose kind changed.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterChangedRequiredBreakage","title":"ParameterChangedRequiredBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for parameters which became required.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterMovedBreakage","title":"ParameterMovedBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for moved parameters.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ParameterRemovedBreakage","title":"ParameterRemovedBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for removed parameters.</p>"},{"location":"reference/griffe/diff/#griffe.diff.ReturnChangedTypeBreakage","title":"ReturnChangedTypeBreakage","text":"<p>         Bases: <code>Breakage</code></p> <p>Specific breakage class for return values which changed type.</p>"},{"location":"reference/griffe/encoders/","title":"encoders","text":"<p>This module contains data encoders/serializers and decoders/deserializers.</p> <p>The available formats are:</p> <ul> <li><code>JSON</code>: see the <code>JSONEncoder</code> and <code>json_decoder</code>.</li> </ul>"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder","title":"JSONEncoder","text":"<pre><code>JSONEncoder(\n    *args,\n    full=False,\n    docstring_parser=None,\n    docstring_options=None,\n    **kwargs\n)\n</code></pre> <p>         Bases: <code>json.JSONEncoder</code></p> <p>JSON encoder.</p> <p>JSON encoders can be used directly, or through the <code>json.dump</code> or <code>json.dumps</code> methods.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from griffe.encoders import JSONEncoder\n&gt;&gt;&gt; JSONEncoder(full=True).encode(..., **kwargs)\n</code></pre> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; from griffe.encoders import JSONEncoder\n&gt;&gt;&gt; json.dumps(..., cls=JSONEncoder, full=True, **kwargs)\n</code></pre> <p>Parameters:</p> <ul> <li> *args             (<code>Any</code>)         \u2013 <p>See <code>json.JSONEncoder</code>.</p> </li> <li> full             (<code>bool</code>)         \u2013 <p>Whether to dump full data or base data. If you plan to reload the data in Python memory using the <code>json_decoder</code>, you don't need the full data as it can be infered again using the base data. If you want to feed a non-Python tool instead, dump the full data.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>See <code>json.JSONEncoder</code>.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    full: bool = False,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    **kwargs: Any,\n) -&gt; None:\n\"\"\"Initialize the encoder.\n\n    Parameters:\n        *args: See [`json.JSONEncoder`][].\n        full: Whether to dump full data or base data.\n            If you plan to reload the data in Python memory\n            using the [`json_decoder`][griffe.encoders.json_decoder],\n            you don't need the full data as it can be infered again\n            using the base data. If you want to feed a non-Python\n            tool instead, dump the full data.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        **kwargs: See [`json.JSONEncoder`][].\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self.full: bool = full\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n</code></pre>"},{"location":"reference/griffe/encoders/#griffe.encoders.JSONEncoder.default","title":"default","text":"<pre><code>default(obj)\n</code></pre> <p>Return a serializable representation of the given object.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>The object to serialize.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013 <p>A serializable representation.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def default(self, obj: Any) -&gt; Any:\n\"\"\"Return a serializable representation of the given object.\n\n    Parameters:\n        obj: The object to serialize.\n\n    Returns:\n        A serializable representation.\n    \"\"\"\n    try:\n        return obj.as_dict(full=self.full, docstring_parser=self.docstring_parser, **self.docstring_options)\n    except AttributeError:\n        return _json_encoder_map.get(type(obj), super().default)(obj)\n</code></pre>"},{"location":"reference/griffe/encoders/#griffe.encoders.json_decoder","title":"json_decoder","text":"<pre><code>json_decoder(obj_dict)\n</code></pre> <p>Decode dictionaries as data classes.</p> <p>The <code>json.loads</code> method walks the tree from bottom to top.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; from griffe.encoders import json_decoder\n&gt;&gt;&gt; json.loads(..., object_hook=json_decoder)\n</code></pre> <p>Parameters:</p> <ul> <li> obj_dict             (<code>dict[str, Any]</code>)         \u2013 <p>The dictionary to decode.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any] | Object | Alias | Parameter</code>         \u2013 <p>An instance of a data class.</p> </li> </ul> Source code in <code>src/griffe/encoders.py</code> <pre><code>def json_decoder(obj_dict: dict[str, Any]) -&gt; dict[str, Any] | Object | Alias | Parameter:\n\"\"\"Decode dictionaries as data classes.\n\n    The [`json.loads`][] method walks the tree from bottom to top.\n\n    Examples:\n        &gt;&gt;&gt; import json\n        &gt;&gt;&gt; from griffe.encoders import json_decoder\n        &gt;&gt;&gt; json.loads(..., object_hook=json_decoder)\n\n    Parameters:\n        obj_dict: The dictionary to decode.\n\n    Returns:\n        An instance of a data class.\n    \"\"\"\n    if \"kind\" in obj_dict:\n        try:\n            kind = Kind(obj_dict[\"kind\"])\n        except ValueError:\n            return _load_parameter(obj_dict)\n        return _loader_map[kind](obj_dict)\n    return obj_dict\n</code></pre>"},{"location":"reference/griffe/exceptions/","title":"exceptions","text":"<p>This module contains all the exceptions specific to Griffe.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.AliasResolutionError","title":"AliasResolutionError","text":"<pre><code>AliasResolutionError(alias)\n</code></pre> <p>         Bases: <code>GriffeError</code></p> <p>Exception for alias that cannot be resolved.</p> <p>Parameters:</p> <ul> <li> alias             (<code>Alias</code>)         \u2013 <p>The alias that could not be resolved.</p> </li> </ul> Source code in <code>src/griffe/exceptions.py</code> <pre><code>def __init__(self, alias: Alias) -&gt; None:\n\"\"\"Initialize the exception.\n\n    Parameters:\n        alias: The alias that could not be resolved.\n    \"\"\"\n    self.alias: Alias = alias\n    message = f\"Could not resolve alias {alias.path} pointing at {alias.target_path}\"\n    try:\n        filepath = alias.parent.relative_filepath  # type: ignore[union-attr]\n    except BuiltinModuleError:\n        pass\n    else:\n        message += f\" (in {filepath}:{alias.alias_lineno})\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.BuiltinModuleError","title":"BuiltinModuleError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception raised when trying to access the filepath of a builtin module.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.CyclicAliasError","title":"CyclicAliasError","text":"<pre><code>CyclicAliasError(chain)\n</code></pre> <p>         Bases: <code>GriffeError</code></p> <p>Exception raised when a cycle is detected in aliases.</p> <p>Parameters:</p> <ul> <li> chain             (<code>list[str]</code>)         \u2013 <p>The cyclic chain of items (such as target path).</p> </li> </ul> Source code in <code>src/griffe/exceptions.py</code> <pre><code>def __init__(self, chain: list[str]) -&gt; None:\n\"\"\"Initialize the exception.\n\n    Parameters:\n        chain: The cyclic chain of items (such as target path).\n    \"\"\"\n    self.chain: list[str] = chain\n    super().__init__(\"Cyclic aliases detected:\\n  \" + \"\\n  \".join(self.chain))\n</code></pre>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionError","title":"ExtensionError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Base class for errors raised by extensions.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.ExtensionNotLoadedError","title":"ExtensionNotLoadedError","text":"<p>         Bases: <code>ExtensionError</code></p> <p>Exception raised when an extension could not be loaded.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.GriffeError","title":"GriffeError","text":"<p>         Bases: <code>Exception</code></p> <p>The base exception for all Griffe errors.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LastNodeError","title":"LastNodeError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception raised when trying to access a next or previous node.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.LoadingError","title":"LoadingError","text":"<p>         Bases: <code>GriffeError</code></p> <p>The base exception for all Griffe errors.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.NameResolutionError","title":"NameResolutionError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception for names that cannot be resolved in a object scope.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.RootNodeError","title":"RootNodeError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception raised when trying to use siblings properties on a root node.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnhandledEditableModuleError","title":"UnhandledEditableModuleError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception for unhandled editables modules, when searching modules.</p>"},{"location":"reference/griffe/exceptions/#griffe.exceptions.UnimportableModuleError","title":"UnimportableModuleError","text":"<p>         Bases: <code>GriffeError</code></p> <p>Exception for modules that cannot be imported.</p>"},{"location":"reference/griffe/expressions/","title":"expressions","text":"<p>This module contains the data classes that represent resolvable names and expressions.</p>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression","title":"Expression","text":"<pre><code>Expression(*values)\n</code></pre> <p>         Bases: <code>list</code></p> <p>This class represents a Python expression.</p> <p>For example, it can represent complex annotations such as:</p> <ul> <li><code>Optional[Dict[str, Tuple[int, bool]]]</code></li> <li><code>str | Callable | list[int]</code></li> </ul> <p>Expressions are simple lists containing strings, names or expressions. Each name in the expression can be resolved to its full name within its scope.</p> <p>Parameters:</p> <ul> <li> *values             (<code>str | Expression | Name</code>)         \u2013 <p>The initial values of the expression.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def __init__(self, *values: str | Expression | Name) -&gt; None:\n\"\"\"Initialize the expression.\n\n    Parameters:\n        *values: The initial values of the expression.\n    \"\"\"\n    super().__init__()\n    self.extend(values)\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.full","title":"full  <code>property</code>","text":"<pre><code>full: str\n</code></pre> <p>Return self as a string.</p> <p>This property is only useful to the AST utils.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>Self as a string.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_classvar","title":"is_classvar  <code>property</code>","text":"<pre><code>is_classvar: bool\n</code></pre> <p>Tell whether this expression represents a ClassVar.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_generator","title":"is_generator  <code>property</code>","text":"<pre><code>is_generator: bool\n</code></pre> <p>Tell whether this expression represents a generator.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_iterator","title":"is_iterator  <code>property</code>","text":"<pre><code>is_iterator: bool\n</code></pre> <p>Tell whether this expression represents an iterator.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.is_tuple","title":"is_tuple  <code>property</code>","text":"<pre><code>is_tuple: bool\n</code></pre> <p>Tell whether this expression represents a tuple.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.kind","title":"kind  <code>property</code>","text":"<pre><code>kind: str\n</code></pre> <p>Return the main type object as a string.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The main type of this expression.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.non_optional","title":"non_optional  <code>cached</code> <code>property</code>","text":"<pre><code>non_optional: Expression\n</code></pre> <p>Return the same expression as non-optional.</p> <p>This will return a new expression without the <code>Optional[]</code> or <code>| None</code> parts.</p> <p>Returns:</p> <ul> <li> <code>Expression</code>         \u2013 <p>A non-optional expression.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.generator_items","title":"generator_items","text":"<pre><code>generator_items()\n</code></pre> <p>Return the items of a generator.</p> <p>Returns:</p> <ul> <li> <code>Name | Expression</code>         \u2013 <p>The yield type.</p> </li> <li> <code>Name | Expression</code>         \u2013 <p>The send/receive type.</p> </li> <li> <code>Name | Expression</code>         \u2013 <p>The return type.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def generator_items(self) -&gt; tuple[Name | Expression, Name | Expression, Name | Expression]:\n\"\"\"Return the items of a generator.\n\n    Returns:\n        The yield type.\n        The send/receive type.\n        The return type.\n    \"\"\"\n    return self.non_optional[2][0], self[2][2], self[2][4]\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.iterator_item","title":"iterator_item","text":"<pre><code>iterator_item()\n</code></pre> <p>Return the item of an iterator.</p> <p>Returns:</p> <ul> <li> <code>Name | Expression</code>         \u2013 <p>The iterator item.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def iterator_item(self) -&gt; Name | Expression:\n\"\"\"Return the item of an iterator.\n\n    Returns:\n        The iterator item.\n    \"\"\"\n    return self.non_optional[2]\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_item","title":"tuple_item","text":"<pre><code>tuple_item(nth)\n</code></pre> <p>Return the n-th item of this tuple expression.</p> <p>Parameters:</p> <ul> <li> nth             (<code>int</code>)         \u2013 <p>The item number.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Name</code>         \u2013 <p>A string or name.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def tuple_item(self, nth: int) -&gt; str | Name:\n\"\"\"Return the n-th item of this tuple expression.\n\n    Parameters:\n        nth: The item number.\n\n    Returns:\n        A string or name.\n    \"\"\"\n    #  0  1     2     3\n    #       N , N , N\n    #       0 1 2 3 4\n    return self.non_optional[2][2 * nth]\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Expression.tuple_items","title":"tuple_items","text":"<pre><code>tuple_items()\n</code></pre> <p>Return a tuple items as a list.</p> <p>Returns:</p> <ul> <li> <code>list[Name | Expression]</code>         \u2013 <p>The tuple items.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def tuple_items(self) -&gt; list[Name | Expression]:\n\"\"\"Return a tuple items as a list.\n\n    Returns:\n        The tuple items.\n    \"\"\"\n    return self.non_optional[2][::2]\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Name","title":"Name","text":"<pre><code>Name(source, full)\n</code></pre> <p>This class represents a Python object identified by a name in a given scope.</p> <p>Attributes:</p> <ul> <li> source             (<code>str</code>)         \u2013 <p>The name as written in the source code.</p> </li> </ul> <p>Parameters:</p> <ul> <li> source             (<code>str</code>)         \u2013 <p>The name as written in the source code.</p> </li> <li> full             (<code>str | Callable</code>)         \u2013 <p>The full, resolved name in the given scope, or a callable to resolve it later.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def __init__(self, source: str, full: str | Callable) -&gt; None:\n\"\"\"Initialize the name.\n\n    Parameters:\n        source: The name as written in the source code.\n        full: The full, resolved name in the given scope, or a callable to resolve it later.\n    \"\"\"\n    self.source: str = source\n    if isinstance(full, str):\n        self._full: str = full\n        self._resolver: Callable = lambda: None\n    else:\n        self._full = \"\"\n        self._resolver = full\n</code></pre>"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.brief","title":"brief  <code>property</code>","text":"<pre><code>brief: str\n</code></pre> <p>Return the brief source name.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The last part of the source name.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.full","title":"full  <code>property</code>","text":"<pre><code>full: str\n</code></pre> <p>Return the full, resolved name.</p> <p>If it was given when creating the name, return that. If a callable was given, call it and return its result. It the name cannot be resolved, return the source.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The resolved name or the source.</p> </li> </ul>"},{"location":"reference/griffe/expressions/#griffe.expressions.Name.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this name's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/expressions.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this name's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\"source\": self.source, \"full\": self.full}\n</code></pre>"},{"location":"reference/griffe/finder/","title":"finder","text":"<p>This module contains the code allowing to find modules.</p>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder","title":"ModuleFinder","text":"<pre><code>ModuleFinder(search_paths=None)\n</code></pre> <p>The Griffe finder, allowing to find modules on the file system.</p> <p>Parameters:</p> <ul> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>Optional paths to search into.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, search_paths: Sequence[str | Path] | None = None) -&gt; None:\n\"\"\"Initialize the finder.\n\n    Parameters:\n        search_paths: Optional paths to search into.\n    \"\"\"\n    self._paths_contents: dict[Path, list[Path]] = {}\n    # optimization: pre-compute Paths to relieve CPU when joining paths\n    self.search_paths = [path if isinstance(path, Path) else Path(path) for path in search_paths or sys.path]\n    self._extend_from_pth_files()\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_package","title":"find_package","text":"<pre><code>find_package(module_name)\n</code></pre> <p>Find a package or namespace package.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013 <p>The module name.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>           \u2013         <p>When the module cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | NamespacePackage</code>         \u2013 <p>A package or namespace package wrapper.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def find_package(self, module_name: str) -&gt; Package | NamespacePackage:\n\"\"\"Find a package or namespace package.\n\n    Parameters:\n        module_name: The module name.\n\n    Raises:\n        ModuleNotFoundError: When the module cannot be found.\n\n    Returns:\n        A package or namespace package wrapper.\n    \"\"\"\n    filepaths = [\n        Path(module_name),\n        # TODO: handle .py[cod] and .so files?\n        Path(f\"{module_name}.py\"),\n    ]\n\n    namespace_dirs = []\n    for path in self.search_paths:\n        path_contents = self._contents(path)\n        if path_contents:\n            for choice in filepaths:\n                abs_path = path / choice\n                if abs_path in path_contents:\n                    if abs_path.suffix:\n                        stubs = abs_path.with_suffix(\".pyi\")\n                        return Package(module_name, abs_path, stubs if stubs.exists() else None)\n                    init_module = abs_path / \"__init__.py\"\n                    if init_module.exists() and not _is_pkg_style_namespace(init_module):\n                        stubs = init_module.with_suffix(\".pyi\")\n                        return Package(module_name, init_module, stubs if stubs.exists() else None)\n                    namespace_dirs.append(abs_path)\n\n    if namespace_dirs:\n        return NamespacePackage(module_name, namespace_dirs)\n\n    raise ModuleNotFoundError(module_name)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.find_spec","title":"find_spec","text":"<pre><code>find_spec(module, *, try_relative_path=True)\n</code></pre> <p>Find the top module of a module.</p> <p>If a Path is passed, only try to find the module as a file path. If a string is passed, first try to find the module as a file path, then look into the search paths.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module name or path.</p> </li> <li> try_relative_path             (<code>bool</code>)         \u2013 <p>Whether to try finding the module as a relative path, when the given module is not already a path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>           \u2013         <p>When a Path was passed and the module could not be found:</p> <ul> <li>the directory has no <code>__init__.py</code> file in it</li> <li>the path does not exist</li> </ul> </li> <li> <code>ModuleNotFoundError</code>           \u2013         <p>When a string was passed and the module could not be found:</p> <ul> <li>no <code>module/__init__.py</code></li> <li>no <code>module.py</code></li> <li>no <code>module.pth</code></li> <li>no <code>module</code> directory (namespace packages)</li> <li>or unsupported .pth file</li> </ul> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, Package | NamespacePackage]</code>         \u2013 <p>The name of the module, and an instance representing its (namespace) package.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def find_spec(\n    self,\n    module: str | Path,\n    *,\n    try_relative_path: bool = True,\n) -&gt; tuple[str, Package | NamespacePackage]:\n\"\"\"Find the top module of a module.\n\n    If a Path is passed, only try to find the module as a file path.\n    If a string is passed, first try to find the module as a file path,\n    then look into the search paths.\n\n    Parameters:\n        module: The module name or path.\n        try_relative_path: Whether to try finding the module as a relative path,\n            when the given module is not already a path.\n\n    Raises:\n        FileNotFoundError: When a Path was passed and the module could not be found:\n\n            - the directory has no `__init__.py` file in it\n            - the path does not exist\n\n        ModuleNotFoundError: When a string was passed and the module could not be found:\n\n            - no `module/__init__.py`\n            - no `module.py`\n            - no `module.pth`\n            - no `module` directory (namespace packages)\n            - or unsupported .pth file\n\n    Returns:\n        The name of the module, and an instance representing its (namespace) package.\n    \"\"\"\n    module_path: Path | list[Path]\n    if isinstance(module, Path):\n        module_name, module_path = self._module_name_path(module)  # type: ignore[arg-type]\n        top_module_name = self._top_module_name(module_path)\n    elif try_relative_path:\n        try:\n            module_name, module_path = self._module_name_path(Path(module))\n        except FileNotFoundError:\n            module_name = module  # type: ignore[assignment]\n            top_module_name = module.split(\".\", 1)[0]  # type: ignore[union-attr]\n        else:\n            top_module_name = self._top_module_name(module_path)\n    else:\n        module_name = module\n        top_module_name = module.split(\".\", 1)[0]\n    return module_name, self.find_package(top_module_name)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.iter_submodules","title":"iter_submodules","text":"<pre><code>iter_submodules(path, seen=None)\n</code></pre> <p>Iterate on a module's submodules, if any.</p> <p>Parameters:</p> <ul> <li> path             (<code>Path | list[Path]</code>)         \u2013 <p>The module path.</p> </li> <li> seen             (<code>set | None</code>)         \u2013 <p>If not none, this set is used to skip some files. The goal is to replicate the behavior of Python by only using the first packages (with <code>__init__</code> modules) of the same name found in different namespace packages. As soon as we find an <code>__init__</code> module, we add its parent path to the <code>seen</code> set, which will be reused when scanning the next namespace packages.</p> </li> </ul> <p>Yields:</p> <ul> <li> name_parts(            <code>tuple[str, ...]</code> )        \u2013 <p>The parts of a submodule name.</p> </li> <li> filepath(            <code>Path</code> )        \u2013 <p>A submodule filepath.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def iter_submodules(\n    self,\n    path: Path | list[Path],\n    seen: set | None = None,\n) -&gt; Iterator[NamePartsAndPathType]:\n\"\"\"Iterate on a module's submodules, if any.\n\n    Parameters:\n        path: The module path.\n        seen: If not none, this set is used to skip some files.\n            The goal is to replicate the behavior of Python by\n            only using the first packages (with `__init__` modules)\n            of the same name found in different namespace packages.\n            As soon as we find an `__init__` module, we add its parent\n            path to the `seen` set, which will be reused when scanning\n            the next namespace packages.\n\n    Yields:\n        name_parts (tuple[str, ...]): The parts of a submodule name.\n        filepath (Path): A submodule filepath.\n    \"\"\"\n    if isinstance(path, list):\n        seen = set()\n        for path_elem in path:\n            yield from self.iter_submodules(path_elem, seen)\n        return\n\n    if path.stem == \"__init__\":\n        path = path.parent\n    # optimization: just check if the file name ends with .py[icod]/.so\n    # (to distinguish it from a directory),\n    # not if it's an actual file\n    elif path.suffix in self.extensions_set:\n        return\n\n    skip = set(seen) if seen else set()\n    for subpath in self._filter_py_modules(path):\n        rel_subpath = subpath.relative_to(path)\n        if rel_subpath.parent in skip:\n            logger.debug(f\"Skip {subpath}, another module took precedence\")\n            continue\n        py_file = rel_subpath.suffix == \".py\"\n        stem = rel_subpath.stem\n        if not py_file:\n            # .py[cod] and .so files look like `name.cpython-38-x86_64-linux-gnu.ext`\n            stem = stem.split(\".\", 1)[0]\n        if stem == \"__init__\":\n            # optimization: since it's a relative path,\n            # if it has only one part and is named __init__,\n            # it means it's the starting path\n            # (no need to compare it against starting path)\n            if len(rel_subpath.parts) == 1:\n                continue\n            yield rel_subpath.parts[:-1], subpath\n            if seen is not None:\n                seen.add(rel_subpath.parent)\n        elif py_file:\n            yield rel_subpath.with_suffix(\"\").parts, subpath\n        else:\n            yield rel_subpath.with_name(stem).parts, subpath\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.ModuleFinder.submodules","title":"submodules","text":"<pre><code>submodules(module)\n</code></pre> <p>Return the list of a module's submodules.</p> <p>Parameters:</p> <ul> <li> module             (<code>Module</code>)         \u2013 <p>The parent module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[NamePartsAndPathType]</code>         \u2013 <p>A list of tuples containing the parts of the submodule name and its path.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def submodules(self, module: Module) -&gt; list[NamePartsAndPathType]:\n\"\"\"Return the list of a module's submodules.\n\n    Parameters:\n        module: The parent module.\n\n    Returns:\n        A list of tuples containing the parts of the submodule name and its path.\n    \"\"\"\n    return sorted(self.iter_submodules(module.filepath), key=_module_depth)\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.NamespacePackage","title":"NamespacePackage","text":"<pre><code>NamespacePackage(name, path)\n</code></pre> <p>This class is a simple placeholder used during the process of finding packages.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The package name.</p> </li> <li> path             (<code>list[Path]</code>)         \u2013 <p>The package paths.</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, name: str, path: list[Path]) -&gt; None:\n\"\"\"Initialize the namespace package.\n\n    Parameters:\n        name: The package name.\n        path: The package paths.\n    \"\"\"\n    self.name: str = name\n    self.path: list[Path] = path\n</code></pre>"},{"location":"reference/griffe/finder/#griffe.finder.Package","title":"Package","text":"<pre><code>Package(name, path, stubs=None)\n</code></pre> <p>This class is a simple placeholder used during the process of finding packages.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The package name.</p> </li> <li> path             (<code>Path</code>)         \u2013 <p>The package path(s).</p> </li> <li> stubs             (<code>Path | None</code>)         \u2013 <p>An optional path to the related stubs file (.pyi).</p> </li> </ul> Source code in <code>src/griffe/finder.py</code> <pre><code>def __init__(self, name: str, path: Path, stubs: Path | None = None) -&gt; None:\n\"\"\"Initialize the package.\n\n    Parameters:\n        name: The package name.\n        path: The package path(s).\n        stubs: An optional path to the related stubs file (.pyi).\n    \"\"\"\n    self.name: str = name\n    self.path: Path = path\n    self.stubs: Path | None = stubs\n</code></pre>"},{"location":"reference/griffe/git/","title":"git","text":"<p>This module contains the code allowing to load modules from specific git commits.</p> <pre><code>from griffe.git import load_git\n\n# where `repo` is the folder *containing* `.git`\nold_api = load_git(\"my_module\", commit=\"v0.1.0\", repo=\"path/to/repo\")\n</code></pre>"},{"location":"reference/griffe/git/#griffe.git.load_git","title":"load_git","text":"<pre><code>load_git(\n    module,\n    *,\n    ref=\"HEAD\",\n    repo=\".\",\n    submodules=True,\n    extensions=None,\n    search_paths=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n    allow_inspection=True\n)\n</code></pre> <p>Load and return a module from a specific Git reference.</p> <p>This function will create a temporary git worktree at the requested reference before loading <code>module</code> with <code>griffe.load</code>.</p> <p>This function requires that the <code>git</code> executable is installed.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module path, relative to the repository root.</p> </li> <li> ref             (<code>str</code>)         \u2013 <p>A Git reference such as a commit, tag or branch.</p> </li> <li> repo             (<code>str | Path</code>)         \u2013 <p>Path to the repository (i.e. the directory containing the <code>.git</code> directory)</p> </li> <li> submodules             (<code>bool</code>)         \u2013 <p>Whether to recurse on the submodules.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into (relative to the repository root).</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/git.py</code> <pre><code>def load_git(\n    module: str | Path,\n    *,\n    ref: str = \"HEAD\",\n    repo: str | Path = \".\",\n    submodules: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module from a specific Git reference.\n\n    This function will create a temporary\n    [git worktree](https://git-scm.com/docs/git-worktree) at the requested reference\n    before loading `module` with [`griffe.load`][griffe.loader.load].\n\n    This function requires that the `git` executable is installed.\n\n    Parameters:\n        module: The module path, relative to the repository root.\n        ref: A Git reference such as a commit, tag or branch.\n        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)\n        submodules: Whether to recurse on the submodules.\n        extensions: The extensions to use.\n        search_paths: The paths to search into (relative to the repository root).\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    with tmp_worktree(repo, ref) as worktree:\n        search_paths = [worktree / path for path in search_paths or [\".\"]]\n        if isinstance(module, Path):\n            module = worktree / module\n        return loader.load(\n            module=module,\n            submodules=submodules,\n            try_relative_path=False,\n            extensions=extensions,\n            search_paths=search_paths,\n            docstring_parser=docstring_parser,\n            docstring_options=docstring_options,\n            lines_collection=lines_collection,\n            modules_collection=modules_collection,\n            allow_inspection=allow_inspection,\n        )\n</code></pre>"},{"location":"reference/griffe/git/#griffe.git.tmp_worktree","title":"tmp_worktree","text":"<pre><code>tmp_worktree(repo='.', ref='HEAD')\n</code></pre> <p>Context manager that checks out the given reference in the given repository to a temporary worktree.</p> <p>Parameters:</p> <ul> <li> repo             (<code>str | Path</code>)         \u2013 <p>Path to the repository (i.e. the directory containing the <code>.git</code> directory)</p> </li> <li> ref             (<code>str</code>)         \u2013 <p>A Git reference such as a commit, tag or branch.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Iterator[Path]</code>         \u2013 <p>The path to the temporary worktree.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>OSError</code>           \u2013         <p>If <code>repo</code> is not a valid <code>.git</code> repository</p> </li> <li> <code>RuntimeError</code>           \u2013         <p>If the <code>git</code> executable is unavailable, or if it cannot create a worktree</p> </li> </ul> Source code in <code>src/griffe/git.py</code> <pre><code>@contextmanager\ndef tmp_worktree(repo: str | Path = \".\", ref: str = \"HEAD\") -&gt; Iterator[Path]:\n\"\"\"Context manager that checks out the given reference in the given repository to a temporary worktree.\n\n    Parameters:\n        repo: Path to the repository (i.e. the directory *containing* the `.git` directory)\n        ref: A Git reference such as a commit, tag or branch.\n\n    Yields:\n        The path to the temporary worktree.\n\n    Raises:\n        OSError: If `repo` is not a valid `.git` repository\n        RuntimeError: If the `git` executable is unavailable, or if it cannot create a worktree\n    \"\"\"\n    repo = str(repo)\n    _assert_git_repo(repo)\n    with TemporaryDirectory(prefix=\"griffe-worktree-\") as td:\n        uid = f\"griffe_{ref}\"\n        target = os.path.join(td, uid)\n        retval = subprocess.run(\n            [\"git\", \"-C\", repo, \"worktree\", \"add\", \"-b\", uid, target, ref],\n            capture_output=True,\n        )\n        if retval.returncode:\n            raise RuntimeError(f\"Could not create git worktree: {retval.stderr.decode()}\")\n\n        try:\n            yield Path(target)\n        finally:\n            subprocess.run([\"git\", \"-C\", repo, \"worktree\", \"remove\", uid], stdout=subprocess.DEVNULL)\n            subprocess.run([\"git\", \"-C\", repo, \"worktree\", \"prune\"], stdout=subprocess.DEVNULL)\n            subprocess.run([\"git\", \"-C\", repo, \"branch\", \"-d\", uid], stdout=subprocess.DEVNULL)\n</code></pre>"},{"location":"reference/griffe/importer/","title":"importer","text":"<p>This module contains utilities to dynamically import objects.</p>"},{"location":"reference/griffe/importer/#griffe.importer.dynamic_import","title":"dynamic_import","text":"<pre><code>dynamic_import(import_path, import_paths=None)\n</code></pre> <p>Dynamically import the specified object.</p> <p>It can be a module, class, method, function, attribute, nested arbitrarily.</p> <p>Parameters:</p> <ul> <li> import_path             (<code>str</code>)         \u2013 <p>The path of the object to import.</p> </li> <li> import_paths             (<code>list[Path] | None</code>)         \u2013 <p>The paths to import the object from.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ModuleNotFoundError</code>           \u2013         <p>When the object's module could not be found.</p> </li> <li> <code>ImportError</code>           \u2013         <p>When there was an import error or when couldn't get the attribute.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>         \u2013 <p>The imported object.</p> </li> </ul> Source code in <code>src/griffe/importer.py</code> <pre><code>def dynamic_import(import_path: str, import_paths: list[Path] | None = None) -&gt; Any:\n\"\"\"Dynamically import the specified object.\n\n    It can be a module, class, method, function, attribute,\n    nested arbitrarily.\n\n    Parameters:\n        import_path: The path of the object to import.\n        import_paths: The paths to import the object from.\n\n    Raises:\n        ModuleNotFoundError: When the object's module could not be found.\n        ImportError: When there was an import error or when couldn't get the attribute.\n\n    Returns:\n        The imported object.\n    \"\"\"\n    module_parts: list[str] = import_path.split(\".\")\n    object_parts: list[str] = []\n    errors = []\n\n    with sys_path(*(import_paths or ())):\n        while True:\n            module_path = \".\".join(module_parts)\n            try:\n                module = import_module(module_path)\n            except ModuleNotFoundError as error:\n                if len(module_parts) == 1:\n                    raise\n                errors.append(str(error))\n                object_parts.insert(0, module_parts.pop(-1))\n            else:\n                break\n\n    # Sometimes extra dependencies are not installed,\n    # and therefore we aren't able to import the leaf module,\n    # so we end up with its parent instead, on which we can't\n    # get the attribute either. In that case we re-raise an\n    # ImportError for consistency.\n    # See https://github.com/mkdocstrings/mkdocstrings/issues/380\n\n    value = module\n    for part in object_parts:\n        try:\n            value = getattr(value, part)\n        except AttributeError as error:\n            raise ImportError(\"\\n\".join(errors)) from error\n    return value\n</code></pre>"},{"location":"reference/griffe/importer/#griffe.importer.sys_path","title":"sys_path","text":"<pre><code>sys_path(*paths)\n</code></pre> <p>Redefine <code>sys.path</code> temporarily.</p> <p>Parameters:</p> <ul> <li> *paths             (<code>str | Path</code>)         \u2013 <p>The paths to use when importing modules. If no paths are given, keep <code>sys.path</code> untouched.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>Iterator[None]</code>         \u2013 <p>Nothing.</p> </li> </ul> Source code in <code>src/griffe/importer.py</code> <pre><code>@contextmanager\ndef sys_path(*paths: str | Path) -&gt; Iterator[None]:\n\"\"\"Redefine `sys.path` temporarily.\n\n    Parameters:\n        *paths: The paths to use when importing modules.\n            If no paths are given, keep `sys.path` untouched.\n\n    Yields:\n        Nothing.\n    \"\"\"\n    if not paths:\n        yield\n        return\n    old_path = sys.path\n    sys.path = [str(path) for path in paths]\n    try:\n        yield\n    finally:\n        sys.path = old_path\n</code></pre>"},{"location":"reference/griffe/loader/","title":"loader","text":"<p>This module contains the code allowing to load modules data.</p> <p>This is the entrypoint to use griffe programatically:</p> <pre><code>from griffe.loader import GriffeLoader\n\ngriffe = GriffeLoader()\nfastapi = griffe.load_module(\"fastapi\")\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader","title":"GriffeLoader","text":"<pre><code>GriffeLoader(\n    *,\n    extensions=None,\n    search_paths=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n    allow_inspection=True\n)\n</code></pre> <p>The Griffe loader, allowing to load data from modules.</p> <p>Parameters:</p> <ul> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def __init__(\n    self,\n    *,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; None:\n\"\"\"Initialize the loader.\n\n    Parameters:\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n    \"\"\"\n    self.extensions: Extensions = extensions or Extensions()\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()\n    self.allow_inspection: bool = allow_inspection\n    self.finder: ModuleFinder = ModuleFinder(search_paths)\n    self._time_stats: dict = {\n        \"time_spent_visiting\": 0,\n        \"time_spent_inspecting\": 0,\n    }\n    patch_ast()\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_exports","title":"expand_exports","text":"<pre><code>expand_exports(module, seen=None)\n</code></pre> <p>Expand exports: try to recursively expand all module exports.</p> <p>Parameters:</p> <ul> <li> module             (<code>Module</code>)         \u2013 <p>The module to recurse on.</p> </li> <li> seen             (<code>set | None</code>)         \u2013 <p>Used to avoid infinite recursion.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def expand_exports(self, module: Module, seen: set | None = None) -&gt; None:\n\"\"\"Expand exports: try to recursively expand all module exports.\n\n    Parameters:\n        module: The module to recurse on.\n        seen: Used to avoid infinite recursion.\n    \"\"\"\n    seen = seen or set()\n    seen.add(module.path)\n    if module.exports is None:\n        return\n    expanded = set()\n    for export in module.exports:\n        if isinstance(export, Name):\n            module_path = export.full.rsplit(\".\", 1)[0]  # remove trailing .__all__\n            try:\n                next_module = self.modules_collection[module_path]\n            except KeyError:\n                logger.debug(f\"Cannot expand '{export.full}', try pre-loading corresponding package\")\n                continue\n            if next_module.path not in seen:\n                self.expand_exports(next_module, seen)\n                try:\n                    expanded |= next_module.exports\n                except TypeError:\n                    logger.warning(f\"Unsupported item in {module.path}.__all__: {export} (use strings only)\")\n        else:\n            expanded.add(export)\n    module.exports = expanded\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.expand_wildcards","title":"expand_wildcards","text":"<pre><code>expand_wildcards(obj, *, external=False, seen=None)\n</code></pre> <p>Expand wildcards: try to recursively expand all found wildcards.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object</code>)         \u2013 <p>The object and its members to recurse on.</p> </li> <li> external             (<code>bool</code>)         \u2013 <p>When true, try to load unspecified modules to expand wildcards.</p> </li> <li> seen             (<code>set | None</code>)         \u2013 <p>Used to avoid infinite recursion.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def expand_wildcards(\n    self,\n    obj: Object,\n    *,\n    external: bool = False,\n    seen: set | None = None,\n) -&gt; None:\n\"\"\"Expand wildcards: try to recursively expand all found wildcards.\n\n    Parameters:\n        obj: The object and its members to recurse on.\n        external: When true, try to load unspecified modules to expand wildcards.\n        seen: Used to avoid infinite recursion.\n    \"\"\"\n    expanded = []\n    to_remove = []\n    seen = seen or set()\n    seen.add(obj.path)\n\n    for member in obj.members.values():\n        if member.is_alias and member.wildcard:  # type: ignore[union-attr]  # we know it's an alias\n            package = member.wildcard.split(\".\", 1)[0]  # type: ignore[union-attr]\n            not_loaded = obj.package.path != package and package not in self.modules_collection\n            if not_loaded:\n                if not external:\n                    continue\n                try:\n                    self.load_module(package, try_relative_path=False)\n                except ImportError as error:\n                    logger.debug(f\"Could not expand wildcard import {member.name} in {obj.path}: {error}\")\n                    continue\n            try:\n                target = self.modules_collection[member.target_path]  # type: ignore[union-attr]\n            except KeyError:\n                logger.debug(\n                    f\"Could not expand wildcard import {member.name} in {obj.path}: \"\n                    f\"{cast(Alias, member).target_path} not found in modules collection\",\n                )\n                continue\n            if target.path not in seen:\n                try:\n                    self.expand_wildcards(target, external=external, seen=seen)  # type: ignore[union-attr]\n                except (AliasResolutionError, CyclicAliasError) as error:\n                    logger.debug(f\"Could not expand wildcard import {member.name} in {obj.path}: {error}\")\n                    continue\n            expanded.extend(self._expand_wildcard(member))  # type: ignore[arg-type]\n            to_remove.append(member.name)\n        elif not member.is_alias and member.is_module and member.path not in seen:\n            self.expand_wildcards(member, external=external, seen=seen)  # type: ignore[arg-type]\n\n    for name in to_remove:\n        del obj[name]\n\n    for new_member, alias_lineno, alias_endlineno in expanded:\n        overwrite = False\n        already_present = new_member.name in obj.members\n        self_alias = new_member.is_alias and cast(Alias, new_member).target_path == f\"{obj.path}.{new_member.name}\"\n        if already_present:\n            old_member = obj[new_member.name]\n            old_lineno = old_member.alias_lineno if old_member.is_alias else old_member.lineno\n            overwrite = alias_lineno &gt; (old_lineno or 0)  # type: ignore[operator]\n        if not self_alias and (not already_present or overwrite):\n            alias = Alias(\n                new_member.name,\n                new_member,\n                lineno=alias_lineno,\n                endlineno=alias_endlineno,\n                parent=obj,  # type: ignore[arg-type]\n            )\n            if already_present:\n                prev_member = obj[new_member.name]\n                with suppress(AliasResolutionError, CyclicAliasError):\n                    if prev_member.is_module:\n                        if prev_member.is_alias:\n                            prev_member = prev_member.final_target\n                        if alias.final_target is prev_member:\n                            # alias named after the module it targets:\n                            # skip to avoid cyclic aliases\n                            continue\n            obj[new_member.name] = alias\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.load_module","title":"load_module","text":"<pre><code>load_module(\n    module, *, submodules=True, try_relative_path=True\n)\n</code></pre> <p>Load a module.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>)         \u2013 <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>)         \u2013 <p>Whether to try finding the module as a relative path.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>LoadingError</code>           \u2013         <p>When loading a module failed for various reasons.</p> </li> <li> <code>ModuleNotFoundError</code>           \u2013         <p>When a module was not found and inspection is disallowed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load_module(\n    self,\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n) -&gt; Module:\n\"\"\"Load a module.\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n\n    Raises:\n        LoadingError: When loading a module failed for various reasons.\n        ModuleNotFoundError: When a module was not found and inspection is disallowed.\n\n    Returns:\n        A module.\n    \"\"\"\n    module_name: str\n    if module in _builtin_modules:\n        logger.debug(f\"{module} is a builtin module\")\n        if self.allow_inspection:\n            logger.debug(f\"Inspecting {module}\")\n            module_name = module  # type: ignore[assignment]\n            top_module = self._inspect_module(module)  # type: ignore[arg-type]\n            self.modules_collection[top_module.path] = top_module\n            return self.modules_collection[module_name]  # type: ignore[index]\n        raise LoadingError(\"Cannot load builtin module without inspection\")\n    try:\n        module_name, package = self.finder.find_spec(module, try_relative_path=try_relative_path)\n    except ModuleNotFoundError:\n        logger.debug(f\"Could not find {module}\")\n        if self.allow_inspection:\n            logger.debug(f\"Trying inspection on {module}\")\n            module_name = module  # type: ignore[assignment]\n            top_module = self._inspect_module(module)  # type: ignore[arg-type]\n            self.modules_collection[top_module.path] = top_module\n        else:\n            raise\n    else:\n        logger.debug(f\"Found {module}: loading\")\n        try:\n            top_module = self._load_package(package, submodules=submodules)\n        except LoadingError as error:\n            logger.exception(str(error))  # noqa: TRY401\n            raise\n    return self.modules_collection[module_name]  # type: ignore[index]\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_aliases","title":"resolve_aliases","text":"<pre><code>resolve_aliases(\n    *,\n    implicit=None,\n    external=None,\n    max_iterations=None,\n    only_exported=None,\n    only_known_modules=None\n)\n</code></pre> <p>Resolve aliases.</p> <p>Parameters:</p> <ul> <li> implicit             (<code>bool | None</code>)         \u2013 <p>When false, only try to resolve an alias if it is explicitely exported.</p> </li> <li> external             (<code>bool | None</code>)         \u2013 <p>When false, don't try to load unspecified modules to resolve aliases.</p> </li> <li> max_iterations             (<code>int | None</code>)         \u2013 <p>Maximum number of iterations on the loader modules collection.</p> </li> <li> only_exported             (<code>bool | None</code>)         \u2013 <p>Deprecated. Use the <code>implicit</code> parameter instead (inverting the value).</p> </li> <li> only_known_modules             (<code>bool | None</code>)         \u2013 <p>Deprecated. Use the <code>external</code> parameter instead (inverting the value).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[set[str], int]</code>         \u2013 <p>The unresolved aliases and the number of iterations done.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def resolve_aliases(\n    self,\n    *,\n    implicit: bool | None = None,\n    external: bool | None = None,\n    max_iterations: int | None = None,\n    only_exported: bool | None = None,\n    only_known_modules: bool | None = None,\n) -&gt; tuple[set[str], int]:\n\"\"\"Resolve aliases.\n\n    Parameters:\n        implicit: When false, only try to resolve an alias if it is explicitely exported.\n        external: When false, don't try to load unspecified modules to resolve aliases.\n        max_iterations: Maximum number of iterations on the loader modules collection.\n        only_exported: Deprecated. Use the `implicit` parameter instead (inverting the value).\n        only_known_modules: Deprecated. Use the `external` parameter instead (inverting the value).\n\n    Returns:\n        The unresolved aliases and the number of iterations done.\n    \"\"\"\n    # TODO: remove deprecated params at some point\n    if only_exported is not None and implicit is None:\n        warn(\n            \"Parameter `only_exported` is deprecated, use `implicit` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        implicit = not only_exported\n\n    if only_known_modules is not None and external is None:\n        warn(\n            \"Parameter `only_known_modules` is deprecated, use `external` instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        external = not only_known_modules\n\n    # TODO: set as param defaults once deprecated params are dropped\n    if implicit is None:\n        implicit = False\n    if external is None:\n        external = False\n\n    if max_iterations is None:\n        max_iterations = float(\"inf\")  # type: ignore[assignment]\n    prev_unresolved: set[str] = set()\n    unresolved: set[str] = set(\"0\")  # init to enter loop\n    iteration = 0\n    collection = self.modules_collection.members\n    for exports_module in list(collection.values()):\n        self.expand_exports(exports_module)\n    for wildcards_module in list(collection.values()):\n        self.expand_wildcards(wildcards_module)\n    load_failures: set[str] = set()\n    while unresolved and unresolved != prev_unresolved and iteration &lt; max_iterations:  # type: ignore[operator]\n        prev_unresolved = unresolved - {\"0\"}\n        unresolved = set()\n        resolved: set[str] = set()\n        iteration += 1\n        for module_name in list(collection.keys()):\n            module = collection[module_name]\n            next_resolved, next_unresolved = self.resolve_module_aliases(\n                module,\n                implicit=implicit,\n                external=external,\n                load_failures=load_failures,\n            )\n            resolved |= next_resolved\n            unresolved |= next_unresolved\n        logger.debug(\n            f\"Iteration {iteration} finished, {len(resolved)} aliases resolved, still {len(unresolved)} to go\",\n        )\n    return unresolved, iteration\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.resolve_module_aliases","title":"resolve_module_aliases","text":"<pre><code>resolve_module_aliases(\n    obj,\n    *,\n    implicit=False,\n    external=False,\n    seen=None,\n    load_failures=None\n)\n</code></pre> <p>Follow aliases: try to recursively resolve all found aliases.</p> <p>Parameters:</p> <ul> <li> obj             (<code>Object | Alias</code>)         \u2013 <p>The object and its members to recurse on.</p> </li> <li> implicit             (<code>bool</code>)         \u2013 <p>When false, only try to resolve an alias if it is explicitely exported.</p> </li> <li> external             (<code>bool</code>)         \u2013 <p>When false, don't try to load unspecified modules to resolve aliases.</p> </li> <li> seen             (<code>set[str] | None</code>)         \u2013 <p>Used to avoid infinite recursion.</p> </li> <li> load_failures             (<code>set[str] | None</code>)         \u2013 <p>Set of external packages we failed to load (to prevent retries).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[set[str], set[str]]</code>         \u2013 <p>Both sets of resolved and unresolved aliases.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def resolve_module_aliases(\n    self,\n    obj: Object | Alias,\n    *,\n    implicit: bool = False,\n    external: bool = False,\n    seen: set[str] | None = None,\n    load_failures: set[str] | None = None,\n) -&gt; tuple[set[str], set[str]]:\n\"\"\"Follow aliases: try to recursively resolve all found aliases.\n\n    Parameters:\n        obj: The object and its members to recurse on.\n        implicit: When false, only try to resolve an alias if it is explicitely exported.\n        external: When false, don't try to load unspecified modules to resolve aliases.\n        seen: Used to avoid infinite recursion.\n        load_failures: Set of external packages we failed to load (to prevent retries).\n\n    Returns:\n        Both sets of resolved and unresolved aliases.\n    \"\"\"\n    resolved = set()\n    unresolved = set()\n    if load_failures is None:\n        load_failures = set()\n    seen = seen or set()\n    seen.add(obj.path)\n\n    for member in obj.members.values():\n        if member.is_alias:\n            if member.wildcard or member.resolved:  # type: ignore[union-attr]\n                continue\n            if not implicit and not member.is_explicitely_exported:\n                continue\n            try:\n                member.resolve_target()  # type: ignore[union-attr]\n            except AliasResolutionError as error:\n                target = error.alias.target_path  # type: ignore[union-attr]\n                unresolved.add(member.path)\n                package = target.split(\".\", 1)[0]\n                load_module = (\n                    external\n                    and package not in load_failures\n                    and obj.package.path != package\n                    and package not in self.modules_collection\n                )\n                if load_module:\n                    logger.debug(f\"Failed to resolve alias {member.path} -&gt; {target}\")\n                    try:\n                        self.load_module(package, try_relative_path=False)\n                    except ImportError as error:\n                        logger.debug(f\"Could not follow alias {member.path}: {error}\")\n                        load_failures.add(package)\n            except CyclicAliasError as error:\n                logger.debug(str(error))\n            else:\n                logger.debug(f\"Alias {member.path} was resolved to {member.final_target.path}\")  # type: ignore[union-attr]\n                resolved.add(member.path)\n        elif member.kind in {Kind.MODULE, Kind.CLASS} and member.path not in seen:\n            sub_resolved, sub_unresolved = self.resolve_module_aliases(\n                member,\n                implicit=implicit,\n                external=external,\n                seen=seen,\n                load_failures=load_failures,  # type: ignore[arg-type]\n            )\n            resolved |= sub_resolved\n            unresolved |= sub_unresolved\n\n    return resolved, unresolved\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.GriffeLoader.stats","title":"stats","text":"<pre><code>stats()\n</code></pre> <p>Compute some statistics.</p> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013 <p>Some statistics.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def stats(self) -&gt; dict:\n\"\"\"Compute some statistics.\n\n    Returns:\n        Some statistics.\n    \"\"\"\n    return {**stats(self), **self._time_stats}\n</code></pre>"},{"location":"reference/griffe/loader/#griffe.loader.load","title":"load","text":"<pre><code>load(\n    module,\n    *,\n    submodules=True,\n    try_relative_path=True,\n    extensions=None,\n    search_paths=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n    allow_inspection=True\n)\n</code></pre> <p>Load and return a module.</p> <p>Example: <pre><code>import griffe\n\nmodule = griffe.load(...)\n</code></pre></p> <p>This is a shortcut for:</p> <pre><code>from griffe.loader import GriffeLoader\n\nloader = GriffeLoader(...)\nmodule = loader.load_module(...)\n</code></pre> <p>See the documentation for the loader: <code>GriffeLoader</code>.</p> <p>Parameters:</p> <ul> <li> module             (<code>str | Path</code>)         \u2013 <p>The module name or path.</p> </li> <li> submodules             (<code>bool</code>)         \u2013 <p>Whether to recurse on the submodules.</p> </li> <li> try_relative_path             (<code>bool</code>)         \u2013 <p>Whether to try finding the module as a relative path.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use.</p> </li> <li> search_paths             (<code>Sequence[str | Path] | None</code>)         \u2013 <p>The paths to search into.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> <li> allow_inspection             (<code>bool</code>)         \u2013 <p>Whether to allow inspecting modules when visiting them is not possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A loaded module.</p> </li> </ul> Source code in <code>src/griffe/loader.py</code> <pre><code>def load(\n    module: str | Path,\n    *,\n    submodules: bool = True,\n    try_relative_path: bool = True,\n    extensions: Extensions | None = None,\n    search_paths: Sequence[str | Path] | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n    allow_inspection: bool = True,\n) -&gt; Module:\n\"\"\"Load and return a module.\n\n    Example:\n    ```python\n    import griffe\n\n    module = griffe.load(...)\n    ```\n\n    This is a shortcut for:\n\n    ```python\n    from griffe.loader import GriffeLoader\n\n    loader = GriffeLoader(...)\n    module = loader.load_module(...)\n    ```\n\n    See the documentation for the loader: [`GriffeLoader`][griffe.loader.GriffeLoader].\n\n    Parameters:\n        module: The module name or path.\n        submodules: Whether to recurse on the submodules.\n        try_relative_path: Whether to try finding the module as a relative path.\n        extensions: The extensions to use.\n        search_paths: The paths to search into.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n        allow_inspection: Whether to allow inspecting modules when visiting them is not possible.\n\n    Returns:\n        A loaded module.\n    \"\"\"\n    return GriffeLoader(\n        extensions=extensions,\n        search_paths=search_paths,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n        allow_inspection=allow_inspection,\n    ).load_module(\n        module=module,\n        submodules=submodules,\n        try_relative_path=try_relative_path,\n    )\n</code></pre>"},{"location":"reference/griffe/logger/","title":"logger","text":"<p>This module contains logging utilities.</p> <p>We provide the <code>patch_loggers</code> function so dependant libraries can patch loggers as they see fit.</p> <p>For example, to fit in the MkDocs logging configuration and prefix each log message with the module name:</p> <pre><code>import logging\nfrom griffe.logger import patch_loggers\n\n\nclass LoggerAdapter(logging.LoggerAdapter):\n    def __init__(self, prefix, logger):\n        super().__init__(logger, {})\n        self.prefix = prefix\n\n    def process(self, msg, kwargs):\n        return f\"{self.prefix}: {msg}\", kwargs\n\n\ndef get_logger(name):\n    logger = logging.getLogger(f\"mkdocs.plugins.{name}\")\n    return LoggerAdapter(name, logger)\n\n\npatch_loggers(get_logger)\n</code></pre>"},{"location":"reference/griffe/logger/#griffe.logger.LogLevel","title":"LogLevel","text":"<p>         Bases: <code>Enum</code></p> <p>Enumeration of available log levels.</p>"},{"location":"reference/griffe/logger/#griffe.logger.get_logger","title":"get_logger","text":"<pre><code>get_logger(name)\n</code></pre> <p>Create and return a new logger instance.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The logger name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_Logger</code>         \u2013 <p>The logger.</p> </li> </ul> Source code in <code>src/griffe/logger.py</code> <pre><code>def get_logger(name: str) -&gt; _Logger:\n\"\"\"Create and return a new logger instance.\n\n    Parameters:\n        name: The logger name.\n\n    Returns:\n        The logger.\n    \"\"\"\n    return _Logger(name)\n</code></pre>"},{"location":"reference/griffe/logger/#griffe.logger.patch_loggers","title":"patch_loggers","text":"<pre><code>patch_loggers(get_logger_func)\n</code></pre> <p>Patch loggers.</p> <p>Parameters:</p> <ul> <li> get_logger_func             (<code>Callable[[str], Any]</code>)         \u2013 <p>A function accepting a name as parameter and returning a logger.</p> </li> </ul> Source code in <code>src/griffe/logger.py</code> <pre><code>def patch_loggers(get_logger_func: Callable[[str], Any]) -&gt; None:\n\"\"\"Patch loggers.\n\n    Parameters:\n        get_logger_func: A function accepting a name as parameter and returning a logger.\n    \"\"\"\n    _Logger._patch_loggers(get_logger_func)\n</code></pre>"},{"location":"reference/griffe/merger/","title":"merger","text":"<p>This module contains utilities to merge data together.</p>"},{"location":"reference/griffe/merger/#griffe.merger.merge_stubs","title":"merge_stubs","text":"<pre><code>merge_stubs(mod1, mod2)\n</code></pre> <p>Merge stubs into a module.</p> <p>Parameters:</p> <ul> <li> mod1             (<code>Module</code>)         \u2013 <p>A regular module or stubs module.</p> </li> <li> mod2             (<code>Module</code>)         \u2013 <p>A regular module or stubs module.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013         <p>When both modules are regular modules (no stubs is passed).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>The regular module.</p> </li> </ul> Source code in <code>src/griffe/merger.py</code> <pre><code>def merge_stubs(mod1: Module, mod2: Module) -&gt; Module:\n\"\"\"Merge stubs into a module.\n\n    Parameters:\n        mod1: A regular module or stubs module.\n        mod2: A regular module or stubs module.\n\n    Raises:\n        ValueError: When both modules are regular modules (no stubs is passed).\n\n    Returns:\n        The regular module.\n    \"\"\"\n    logger.debug(f\"Trying to merge {mod1.filepath} and {mod2.filepath}\")\n    if mod1.filepath.suffix == \".pyi\":  # type: ignore[union-attr]\n        stubs = mod1\n        module = mod2\n    elif mod2.filepath.suffix == \".pyi\":  # type: ignore[union-attr]\n        stubs = mod2\n        module = mod1\n    else:\n        raise ValueError(\"cannot merge regular (non-stubs) modules together\")\n    _merge_module_stubs(module, stubs)\n    return module\n</code></pre>"},{"location":"reference/griffe/mixins/","title":"mixins","text":"<p>This module contains some mixins classes about accessing and setting members.</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.DelMembersMixin","title":"DelMembersMixin","text":"<p>This mixin adds a <code>__delitem__</code> method to a class.</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.GetMembersMixin","title":"GetMembersMixin","text":"<p>This mixin adds a <code>__getitem__</code> method to a class.</p> <p>It makes it easier to access members of an object. The method expects a <code>members</code> attribute/property to be available on the instance.</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin","title":"ObjectAliasMixin","text":"<p>A mixin for methods that appear both in objects and aliases, unchanged.</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_explicitely_exported","title":"is_explicitely_exported  <code>property</code>","text":"<pre><code>is_explicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is explicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_implicitely_exported","title":"is_implicitely_exported  <code>property</code>","text":"<pre><code>is_implicitely_exported: bool\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul>"},{"location":"reference/griffe/mixins/#griffe.mixins.ObjectAliasMixin.is_exported","title":"is_exported","text":"<pre><code>is_exported(*, explicitely=True)\n</code></pre> <p>Tell if this object/alias is implicitely exported by its parent.</p> <p>Parameters:</p> <ul> <li> explicitely             (<code>bool</code>)         \u2013 <p>Whether to only return True when <code>__all__</code> is defined.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True or False.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def is_exported(self, *, explicitely: bool = True) -&gt; bool:\n\"\"\"Tell if this object/alias is implicitely exported by its parent.\n\n    Parameters:\n        explicitely: Whether to only return True when `__all__` is defined.\n\n    Returns:\n        True or False.\n    \"\"\"\n    return self.parent.member_is_exported(self, explicitely=explicitely)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin","title":"SerializationMixin","text":"<p>A mixin that adds de/serialization conveniences.</p>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.as_json","title":"as_json","text":"<pre><code>as_json(*, full=False, **kwargs)\n</code></pre> <p>Return this object's data as a JSON string.</p> <p>Parameters:</p> <ul> <li> full             (<code>bool</code>)         \u2013 <p>Whether to return full info, or just base info.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options passed to encoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A string.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>def as_json(self, *, full: bool = False, **kwargs: Any) -&gt; str:\n\"\"\"Return this object's data as a JSON string.\n\n    Parameters:\n        full: Whether to return full info, or just base info.\n        **kwargs: Additional serialization options passed to encoder.\n\n    Returns:\n        A string.\n    \"\"\"\n    from griffe.encoders import JSONEncoder  # avoid circular import\n\n    return json.dumps(self, cls=JSONEncoder, full=full, **kwargs)\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SerializationMixin.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string, **kwargs)\n</code></pre> <p>Create an instance of this class from a JSON string.</p> <p>Parameters:</p> <ul> <li> json_string             (<code>str</code>)         \u2013 <p>JSON to decode into Object.</p> </li> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional options passed to decoder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>_ObjType</code>         \u2013 <p>An Object instance.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013         <p>When the json_string does not represent and object of the class from which this classmethod has been called.</p> </li> </ul> Source code in <code>src/griffe/mixins.py</code> <pre><code>@classmethod\ndef from_json(cls: type[_ObjType], json_string: str, **kwargs: Any) -&gt; _ObjType:\n\"\"\"Create an instance of this class from a JSON string.\n\n    Parameters:\n        json_string: JSON to decode into Object.\n        **kwargs: Additional options passed to decoder.\n\n    Returns:\n        An Object instance.\n\n    Raises:\n        TypeError: When the json_string does not represent and object\n            of the class from which this classmethod has been called.\n    \"\"\"\n    from griffe.encoders import json_decoder  # avoid circular import\n\n    kwargs.setdefault(\"object_hook\", json_decoder)\n    obj = json.loads(json_string, **kwargs)\n    if not isinstance(obj, cls):\n        raise TypeError(f\"provided JSON object is not of type {cls}\")\n    return obj\n</code></pre>"},{"location":"reference/griffe/mixins/#griffe.mixins.SetMembersMixin","title":"SetMembersMixin","text":"<p>         Bases: <code>DelMembersMixin</code></p> <p>This mixin adds a <code>__setitem__</code> method to a class.</p> <p>It makes it easier to set members of an object. The method expects a <code>members</code> attribute/property to be available on the instance. Each time a member is set, its <code>parent</code> attribute is set as well.</p>"},{"location":"reference/griffe/stats/","title":"stats","text":"<p>This module contains utilities to compute loading statistics.</p>"},{"location":"reference/griffe/stats/#griffe.stats.stats","title":"stats","text":"<pre><code>stats(loader)\n</code></pre> <p>Return some loading statistics.</p> <p>Parameters:</p> <ul> <li> loader             (<code>GriffeLoader</code>)         \u2013 <p>The loader to compute stats from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>         \u2013 <p>Some statistics.</p> </li> </ul> Source code in <code>src/griffe/stats.py</code> <pre><code>def stats(loader: GriffeLoader) -&gt; dict:\n\"\"\"Return some loading statistics.\n\n    Parameters:\n        loader: The loader to compute stats from.\n\n    Returns:\n        Some statistics.\n    \"\"\"\n    modules_by_extension = defaultdict(\n        int,\n        {\n            \"\": 0,\n            \".py\": 0,\n            \".pyi\": 0,\n            \".pyc\": 0,\n            \".pyo\": 0,\n            \".pyd\": 0,\n            \".so\": 0,\n        },\n    )\n    top_modules = loader.modules_collection.members.values()\n    for module in top_modules:\n        _sum_extensions(modules_by_extension, module)\n    n_lines = sum(len(lines) for lines in loader.lines_collection.values())\n    return {\n        \"packages\": len(top_modules),\n        \"modules\": len(top_modules) + sum(_n_modules(mod) for mod in top_modules),\n        \"classes\": sum(_n_classes(mod) for mod in top_modules),\n        \"functions\": sum(_n_functions(mod) for mod in top_modules),\n        \"attributes\": sum(_n_attributes(mod) for mod in top_modules),\n        \"modules_by_extension\": modules_by_extension,\n        \"lines\": n_lines,\n    }\n</code></pre>"},{"location":"reference/griffe/agents/","title":"Index","text":"<p>These modules contain the different agents that are able to extract data.</p>"},{"location":"reference/griffe/agents/base/","title":"base","text":"<p>This module contains the base classes for dealing with extensions.</p>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector","title":"BaseInspector","text":"<p>The base class for inspectors.</p>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node)\n</code></pre> <p>Inspect the children of a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect (its children).</p> </li> </ul> Source code in <code>src/griffe/agents/base.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect the children of a node.\n\n    Parameters:\n        node: The node to inspect (its children).\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseInspector.inspect","title":"inspect","text":"<pre><code>inspect(node)\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", self.generic_inspect)(node)\n</code></pre>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor","title":"BaseVisitor","text":"<p>The base class for visitors.</p>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node)\n</code></pre> <p>Visit the children of a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit (its children).</p> </li> </ul> Source code in <code>src/griffe/agents/base.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit the children of a node.\n\n    Parameters:\n        node: The node to visit (its children).\n    \"\"\"\n</code></pre>"},{"location":"reference/griffe/agents/base/#griffe.agents.base.BaseVisitor.visit","title":"visit","text":"<pre><code>visit(node)\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{node.kind}\", self.generic_visit)(node)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/agents/extensions/","title":"extensions","text":"<p>Deprecated. Import from <code>griffe.extensions</code> instead.</p>"},{"location":"reference/griffe/agents/inspector/","title":"inspector","text":"<p>This module defines introspection mechanisms.</p> <p>Sometimes we cannot get the source code of a module or an object, typically built-in modules like <code>itertools</code>. The only way to know what they are made of is to actually import them and inspect their contents.</p> <p>Sometimes, even if the source code is available, loading the object is desired because it was created or modified dynamically, and our node visitor is not powerful enough to infer all these dynamic modifications. In this case, we always try to visit the code first, and only then we load the object to update the data with introspection.</p> <p>This module exposes a public function, <code>inspect()</code>, which inspects the module using <code>inspect.getmembers()</code>, and returns a new <code>Module</code> instance, populating its members recursively, by using a <code>NodeVisitor</code>-like class.</p> <p>The inspection agent works similarly to the regular \"node visitor\" agent, in that it maintains a state with the current object being handled, and recursively handle its members.</p>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector","title":"Inspector","text":"<pre><code>Inspector(\n    module_name,\n    filepath,\n    extensions,\n    parent=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n)\n</code></pre> <p>         Bases: <code>BaseInspector</code></p> <p>This class is used to instantiate an inspector.</p> <p>Inspectors iterate on objects members to extract data from them.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013 <p>The module name.</p> </li> <li> filepath             (<code>Path | None</code>)         \u2013 <p>The optional filepath.</p> </li> <li> extensions             (<code>Extensions</code>)         \u2013 <p>Extensions to use when inspecting.</p> </li> <li> parent             (<code>Module | None</code>)         \u2013 <p>The module parent.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>The docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def __init__(\n    self,\n    module_name: str,\n    filepath: Path | None,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the inspector.\n\n    Parameters:\n        module_name: The module name.\n        filepath: The optional filepath.\n        extensions: Extensions to use when inspecting.\n        parent: The module parent.\n        docstring_parser: The docstring parser to use.\n        docstring_options: The docstring parsing options.\n        lines_collection: A collection of source code lines.\n    \"\"\"\n    super().__init__()\n    self.module_name: str = module_name\n    self.filepath: Path | None = filepath\n    self.extensions: Extensions = extensions.attach_inspector(self)\n    self.parent: Module | None = parent\n    self.current: Module | Class = None  # type: ignore[assignment]\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.generic_inspect","title":"generic_inspect","text":"<pre><code>generic_inspect(node)\n</code></pre> <p>Extend the base generic inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def generic_inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base generic inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for before_inspector in self.extensions.before_children_inspection:\n        before_inspector.inspect(node)\n\n    for child in node.children:\n        child_module_path = _should_create_alias(node, child, self.current.module.path)\n        if child_module_path:\n            if child.kind is ObjectKind.MODULE:\n                target_path = child_module_path\n            else:\n                child_name = getattr(child.obj, \"__name__\", child.name)\n                target_path = f\"{child_module_path}.{child_name}\"\n            self.current[child.name] = Alias(child.name, target_path)\n        else:\n            self.inspect(child)\n\n    for after_inspector in self.extensions.after_children_inspection:\n        after_inspector.inspect(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.get_module","title":"get_module","text":"<pre><code>get_module(import_paths=None)\n</code></pre> <p>Build and return the object representing the module attached to this inspector.</p> <p>This method triggers a complete inspection of the module members.</p> <p>Parameters:</p> <ul> <li> import_paths             (<code>list[Path] | None</code>)         \u2013 <p>Paths replacing <code>sys.path</code> to import the module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A module instance.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def get_module(self, import_paths: list[Path] | None = None) -&gt; Module:\n\"\"\"Build and return the object representing the module attached to this inspector.\n\n    This method triggers a complete inspection of the module members.\n\n    Parameters:\n        import_paths: Paths replacing `sys.path` to import the module.\n\n    Returns:\n        A module instance.\n    \"\"\"\n    import_path = self.module_name\n    if self.parent is not None:\n        import_path = f\"{self.parent.path}.{import_path}\"\n    value = dynamic_import(import_path, import_paths)\n    top_node = ObjectNode(value, self.module_name)\n    self.inspect(top_node)\n    return self.current.module\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_attribute","title":"handle_attribute","text":"<pre><code>handle_attribute(node, annotation=None)\n</code></pre> <p>Handle an attribute.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>A potentiel annotation.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def handle_attribute(self, node: ObjectNode, annotation: str | Name | Expression | None = None) -&gt; None:\n\"\"\"Handle an attribute.\n\n    Parameters:\n        node: The node to inspect.\n        annotation: A potentiel annotation.\n    \"\"\"\n    # TODO: to improve\n    parent = self.current\n    labels: set[str] = set()\n\n    if parent.kind is ObjectKind.MODULE:\n        labels.add(\"module\")\n    elif parent.kind is ObjectKind.CLASS:\n        labels.add(\"class\")\n    elif parent.kind is ObjectKind.FUNCTION:\n        if parent.name != \"__init__\":\n            return\n        parent = parent.parent\n        labels.add(\"instance\")\n\n    try:\n        value = repr(node.obj)\n    except Exception:  # noqa: BLE001\n        value = None\n    try:\n        docstring = self._get_docstring(node)\n    except Exception:  # noqa: BLE001\n        docstring = None\n\n    attribute = Attribute(\n        name=node.name,\n        value=value,\n        annotation=annotation,\n        docstring=docstring,\n    )\n    attribute.labels |= labels\n    parent[node.name] = attribute\n\n    if node.name == \"__all__\":\n        parent.exports = set(node.obj)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.handle_function","title":"handle_function","text":"<pre><code>handle_function(node, labels=None)\n</code></pre> <p>Handle a function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> <li> labels             (<code>set | None</code>)         \u2013 <p>Labels to add to the data object.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def handle_function(self, node: ObjectNode, labels: set | None = None) -&gt; None:\n\"\"\"Handle a function.\n\n    Parameters:\n        node: The node to inspect.\n        labels: Labels to add to the data object.\n    \"\"\"\n    try:\n        signature = getsignature(node.obj)\n    except Exception:  # noqa: BLE001\n        # so many exceptions can be raised here:\n        # AttributeError, NameError, RuntimeError, ValueError, TokenError, TypeError\n        parameters = None\n        returns = None\n    else:\n        parameters = Parameters(\n            *[_convert_parameter(parameter, parent=self.current) for parameter in signature.parameters.values()],\n        )\n        return_annotation = signature.return_annotation\n        returns = (\n            None\n            if return_annotation is empty\n            else _convert_object_to_annotation(return_annotation, parent=self.current)\n        )\n\n    obj: Attribute | Function\n    labels = labels or set()\n    if \"property\" in labels:\n        obj = Attribute(\n            name=node.name,\n            value=None,\n            annotation=returns,\n            docstring=self._get_docstring(node),\n        )\n    else:\n        obj = Function(\n            name=node.name,\n            parameters=parameters,\n            returns=returns,\n            docstring=self._get_docstring(node),\n        )\n    obj.labels |= labels\n    self.current[node.name] = obj\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect","title":"inspect","text":"<pre><code>inspect(node)\n</code></pre> <p>Extend the base inspection with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Extend the base inspection with extensions.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    for before_inspector in self.extensions.before_inspection:\n        before_inspector.inspect(node)\n    super().inspect(node)\n    for after_inspector in self.extensions.after_inspection:\n        after_inspector.inspect(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_attribute","title":"inspect_attribute","text":"<pre><code>inspect_attribute(node)\n</code></pre> <p>Inspect an attribute.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_attribute(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect an attribute.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_attribute(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_function","title":"inspect_builtin_function","text":"<pre><code>inspect_builtin_function(node)\n</code></pre> <p>Inspect a builtin function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_builtin_function(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a builtin function.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"builtin\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_builtin_method","title":"inspect_builtin_method","text":"<pre><code>inspect_builtin_method(node)\n</code></pre> <p>Inspect a builtin method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_builtin_method(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a builtin method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"builtin\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_cached_property","title":"inspect_cached_property","text":"<pre><code>inspect_cached_property(node)\n</code></pre> <p>Inspect a cached property.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_cached_property(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a cached property.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    node.obj = node.obj.func\n    self.handle_function(node, {\"cached\", \"property\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_class","title":"inspect_class","text":"<pre><code>inspect_class(node)\n</code></pre> <p>Inspect a class.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_class(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a class.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    bases = [base.__name__ for base in node.obj.__bases__ if base is not object]\n\n    class_ = Class(\n        name=node.name,\n        docstring=self._get_docstring(node),\n        bases=bases,\n    )\n    self.current[node.name] = class_\n    self.current = class_\n    self.generic_inspect(node)\n    self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_classmethod","title":"inspect_classmethod","text":"<pre><code>inspect_classmethod(node)\n</code></pre> <p>Inspect a class method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_classmethod(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a class method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"classmethod\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_coroutine","title":"inspect_coroutine","text":"<pre><code>inspect_coroutine(node)\n</code></pre> <p>Inspect a coroutine.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_coroutine(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a coroutine.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"async\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_function","title":"inspect_function","text":"<pre><code>inspect_function(node)\n</code></pre> <p>Inspect a function.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_function(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a function.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method","title":"inspect_method","text":"<pre><code>inspect_method(node)\n</code></pre> <p>Inspect a method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_method(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_method_descriptor","title":"inspect_method_descriptor","text":"<pre><code>inspect_method_descriptor(node)\n</code></pre> <p>Inspect a method descriptor.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_method_descriptor(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a method descriptor.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"method descriptor\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_module","title":"inspect_module","text":"<pre><code>inspect_module(node)\n</code></pre> <p>Inspect a module.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_module(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a module.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.current = Module(\n        name=self.module_name,\n        filepath=self.filepath,\n        parent=self.parent,\n        docstring=self._get_docstring(node),\n        lines_collection=self.lines_collection,\n    )\n    self.generic_inspect(node)\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_property","title":"inspect_property","text":"<pre><code>inspect_property(node)\n</code></pre> <p>Inspect a property.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_property(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a property.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"property\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.Inspector.inspect_staticmethod","title":"inspect_staticmethod","text":"<pre><code>inspect_staticmethod(node)\n</code></pre> <p>Inspect a static method.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect_staticmethod(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a static method.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    self.handle_function(node, {\"staticmethod\"})\n</code></pre>"},{"location":"reference/griffe/agents/inspector/#griffe.agents.inspector.inspect","title":"inspect","text":"<pre><code>inspect(\n    module_name,\n    *,\n    filepath=None,\n    import_paths=None,\n    extensions=None,\n    parent=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None\n)\n</code></pre> <p>Inspect a module.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013 <p>The module name (as when importing [from] it).</p> </li> <li> filepath             (<code>Path | None</code>)         \u2013 <p>The module file path.</p> </li> <li> import_paths             (<code>list[Path] | None</code>)         \u2013 <p>Paths to import the module from.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use when inspecting the module.</p> </li> <li> parent             (<code>Module | None</code>)         \u2013 <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>The module, with its members populated.</p> </li> </ul> Source code in <code>src/griffe/agents/inspector.py</code> <pre><code>def inspect(\n    module_name: str,\n    *,\n    filepath: Path | None = None,\n    import_paths: list[Path] | None = None,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n) -&gt; Module:\n\"\"\"Inspect a module.\n\n    Parameters:\n        module_name: The module name (as when importing [from] it).\n        filepath: The module file path.\n        import_paths: Paths to import the module from.\n        extensions: The extensions to use when inspecting the module.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n\n    Returns:\n        The module, with its members populated.\n    \"\"\"\n    if not import_paths and filepath:\n        import_paths = [filepath.parent]\n    return Inspector(\n        module_name,\n        filepath,\n        extensions or Extensions(),\n        parent,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n    ).get_module(import_paths)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/","title":"nodes","text":"<p>This module contains utilities for extracting information from nodes.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode","title":"ASTNode","text":"<p>This class is dynamically added to the bases of each AST node class.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.children","title":"children  <code>cached</code> <code>property</code>","text":"<pre><code>children: Sequence[ASTNode]\n</code></pre> <p>Build and return the children of this node.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ASTNode]</code>         \u2013 <p>A list of children.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.first_child","title":"first_child  <code>cached</code> <code>property</code>","text":"<pre><code>first_child: ASTNode\n</code></pre> <p>Return the first child of this node.</p> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013         <p>When the node does not have children.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ASTNode</code>         \u2013 <p>The child.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.kind","title":"kind  <code>cached</code> <code>property</code>","text":"<pre><code>kind: str\n</code></pre> <p>Return the kind of this node.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The node kind.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.last_child","title":"last_child  <code>cached</code> <code>property</code>","text":"<pre><code>last_child: ASTNode\n</code></pre> <p>Return the lasts child of this node.</p> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013         <p>When the node does not have children.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ASTNode</code>         \u2013 <p>The child.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next","title":"next  <code>cached</code> <code>property</code>","text":"<pre><code>next: ASTNode\n</code></pre> <p>Return the next sibling of this node.</p> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013         <p>When the node does not have next siblings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ASTNode</code>         \u2013 <p>The sibling.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.next_siblings","title":"next_siblings  <code>cached</code> <code>property</code>","text":"<pre><code>next_siblings: Sequence[ASTNode]\n</code></pre> <p>Return the next siblings of this node, starting from the closest.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ASTNode]</code>         \u2013 <p>The next siblings.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.position","title":"position  <code>cached</code> <code>property</code>","text":"<pre><code>position: int\n</code></pre> <p>Tell the position of this node amongst its siblings.</p> <p>Raises:</p> <ul> <li> <code>RootNodeError</code>           \u2013         <p>When the node doesn't have a parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>         \u2013 <p>The node position amongst its siblings.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous","title":"previous  <code>cached</code> <code>property</code>","text":"<pre><code>previous: ASTNode\n</code></pre> <p>Return the previous sibling of this node.</p> <p>Raises:</p> <ul> <li> <code>LastNodeError</code>           \u2013         <p>When the node does not have previous siblings.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ASTNode</code>         \u2013 <p>The sibling.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.previous_siblings","title":"previous_siblings  <code>cached</code> <code>property</code>","text":"<pre><code>previous_siblings: Sequence[ASTNode]\n</code></pre> <p>Return the previous siblings of this node, starting from the closest.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ASTNode]</code>         \u2013 <p>The previous siblings.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ASTNode.siblings","title":"siblings  <code>cached</code> <code>property</code>","text":"<pre><code>siblings: Sequence[ASTNode]\n</code></pre> <p>Return the siblings of this node.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ASTNode]</code>         \u2013 <p>The siblings.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectKind","title":"ObjectKind","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enumeration for the different kinds of objects.</p>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode","title":"ObjectNode","text":"<pre><code>ObjectNode(obj, name, parent=None)\n</code></pre> <p>Helper class to represent an object tree.</p> <p>It's not really a tree but more a backward-linked list: each node has a reference to its parent, but not to its child (for simplicity purposes and to avoid bugs).</p> <p>Each node stores an object, its name, and a reference to its parent node.</p> <p>Attributes:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>The actual Python object.</p> </li> <li> name             (<code>str</code>)         \u2013 <p>The Python object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>)         \u2013 <p>The parent node.</p> </li> </ul> <p>Parameters:</p> <ul> <li> obj             (<code>Any</code>)         \u2013 <p>A Python object.</p> </li> <li> name             (<code>str</code>)         \u2013 <p>The object's name.</p> </li> <li> parent             (<code>ObjectNode | None</code>)         \u2013 <p>The object's parent node.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None) -&gt; None:\n\"\"\"Initialize the object.\n\n    Arguments:\n        obj: A Python object.\n        name: The object's name.\n        parent: The object's parent node.\n    \"\"\"\n    try:\n        obj = inspect.unwrap(obj)\n    except Exception as error:  # noqa: BLE001\n        # inspect.unwrap at some point runs hasattr(obj, \"__wrapped__\"),\n        # which triggers the __getattr__ method of the object, which in\n        # turn can raise various exceptions. Probably not just __getattr__.\n        # See https://github.com/pawamoy/pytkdocs/issues/45\n        logger.debug(f\"Could not unwrap {name}: {error!r}\")\n\n    self.obj: Any = obj\n    self.name: str = name\n    self.parent: ObjectNode | None = parent\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.children","title":"children  <code>cached</code> <code>property</code>","text":"<pre><code>children: Sequence[ObjectNode]\n</code></pre> <p>Build and return the children of this node.</p> <p>Returns:</p> <ul> <li> <code>Sequence[ObjectNode]</code>         \u2013 <p>A list of children.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_function","title":"is_builtin_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_function: bool\n</code></pre> <p>Tell if this node's object is a builtin function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a builtin function.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_builtin_method","title":"is_builtin_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_builtin_method: bool\n</code></pre> <p>Tell if this node's object is a builtin method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a builtin method.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_cached_property","title":"is_cached_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_cached_property: bool\n</code></pre> <p>Tell if this node's object is a cached property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a cached property.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_class","title":"is_class  <code>cached</code> <code>property</code>","text":"<pre><code>is_class: bool\n</code></pre> <p>Tell if this node's object is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a class.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_classmethod","title":"is_classmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_classmethod: bool\n</code></pre> <p>Tell if this node's object is a classmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a classmethod.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_coroutine","title":"is_coroutine  <code>cached</code> <code>property</code>","text":"<pre><code>is_coroutine: bool\n</code></pre> <p>Tell if this node's object is a coroutine.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a coroutine.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_function","title":"is_function  <code>cached</code> <code>property</code>","text":"<pre><code>is_function: bool\n</code></pre> <p>Tell if this node's object is a function.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a function.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method","title":"is_method  <code>cached</code> <code>property</code>","text":"<pre><code>is_method: bool\n</code></pre> <p>Tell if this node's object is a method.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a method.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_method_descriptor","title":"is_method_descriptor  <code>cached</code> <code>property</code>","text":"<pre><code>is_method_descriptor: bool\n</code></pre> <p>Tell if this node's object is a method descriptor.</p> <p>Built-in methods (e.g. those implemented in C/Rust) are often method descriptors, rather than normal methods.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a method descriptor.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_module","title":"is_module  <code>cached</code> <code>property</code>","text":"<pre><code>is_module: bool\n</code></pre> <p>Tell if this node's object is a module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>The root of the tree.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_property","title":"is_property  <code>cached</code> <code>property</code>","text":"<pre><code>is_property: bool\n</code></pre> <p>Tell if this node's object is a property.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a property.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.is_staticmethod","title":"is_staticmethod  <code>cached</code> <code>property</code>","text":"<pre><code>is_staticmethod: bool\n</code></pre> <p>Tell if this node's object is a staticmethod.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If this node's object is a staticmethod.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.kind","title":"kind  <code>cached</code> <code>property</code>","text":"<pre><code>kind: ObjectKind\n</code></pre> <p>Return the kind of this node.</p> <p>Returns:</p> <ul> <li> <code>ObjectKind</code>         \u2013 <p>The node kind.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.ObjectNode.parent_is_class","title":"parent_is_class  <code>cached</code> <code>property</code>","text":"<pre><code>parent_is_class: bool\n</code></pre> <p>Tell if the object of this node's parent is a class.</p> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>If the object of this node's parent is a class.</p> </li> </ul>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_annotation","title":"get_annotation","text":"<pre><code>get_annotation(node, parent)\n</code></pre> <p>Extract a resolvable annotation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013 <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013 <p>The parent used to resolve the name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Name | Expression | None</code>         \u2013 <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_annotation(node: AST | None, parent: Module | Class) -&gt; str | Name | Expression | None:\n\"\"\"Extract a resolvable annotation.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    if node is None:\n        return None\n    return _get_annotation(node, parent)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_docstring","title":"get_docstring","text":"<pre><code>get_docstring(node, *, strict=False)\n</code></pre> <p>Extract a docstring.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013 <p>The node to extract the docstring from.</p> </li> <li> strict             (<code>bool</code>)         \u2013 <p>Whether to skip searching the body (functions).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str | None, int | None, int | None]</code>         \u2013 <p>A tuple with the value and line numbers of the docstring.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_docstring(\n    node: AST,\n    *,\n    strict: bool = False,\n) -&gt; tuple[str | None, int | None, int | None]:\n\"\"\"Extract a docstring.\n\n    Parameters:\n        node: The node to extract the docstring from.\n        strict: Whether to skip searching the body (functions).\n\n    Returns:\n        A tuple with the value and line numbers of the docstring.\n    \"\"\"\n    # TODO: possible optimization using a type map\n    if isinstance(node, NodeExpr):\n        doc = node.value\n    elif node.body and isinstance(node.body[0], NodeExpr) and not strict:  # type: ignore[attr-defined]\n        doc = node.body[0].value  # type: ignore[attr-defined]\n    else:\n        return None, None, None\n    if isinstance(doc, NodeConstant) and isinstance(doc.value, str):\n        return doc.value, doc.lineno, doc.end_lineno  # type: ignore[attr-defined]\n    if isinstance(doc, NodeStr):\n        # TODO: remove once Python 3.7 support is dropped\n        # on Python 3.7, lineno seems to be the ending line of the string\n        # rather than the starting one, so we substract the number of newlines\n        lineno = doc.lineno\n        if sys.version_info &lt; (3, 8):\n            lineno -= doc.s.count(\"\\n\")\n\n        return doc.s, lineno, doc.end_lineno  # type: ignore[attr-defined]\n    return None, None, None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_instance_names","title":"get_instance_names","text":"<pre><code>get_instance_names(node)\n</code></pre> <p>Extract names from an assignment node, only for instance attributes.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013 <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013 <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_instance_names(node: AST) -&gt; list[str]:\n\"\"\"Extract names from an assignment node, only for instance attributes.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return [name.split(\".\", 1)[1] for name in get_names(node) if name.startswith(\"self.\")]\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_name","title":"get_name","text":"<pre><code>get_name(node)\n</code></pre> <p>Extract name from an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013 <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_name(node: AST) -&gt; str:\n\"\"\"Extract name from an assignment node.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return _node_name_map[type(node)](node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_names","title":"get_names","text":"<pre><code>get_names(node)\n</code></pre> <p>Extract names from an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST</code>)         \u2013 <p>The node to extract names from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>         \u2013 <p>A list of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_names(node: AST) -&gt; list[str]:\n\"\"\"Extract names from an assignment node.\n\n    Parameters:\n        node: The node to extract names from.\n\n    Returns:\n        A list of names.\n    \"\"\"\n    return _node_names_map[type(node)](node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_parameter_default","title":"get_parameter_default","text":"<pre><code>get_parameter_default(node, filepath, lines_collection)\n</code></pre> <p>Extract the default value of a function parameter.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013 <p>The node to extract the default value from.</p> </li> <li> filepath             (<code>Path</code>)         \u2013 <p>The filepath in which the parameter is written. It allows to retrieve the actual code directly from the lines collection.</p> </li> <li> lines_collection             (<code>LinesCollection</code>)         \u2013 <p>A collection of source code lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013 <p>The default value as a string.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_parameter_default(node: AST | None, filepath: Path, lines_collection: LinesCollection) -&gt; str | None:\n\"\"\"Extract the default value of a function parameter.\n\n    Parameters:\n        node: The node to extract the default value from.\n        filepath: The filepath in which the parameter is written.\n            It allows to retrieve the actual code directly from the lines collection.\n        lines_collection: A collection of source code lines.\n\n    Returns:\n        The default value as a string.\n    \"\"\"\n    if node is None:\n        return None\n    with suppress(KeyError):\n        return _get_value(node)\n    if node.lineno == node.end_lineno:  # type: ignore[attr-defined]\n        return lines_collection[filepath][node.lineno - 1][node.col_offset : node.end_col_offset]  # type: ignore[attr-defined]\n    # TODO: handle multiple line defaults\n    return None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.get_value","title":"get_value","text":"<pre><code>get_value(node)\n</code></pre> <p>Unparse a node to its string representation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013 <p>The node to unparse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013 <p>The unparsed code of the node.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def get_value(node: AST | None) -&gt; str | None:\n\"\"\"Unparse a node to its string representation.\n\n    Parameters:\n        node: The node to unparse.\n\n    Returns:\n        The unparsed code of the node.\n    \"\"\"\n    if node is None:\n        return None\n    return _node_value_map[type(node)](node)\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.parse__all__","title":"parse__all__","text":"<pre><code>parse__all__(node, parent)\n</code></pre> <p>Get the values declared in <code>__all__</code>.</p> <p>Parameters:</p> <ul> <li> node             (<code>NodeAssign | NodeAugAssign</code>)         \u2013 <p>The assignment node.</p> </li> <li> parent             (<code>Module</code>)         \u2013 <p>The parent module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str | Name]</code>         \u2013 <p>A set of names.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def parse__all__(node: NodeAssign | NodeAugAssign, parent: Module) -&gt; list[str | Name]:\n\"\"\"Get the values declared in `__all__`.\n\n    Parameters:\n        node: The assignment node.\n        parent: The parent module.\n\n    Returns:\n        A set of names.\n    \"\"\"\n    try:\n        return _parse__all__(node.value, parent)\n    except KeyError as error:\n        logger.debug(f\"Cannot parse __all__ assignment: {get_value(node.value)} ({error})\")\n        return []\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.relative_to_absolute","title":"relative_to_absolute","text":"<pre><code>relative_to_absolute(node, name, current_module)\n</code></pre> <p>Convert a relative import path to an absolute one.</p> <p>Parameters:</p> <ul> <li> node             (<code>NodeImportFrom</code>)         \u2013 <p>The \"from ... import ...\" AST node.</p> </li> <li> name             (<code>NodeAlias</code>)         \u2013 <p>The imported name.</p> </li> <li> current_module             (<code>Module</code>)         \u2013 <p>The module in which the import happens.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The absolute import path.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def relative_to_absolute(node: NodeImportFrom, name: NodeAlias, current_module: Module) -&gt; str:\n\"\"\"Convert a relative import path to an absolute one.\n\n    Parameters:\n        node: The \"from ... import ...\" AST node.\n        name: The imported name.\n        current_module: The module in which the import happens.\n\n    Returns:\n        The absolute import path.\n    \"\"\"\n    level = node.level\n    if level &gt; 0 and current_module.is_package or current_module.is_subpackage:\n        level -= 1\n    while level &gt; 0 and current_module.parent is not None:\n        current_module = current_module.parent  # type: ignore[assignment]\n        level -= 1\n    base = current_module.path + \".\" if node.level &gt; 0 else \"\"\n    node_module = node.module + \".\" if node.module else \"\"\n    return base + node_module + name.name\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_annotation","title":"safe_get_annotation","text":"<pre><code>safe_get_annotation(node, parent, log_level=LogLevel.error)\n</code></pre> <p>Safely (no exception) extract a resolvable annotation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013 <p>The annotation node.</p> </li> <li> parent             (<code>Module | Class</code>)         \u2013 <p>The parent used to resolve the name.</p> </li> <li> log_level             (<code>LogLevel</code>)         \u2013 <p>Log level to use to log a message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Name | Expression | None</code>         \u2013 <p>A string or resovable name or expression.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def safe_get_annotation(\n    node: AST | None,\n    parent: Module | Class,\n    log_level: LogLevel = LogLevel.error,\n) -&gt; str | Name | Expression | None:\n\"\"\"Safely (no exception) extract a resolvable annotation.\n\n    Parameters:\n        node: The annotation node.\n        parent: The parent used to resolve the name.\n        log_level: Log level to use to log a message.\n\n    Returns:\n        A string or resovable name or expression.\n    \"\"\"\n    try:\n        return get_annotation(node, parent)\n    except Exception as error:  # noqa: BLE001\n        message = f\"Failed to parse annotation from '{node.__class__.__name__}' node\"\n        with suppress(Exception):\n            message += f\" at {parent.relative_filepath}:{node.lineno}\"  # type: ignore[union-attr]\n        if not isinstance(error, KeyError):\n            message += f\": {error}\"\n        getattr(logger, log_level.value)(message)\n        return None\n</code></pre>"},{"location":"reference/griffe/agents/nodes/#griffe.agents.nodes.safe_get_value","title":"safe_get_value","text":"<pre><code>safe_get_value(node, filepath=None)\n</code></pre> <p>Safely (no exception) unparse a node to its string representation.</p> <p>Parameters:</p> <ul> <li> node             (<code>AST | None</code>)         \u2013 <p>The node to unparse.</p> </li> <li> filepath             (<code>str | Path | None</code>)         \u2013 <p>An optional filepath from where the node comes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013 <p>The unparsed code of the node.</p> </li> </ul> Source code in <code>src/griffe/agents/nodes.py</code> <pre><code>def safe_get_value(node: AST | None, filepath: str | Path | None = None) -&gt; str | None:\n\"\"\"Safely (no exception) unparse a node to its string representation.\n\n    Parameters:\n        node: The node to unparse.\n        filepath: An optional filepath from where the node comes.\n\n    Returns:\n        The unparsed code of the node.\n    \"\"\"\n    try:\n        return get_value(node)\n    except Exception as error:\n        message = f\"Failed to unparse node {node}\"\n        if filepath:\n            message += f\" at {filepath}:{node.lineno}\"  # type: ignore[union-attr]\n        message += f\": {error}\"\n        logger.exception(message)\n        return None\n</code></pre>"},{"location":"reference/griffe/agents/visitor/","title":"visitor","text":"<p>Code parsing and data extraction utilies.</p> <p>This module exposes a public function, <code>visit()</code>, which parses the module code using <code>parse()</code>, and returns a new <code>Module</code> instance, populating its members recursively, by using a <code>NodeVisitor</code>-like class.</p>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor","title":"Visitor","text":"<pre><code>Visitor(\n    module_name,\n    filepath,\n    code,\n    extensions,\n    parent=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None,\n)\n</code></pre> <p>         Bases: <code>BaseVisitor</code></p> <p>This class is used to instantiate a visitor.</p> <p>Visitors iterate on AST nodes to extract data from them.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013 <p>The module name.</p> </li> <li> filepath             (<code>Path</code>)         \u2013 <p>The module filepath.</p> </li> <li> code             (<code>str</code>)         \u2013 <p>The module source code.</p> </li> <li> extensions             (<code>Extensions</code>)         \u2013 <p>The extensions to use when visiting.</p> </li> <li> parent             (<code>Module | None</code>)         \u2013 <p>An optional parent for the final module object.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>The docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def __init__(\n    self,\n    module_name: str,\n    filepath: Path,\n    code: str,\n    extensions: Extensions,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; None:\n\"\"\"Initialize the visitor.\n\n    Parameters:\n        module_name: The module name.\n        filepath: The module filepath.\n        code: The module source code.\n        extensions: The extensions to use when visiting.\n        parent: An optional parent for the final module object.\n        docstring_parser: The docstring parser to use.\n        docstring_options: The docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n    \"\"\"\n    super().__init__()\n    self.module_name: str = module_name\n    self.filepath: Path = filepath\n    self.code: str = code\n    self.extensions: Extensions = extensions.attach_visitor(self)\n    self.parent: Module | None = parent\n    self.current: Module | Class = None  # type: ignore[assignment]\n    self.docstring_parser: Parser | None = docstring_parser\n    self.docstring_options: dict[str, Any] = docstring_options or {}\n    self.lines_collection: LinesCollection = lines_collection or LinesCollection()\n    self.modules_collection: ModulesCollection = modules_collection or ModulesCollection()\n    self.type_guarded: bool = False\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.decorators_to_labels","title":"decorators_to_labels","text":"<pre><code>decorators_to_labels(decorators)\n</code></pre> <p>Build and return a set of labels based on decorators.</p> <p>Parameters:</p> <ul> <li> decorators             (<code>list[Decorator]</code>)         \u2013 <p>The decorators to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>set[str]</code>         \u2013 <p>A set of labels.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def decorators_to_labels(self, decorators: list[Decorator]) -&gt; set[str]:\n\"\"\"Build and return a set of labels based on decorators.\n\n    Parameters:\n        decorators: The decorators to check.\n\n    Returns:\n        A set of labels.\n    \"\"\"\n    labels = set()\n    for decorator in decorators:\n        decorator_value = decorator.value.split(\"(\", 1)[0]\n        if decorator_value in builtin_decorators:\n            labels.add(builtin_decorators[decorator_value])\n        else:\n            names = decorator_value.split(\".\")\n            with suppress(NameResolutionError):\n                resolved_first = self.current.resolve(names[0])\n                resolved_name = \".\".join([resolved_first, *names[1:]])\n                if resolved_name in stdlib_decorators:\n                    labels |= stdlib_decorators[resolved_name]\n    return labels\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.generic_visit","title":"generic_visit","text":"<pre><code>generic_visit(node)\n</code></pre> <p>Extend the base generic visit with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def generic_visit(self, node: ast.AST) -&gt; None:\n\"\"\"Extend the base generic visit with extensions.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for before_visitor in self.extensions.before_children_visit:\n        before_visitor.visit(node)\n    for child in node.children:  # type: ignore[attr-defined]\n        self.visit(child)\n    for after_visitor in self.extensions.after_children_visit:\n        after_visitor.visit(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_base_property","title":"get_base_property","text":"<pre><code>get_base_property(decorators)\n</code></pre> <p>Check decorators to return the base property in case of setters and deleters.</p> <p>Parameters:</p> <ul> <li> decorators             (<code>list[Decorator]</code>)         \u2013 <p>The decorators to check.</p> </li> </ul> <p>Returns:</p> <ul> <li> base_property(            <code>Function | None</code> )        \u2013 <p>The property for which the setter/deleted is set.</p> </li> <li> property_function(            <code>str | None</code> )        \u2013 <p>Either <code>\"setter\"</code> or <code>\"deleter\"</code>.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def get_base_property(self, decorators: list[Decorator]) -&gt; tuple[Function | None, str | None]:\n\"\"\"Check decorators to return the base property in case of setters and deleters.\n\n    Parameters:\n        decorators: The decorators to check.\n\n    Returns:\n        base_property: The property for which the setter/deleted is set.\n        property_function: Either `\"setter\"` or `\"deleter\"`.\n    \"\"\"\n    for decorator in decorators:\n        names = decorator.value.split(\".\")\n        with suppress(ValueError):\n            base_name, base_function = names\n            property_setter_or_deleter = (\n                base_function in {\"setter\", \"deleter\"}\n                and base_name in self.current.members\n                and self.current[base_name].has_labels({\"property\"})\n            )\n            if property_setter_or_deleter:\n                return self.current[base_name], base_function\n    return None, None\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.get_module","title":"get_module","text":"<pre><code>get_module()\n</code></pre> <p>Build and return the object representing the module attached to this visitor.</p> <p>This method triggers a complete visit of the module nodes.</p> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>A module instance.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def get_module(self) -&gt; Module:\n\"\"\"Build and return the object representing the module attached to this visitor.\n\n    This method triggers a complete visit of the module nodes.\n\n    Returns:\n        A module instance.\n    \"\"\"\n    # optimization: equivalent to ast.parse, but with optimize=1 to remove assert statements\n    # TODO: with options, could use optimize=2 to remove docstrings\n    top_node = compile(self.code, mode=\"exec\", filename=str(self.filepath), flags=ast.PyCF_ONLY_AST, optimize=1)\n    self.visit(top_node)\n    return self.current.module\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_attribute","title":"handle_attribute","text":"<pre><code>handle_attribute(node, annotation=None)\n</code></pre> <p>Handle an attribute (assignment) node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.Assign | ast.AnnAssign</code>)         \u2013 <p>The node to visit.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>A potential annotation.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def handle_attribute(\n    self,\n    node: ast.Assign | ast.AnnAssign,\n    annotation: str | Name | Expression | None = None,\n) -&gt; None:\n\"\"\"Handle an attribute (assignment) node.\n\n    Parameters:\n        node: The node to visit.\n        annotation: A potential annotation.\n    \"\"\"\n    parent = self.current\n    labels = set()\n\n    if parent.kind is Kind.MODULE:\n        try:\n            names = get_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n        labels.add(\"module-attribute\")\n    elif parent.kind is Kind.CLASS:\n        try:\n            names = get_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n\n        if isinstance(annotation, Expression) and annotation.is_classvar:\n            # explicit classvar: class attribute only\n            annotation = annotation[2]\n            labels.add(\"class-attribute\")\n        elif node.value:\n            # attribute assigned at class-level: available in instances as well\n            labels.add(\"class-attribute\")\n            labels.add(\"instance-attribute\")\n        else:\n            # annotated attribute only: not available at class-level\n            labels.add(\"instance-attribute\")\n\n    elif parent.kind is Kind.FUNCTION:\n        if parent.name != \"__init__\":\n            return\n        try:\n            names = get_instance_names(node)\n        except KeyError:  # unsupported nodes, like subscript\n            return\n        parent = parent.parent  # type: ignore[assignment]\n        labels.add(\"instance-attribute\")\n\n    if not names:\n        return\n\n    value = safe_get_value(node.value, self.filepath)  # type: ignore[arg-type]\n\n    try:\n        docstring = self._get_docstring(node.next, strict=True)  # type: ignore[union-attr]\n    except (LastNodeError, AttributeError):\n        docstring = None\n\n    for name in names:\n        # TODO: handle assigns like x.y = z\n        # we need to resolve x.y and add z in its member\n        if \".\" in name:\n            continue\n\n        if name in parent.members:\n            # assigning multiple times\n            # TODO: might be better to inspect\n            if isinstance(node.parent, (ast.If, ast.ExceptHandler)):  # type: ignore[union-attr]\n                continue  # prefer \"no-exception\" case\n\n            existing_member = parent.members[name]\n            with suppress(AliasResolutionError, CyclicAliasError):\n                labels |= existing_member.labels  # type: ignore[misc]\n                # forward previous docstring and annotation instead of erasing them\n                if existing_member.docstring and not docstring:\n                    docstring = existing_member.docstring\n                with suppress(AttributeError):\n                    if existing_member.annotation and not annotation:  # type: ignore[union-attr]\n                        annotation = existing_member.annotation  # type: ignore[union-attr]\n\n        attribute = Attribute(\n            name=name,\n            value=value,\n            annotation=annotation,\n            lineno=node.lineno,\n            endlineno=node.end_lineno,  # type: ignore[union-attr]\n            docstring=docstring,\n            runtime=not self.type_guarded,\n        )\n        attribute.labels |= labels\n        parent[name] = attribute\n\n        if name == \"__all__\":\n            with suppress(AttributeError):\n                parent.exports = parse__all__(node, self.current)  # type: ignore[assignment,arg-type]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.handle_function","title":"handle_function","text":"<pre><code>handle_function(node, labels=None)\n</code></pre> <p>Handle a function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AsyncFunctionDef | ast.FunctionDef</code>)         \u2013 <p>The node to visit.</p> </li> <li> labels             (<code>set | None</code>)         \u2013 <p>Labels to add to the data object.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def handle_function(self, node: ast.AsyncFunctionDef | ast.FunctionDef, labels: set | None = None) -&gt; None:\n\"\"\"Handle a function definition node.\n\n    Parameters:\n        node: The node to visit.\n        labels: Labels to add to the data object.\n    \"\"\"\n    labels = labels or set()\n\n    # handle decorators\n    decorators = []\n    overload = False\n    if node.decorator_list:\n        lineno = node.decorator_list[0].lineno\n        for decorator_node in node.decorator_list:\n            decorator_value = safe_get_value(decorator_node, self.filepath)\n            overload = (\n                decorator_value in typing_overload\n                or decorator_value == \"overload\"\n                and self.current.resolve(\"overload\") in typing_overload\n            )\n            decorators.append(\n                Decorator(\n                    decorator_value,  # type: ignore[arg-type]\n                    lineno=decorator_node.lineno,\n                    endlineno=decorator_node.end_lineno,  # type: ignore[attr-defined]\n                ),\n            )\n    else:\n        lineno = node.lineno\n\n    labels |= self.decorators_to_labels(decorators)\n\n    if \"property\" in labels:\n        attribute = Attribute(\n            name=node.name,\n            value=None,\n            annotation=safe_get_annotation(node.returns, parent=self.current),\n            lineno=node.lineno,\n            endlineno=node.end_lineno,  # type: ignore[union-attr]\n            docstring=self._get_docstring(node),\n            runtime=not self.type_guarded,\n        )\n        attribute.labels |= labels\n        self.current[node.name] = attribute\n        return\n\n    base_property, property_function = self.get_base_property(decorators)\n\n    # handle parameters\n    parameters = Parameters()\n    annotation: str | Name | Expression | None\n\n    # TODO: remove once Python 3.7 support is dropped\n    try:\n        posonlyargs = node.args.posonlyargs  # type: ignore[attr-defined]\n    except AttributeError:\n        posonlyargs = []\n\n    # TODO: probably some optimizations to do here\n    args_kinds_defaults: Iterable = reversed(\n        (\n            *zip_longest(\n                reversed(\n                    (\n                        *zip_longest(\n                            posonlyargs,  # type: ignore[attr-defined]\n                            [],\n                            fillvalue=ParameterKind.positional_only,\n                        ),\n                        *zip_longest(node.args.args, [], fillvalue=ParameterKind.positional_or_keyword),\n                    ),\n                ),\n                reversed(node.args.defaults),\n                fillvalue=None,\n            ),\n        ),\n    )\n    arg: ast.arg\n    kind: ParameterKind\n    arg_default: ast.AST | None\n    for (arg, kind), arg_default in args_kinds_defaults:\n        annotation = safe_get_annotation(arg.annotation, parent=self.current)\n        default = get_parameter_default(arg_default, self.filepath, self.lines_collection)\n        parameters.add(Parameter(arg.arg, annotation=annotation, kind=kind, default=default))\n\n    if node.args.vararg:\n        annotation = safe_get_annotation(node.args.vararg.annotation, parent=self.current)\n        parameters.add(\n            Parameter(\n                node.args.vararg.arg,\n                annotation=annotation,\n                kind=ParameterKind.var_positional,\n                default=\"()\",\n            ),\n        )\n\n    # TODO: probably some optimizations to do here\n    kwargs_defaults: Iterable = reversed(\n        (\n            *zip_longest(\n                reversed(node.args.kwonlyargs),\n                reversed(node.args.kw_defaults),\n                fillvalue=None,\n            ),\n        ),\n    )\n    kwarg: ast.arg\n    kwarg_default: ast.AST | None\n    for kwarg, kwarg_default in kwargs_defaults:\n        annotation = safe_get_annotation(kwarg.annotation, parent=self.current)\n        default = get_parameter_default(kwarg_default, self.filepath, self.lines_collection)\n        parameters.add(\n            Parameter(kwarg.arg, annotation=annotation, kind=ParameterKind.keyword_only, default=default),\n        )\n\n    if node.args.kwarg:\n        annotation = safe_get_annotation(node.args.kwarg.annotation, parent=self.current)\n        parameters.add(\n            Parameter(\n                node.args.kwarg.arg,\n                annotation=annotation,\n                kind=ParameterKind.var_keyword,\n                default=\"{}\",\n            ),\n        )\n\n    function = Function(\n        name=node.name,\n        lineno=lineno,\n        endlineno=node.end_lineno,  # type: ignore[union-attr]\n        parameters=parameters,\n        returns=safe_get_annotation(node.returns, parent=self.current),\n        decorators=decorators,\n        docstring=self._get_docstring(node),\n        runtime=not self.type_guarded,\n        parent=self.current,\n    )\n\n    if overload:\n        self.current.overloads[function.name].append(function)\n    elif base_property is not None:\n        if property_function == \"setter\":\n            base_property.setter = function\n            base_property.labels.add(\"writable\")\n        elif property_function == \"deleter\":\n            base_property.deleter = function\n            base_property.labels.add(\"deletable\")\n    else:\n        self.current[node.name] = function\n        if self.current.kind in {Kind.MODULE, Kind.CLASS} and self.current.overloads[function.name]:\n            function.overloads = self.current.overloads[function.name]\n            del self.current.overloads[function.name]\n\n    function.labels |= labels\n\n    if self.current.kind is Kind.CLASS and function.name == \"__init__\":\n        self.current = function  # type: ignore[assignment]  # temporary assign a function\n        self.generic_visit(node)\n        self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit","title":"visit","text":"<pre><code>visit(node)\n</code></pre> <p>Extend the base visit with extensions.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Extend the base visit with extensions.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for before_visitor in self.extensions.before_visit:\n        before_visitor.visit(node)\n    super().visit(node)\n    for after_visitor in self.extensions.after_visit:\n        after_visitor.visit(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_annassign","title":"visit_annassign","text":"<pre><code>visit_annassign(node)\n</code></pre> <p>Visit an annotated assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AnnAssign</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_annassign(self, node: ast.AnnAssign) -&gt; None:\n\"\"\"Visit an annotated assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_attribute(node, safe_get_annotation(node.annotation, parent=self.current))\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_assign","title":"visit_assign","text":"<pre><code>visit_assign(node)\n</code></pre> <p>Visit an assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.Assign</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_assign(self, node: ast.Assign) -&gt; None:\n\"\"\"Visit an assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_attribute(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_asyncfunctiondef","title":"visit_asyncfunctiondef","text":"<pre><code>visit_asyncfunctiondef(node)\n</code></pre> <p>Visit an async function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AsyncFunctionDef</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_asyncfunctiondef(self, node: ast.AsyncFunctionDef) -&gt; None:\n\"\"\"Visit an async function definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_function(node, labels={\"async\"})\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_augassign","title":"visit_augassign","text":"<pre><code>visit_augassign(node)\n</code></pre> <p>Visit an augmented assignment node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AugAssign</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_augassign(self, node: ast.AugAssign) -&gt; None:\n\"\"\"Visit an augmented assignment node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    with suppress(AttributeError):\n        all_augment = (\n            node.target.id == \"__all__\"  # type: ignore[attr-defined,union-attr]\n            and self.current.is_module\n            and isinstance(node.op, ast.Add)\n        )\n        if all_augment:\n            # we assume exports is not None at this point\n            self.current.exports.extend(parse__all__(node, self.current))  # type: ignore[arg-type,union-attr]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_classdef","title":"visit_classdef","text":"<pre><code>visit_classdef(node)\n</code></pre> <p>Visit a class definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.ClassDef</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_classdef(self, node: ast.ClassDef) -&gt; None:\n\"\"\"Visit a class definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    # handle decorators\n    decorators = []\n    if node.decorator_list:\n        lineno = node.decorator_list[0].lineno\n        for decorator_node in node.decorator_list:\n            decorators.append(\n                Decorator(\n                    safe_get_value(decorator_node, self.current.relative_filepath),  # type: ignore[arg-type]\n                    lineno=decorator_node.lineno,\n                    endlineno=decorator_node.end_lineno,  # type: ignore[attr-defined]\n                ),\n            )\n    else:\n        lineno = node.lineno\n\n    # handle base classes\n    bases = []\n    if node.bases:\n        for base in node.bases:\n            bases.append(safe_get_annotation(base, parent=self.current))\n\n    class_ = Class(\n        name=node.name,\n        lineno=lineno,\n        endlineno=node.end_lineno,  # type: ignore[attr-defined]\n        docstring=self._get_docstring(node),\n        decorators=decorators,\n        bases=bases,  # type: ignore[arg-type]\n        runtime=not self.type_guarded,\n    )\n    class_.labels |= self.decorators_to_labels(decorators)\n    self.current[node.name] = class_\n    self.current = class_\n    self.generic_visit(node)\n    self.current = self.current.parent  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_functiondef","title":"visit_functiondef","text":"<pre><code>visit_functiondef(node)\n</code></pre> <p>Visit a function definition node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.FunctionDef</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_functiondef(self, node: ast.FunctionDef) -&gt; None:\n\"\"\"Visit a function definition node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.handle_function(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_if","title":"visit_if","text":"<pre><code>visit_if(node)\n</code></pre> <p>Visit an \"if\" node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.If</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_if(self, node: ast.If) -&gt; None:\n\"\"\"Visit an \"if\" node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    if isinstance(node.parent, (ast.Module, ast.ClassDef)):  # type: ignore[attr-defined]\n        with suppress(KeyError):  # unhandled AST nodes\n            condition = get_annotation(node.test, parent=self.current)\n            if str(condition) in {\"typing.TYPE_CHECKING\", \"TYPE_CHECKING\"}:\n                self.type_guarded = True\n    self.generic_visit(node)\n    self.type_guarded = False\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_import","title":"visit_import","text":"<pre><code>visit_import(node)\n</code></pre> <p>Visit an import node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.Import</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_import(self, node: ast.Import) -&gt; None:\n\"\"\"Visit an import node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for name in node.names:\n        alias_path = name.name\n        alias_name = name.asname or alias_path.split(\".\", 1)[0]\n        self.current.imports[alias_name] = alias_path\n        self.current[alias_name] = Alias(\n            alias_name,\n            alias_path,\n            lineno=node.lineno,\n            endlineno=node.end_lineno,  # type: ignore[attr-defined]\n            runtime=not self.type_guarded,\n        )\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_importfrom","title":"visit_importfrom","text":"<pre><code>visit_importfrom(node)\n</code></pre> <p>Visit an \"import from\" node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.ImportFrom</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_importfrom(self, node: ast.ImportFrom) -&gt; None:\n\"\"\"Visit an \"import from\" node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    for name in node.names:\n        if not node.module and node.level == 1 and not name.asname:\n            # special case: when being in `a` and doing `from . import b`,\n            # we are effectively creating a member `b` in `a` that is pointing to `a.b`\n            # -&gt; cyclic alias! in that case, we just skip it, as both the member and module\n            # have the same name and can be accessed the same way\n            continue\n\n        alias_path = relative_to_absolute(node, name, self.current.module)\n        if name.name == \"*\":\n            alias_name = alias_path.replace(\".\", \"/\")  # type: ignore[union-attr]\n            alias_path = alias_path.replace(\".*\", \"\")\n        else:\n            alias_name = name.asname or name.name\n            self.current.imports[alias_name] = alias_path\n        self.current[alias_name] = Alias(\n            alias_name,\n            alias_path,  # type: ignore[arg-type]\n            lineno=node.lineno,\n            endlineno=node.end_lineno,  # type: ignore[attr-defined]\n            runtime=not self.type_guarded,\n        )\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.Visitor.visit_module","title":"visit_module","text":"<pre><code>visit_module(node)\n</code></pre> <p>Visit a module node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.Module</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit_module(self, node: ast.Module) -&gt; None:\n\"\"\"Visit a module node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    self.current = Module(\n        name=self.module_name,\n        filepath=self.filepath,\n        parent=self.parent,\n        docstring=self._get_docstring(node),\n        lines_collection=self.lines_collection,\n        modules_collection=self.modules_collection,\n    )\n    self.generic_visit(node)\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.patch_ast","title":"patch_ast","text":"<pre><code>patch_ast()\n</code></pre> <p>Extend the base <code>ast.AST</code> class to provide more functionality.</p> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def patch_ast() -&gt; None:\n\"\"\"Extend the base `ast.AST` class to provide more functionality.\"\"\"\n    global _patched  # noqa: PLW0603\n    if _patched:\n        return\n    for name, member in inspect.getmembers(ast):\n        if name != \"AST\" and inspect.isclass(member) and ast.AST in member.__bases__:\n            member.__bases__ = (*member.__bases__, ASTNode)\n    _patched = True\n</code></pre>"},{"location":"reference/griffe/agents/visitor/#griffe.agents.visitor.visit","title":"visit","text":"<pre><code>visit(\n    module_name,\n    filepath,\n    code,\n    *,\n    extensions=None,\n    parent=None,\n    docstring_parser=None,\n    docstring_options=None,\n    lines_collection=None,\n    modules_collection=None\n)\n</code></pre> <p>Parse and visit a module file.</p> <p>Parameters:</p> <ul> <li> module_name             (<code>str</code>)         \u2013 <p>The module name (as when importing [from] it).</p> </li> <li> filepath             (<code>Path</code>)         \u2013 <p>The module file path.</p> </li> <li> code             (<code>str</code>)         \u2013 <p>The module contents.</p> </li> <li> extensions             (<code>Extensions | None</code>)         \u2013 <p>The extensions to use when visiting the AST.</p> </li> <li> parent             (<code>Module | None</code>)         \u2013 <p>The optional parent of this module.</p> </li> <li> docstring_parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. By default, no parsing is done.</p> </li> <li> docstring_options             (<code>dict[str, Any] | None</code>)         \u2013 <p>Additional docstring parsing options.</p> </li> <li> lines_collection             (<code>LinesCollection | None</code>)         \u2013 <p>A collection of source code lines.</p> </li> <li> modules_collection             (<code>ModulesCollection | None</code>)         \u2013 <p>A collection of modules.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Module</code>         \u2013 <p>The module, with its members populated.</p> </li> </ul> Source code in <code>src/griffe/agents/visitor.py</code> <pre><code>def visit(\n    module_name: str,\n    filepath: Path,\n    code: str,\n    *,\n    extensions: Extensions | None = None,\n    parent: Module | None = None,\n    docstring_parser: Parser | None = None,\n    docstring_options: dict[str, Any] | None = None,\n    lines_collection: LinesCollection | None = None,\n    modules_collection: ModulesCollection | None = None,\n) -&gt; Module:\n\"\"\"Parse and visit a module file.\n\n    Parameters:\n        module_name: The module name (as when importing [from] it).\n        filepath: The module file path.\n        code: The module contents.\n        extensions: The extensions to use when visiting the AST.\n        parent: The optional parent of this module.\n        docstring_parser: The docstring parser to use. By default, no parsing is done.\n        docstring_options: Additional docstring parsing options.\n        lines_collection: A collection of source code lines.\n        modules_collection: A collection of modules.\n\n    Returns:\n        The module, with its members populated.\n    \"\"\"\n    return Visitor(\n        module_name,\n        filepath,\n        code,\n        extensions or Extensions(),\n        parent,\n        docstring_parser=docstring_parser,\n        docstring_options=docstring_options,\n        lines_collection=lines_collection,\n        modules_collection=modules_collection,\n    ).get_module()\n</code></pre>"},{"location":"reference/griffe/docstrings/","title":"Index","text":"<p>This module exposes objects related to docstrings.</p>"},{"location":"reference/griffe/docstrings/#griffe.docstrings.Parser","title":"Parser","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enumeration for the different docstring parsers.</p>"},{"location":"reference/griffe/docstrings/#griffe.docstrings.parse","title":"parse","text":"<pre><code>parse(docstring, parser, **options)\n</code></pre> <p>Parse the docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring to parse.</p> </li> <li> parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. If None, return a single text section.</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>The options accepted by the parser.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/parsers.py</code> <pre><code>def parse(docstring: Docstring, parser: Parser | None, **options: Any) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        parser: The docstring parser to use. If None, return a single text section.\n        **options: The options accepted by the parser.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    if parser:\n        return parsers[parser](docstring, **options)  # type: ignore[operator]\n    return [DocstringSectionText(docstring.value)]\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/","title":"dataclasses","text":"<p>This module contains the dataclasses related to docstrings.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition","title":"DocstringAdmonition","text":"<p>         Bases: <code>DocstringElement</code></p> <p>This class represents an admonition.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.contents","title":"contents  <code>property</code> <code>writable</code>","text":"<pre><code>contents: str\n</code></pre> <p>Return the contents of this admonition.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The admonition's contents.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAdmonition.kind","title":"kind  <code>property</code> <code>writable</code>","text":"<pre><code>kind: str | Name | Expression | None\n</code></pre> <p>Return the kind of this admonition.</p> <p>Returns:</p> <ul> <li> <code>str | Name | Expression | None</code>         \u2013 <p>The admonition's kind.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringAttribute","title":"DocstringAttribute","text":"<p>         Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented module/class attribute.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated","title":"DocstringDeprecated","text":"<p>         Bases: <code>DocstringElement</code></p> <p>This class represents a documented deprecated item.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringDeprecated.version","title":"version  <code>property</code> <code>writable</code>","text":"<pre><code>version: str\n</code></pre> <p>Return the version of this deprecation.</p> <p>Returns:</p> <ul> <li> <code>str</code>         \u2013 <p>The deprecation version.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement","title":"DocstringElement","text":"<pre><code>DocstringElement(*, description, annotation=None)\n</code></pre> <p>This base class represents annotated, nameless elements.</p> <p>Attributes:</p> <ul> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The element annotation, if any.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>The element description.</p> </li> </ul> <p>Parameters:</p> <ul> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The element annotation, if any.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>The element description.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, *, description: str, annotation: str | Name | Expression | None = None) -&gt; None:\n\"\"\"Initialize the element.\n\n    Parameters:\n        annotation: The element annotation, if any.\n        description: The element description.\n    \"\"\"\n    self.description: str = description\n    self.annotation: str | Name | Expression | None = annotation\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringElement.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:  # noqa: ARG002\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    return {\n        \"annotation\": self.annotation,\n        \"description\": self.description,\n    }\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement","title":"DocstringNamedElement","text":"<pre><code>DocstringNamedElement(\n    name, *, description, annotation=None, value=None\n)\n</code></pre> <p>         Bases: <code>DocstringElement</code></p> <p>This base class represents annotated, named elements.</p> <p>Attributes:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The element name.</p> </li> <li> value             (<code>str | None</code>)         \u2013 <p>The element value, as a string, if any.</p> </li> </ul> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The element name.</p> </li> <li> description             (<code>str</code>)         \u2013 <p>The element description.</p> </li> <li> annotation             (<code>str | Name | Expression | None</code>)         \u2013 <p>The element annotation, if any.</p> </li> <li> value             (<code>str | None</code>)         \u2013 <p>The element value, as a string.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *,\n    description: str,\n    annotation: str | Name | Expression | None = None,\n    value: str | None = None,\n) -&gt; None:\n\"\"\"Initialize the element.\n\n    Parameters:\n        name: The element name.\n        description: The element description.\n        annotation: The element annotation, if any.\n        value: The element value, as a string.\n    \"\"\"\n    super().__init__(description=description, annotation=annotation)\n    self.name: str = name\n    self.value: str | None = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringNamedElement.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this element's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this element's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    base = {\"name\": self.name, **super().as_dict(**kwargs)}\n    if self.value is not None:\n        base[\"value\"] = self.value\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter","title":"DocstringParameter","text":"<p>         Bases: <code>DocstringNamedElement</code></p> <p>This class represent a documented function parameter.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringParameter.default","title":"default  <code>property</code> <code>writable</code>","text":"<pre><code>default: str | None\n</code></pre> <p>Return the default value of this parameter.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>         \u2013 <p>The parameter's default.</p> </li> </ul>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringRaise","title":"DocstringRaise","text":"<p>         Bases: <code>DocstringElement</code></p> <p>This class represents a documented raise value.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReceive","title":"DocstringReceive","text":"<p>         Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented receive value.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringReturn","title":"DocstringReturn","text":"<p>         Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented return value.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection","title":"DocstringSection","text":"<pre><code>DocstringSection(title=None)\n</code></pre> <p>This class represents a docstring section.</p> <p>Parameters:</p> <ul> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        title: An optional title.\n    \"\"\"\n    self.title: str | None = title\n    self.value: Any = None\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSection.as_dict","title":"as_dict","text":"<pre><code>as_dict(**kwargs)\n</code></pre> <p>Return this section's data as a dictionary.</p> <p>Parameters:</p> <ul> <li> **kwargs             (<code>Any</code>)         \u2013 <p>Additional serialization options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>         \u2013 <p>A dictionary.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def as_dict(self, **kwargs: Any) -&gt; dict[str, Any]:\n\"\"\"Return this section's data as a dictionary.\n\n    Parameters:\n        **kwargs: Additional serialization options.\n\n    Returns:\n        A dictionary.\n    \"\"\"\n    if hasattr(self.value, \"as_dict\"):  # type: ignore[attr-defined]  # noqa: SIM108\n        serialized_value = self.value.as_dict(**kwargs)  # type: ignore[attr-defined]\n    else:\n        serialized_value = self.value  # type: ignore[attr-defined]\n    base = {\"kind\": self.kind.value, \"value\": serialized_value}\n    if self.title:\n        base[\"title\"] = self.title\n    return base\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAdmonition","title":"DocstringSectionAdmonition","text":"<pre><code>DocstringSectionAdmonition(kind, text, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents an admonition section.</p> <p>Parameters:</p> <ul> <li> kind             (<code>str</code>)         \u2013 <p>The admonition kind.</p> </li> <li> text             (<code>str</code>)         \u2013 <p>The admonition text.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, kind: str, text: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        kind: The admonition kind.\n        text: The admonition text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: DocstringAdmonition = DocstringAdmonition(annotation=kind, description=text)\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionAttributes","title":"DocstringSectionAttributes","text":"<pre><code>DocstringSectionAttributes(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents an attributes section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringAttribute]</code>)         \u2013 <p>The section attributes.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringAttribute], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section attributes.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringAttribute] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionDeprecated","title":"DocstringSectionDeprecated","text":"<pre><code>DocstringSectionDeprecated(version, text, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a deprecated section.</p> <p>Parameters:</p> <ul> <li> version             (<code>str</code>)         \u2013 <p>The deprecation version.</p> </li> <li> text             (<code>str</code>)         \u2013 <p>The deprecation text.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, version: str, text: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        version: The deprecation version.\n        text: The deprecation text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: DocstringDeprecated = DocstringDeprecated(annotation=version, description=text)\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionExamples","title":"DocstringSectionExamples","text":"<pre><code>DocstringSectionExamples(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents an examples section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[tuple[Literal[DocstringSectionKind.text] | Literal[DocstringSectionKind.examples], str]]</code>)         \u2013 <p>The section examples.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(\n    self,\n    value: list[tuple[Literal[DocstringSectionKind.text] | Literal[DocstringSectionKind.examples], str]],\n    title: str | None = None,\n) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section examples.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[\n        tuple[Literal[DocstringSectionKind.text] | Literal[DocstringSectionKind.examples], str]\n    ] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionKind","title":"DocstringSectionKind","text":"<p>         Bases: <code>enum.Enum</code></p> <p>The possible section kinds.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionOtherParameters","title":"DocstringSectionOtherParameters","text":"<p>         Bases: <code>DocstringSectionParameters</code></p> <p>This class represents an other parameters section.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionParameters","title":"DocstringSectionParameters","text":"<pre><code>DocstringSectionParameters(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a parameters section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringParameter]</code>)         \u2013 <p>The section parameters.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringParameter], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section parameters.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringParameter] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionRaises","title":"DocstringSectionRaises","text":"<pre><code>DocstringSectionRaises(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a raises section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringRaise]</code>)         \u2013 <p>The section exceptions.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringRaise], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section exceptions.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringRaise] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReceives","title":"DocstringSectionReceives","text":"<pre><code>DocstringSectionReceives(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a receives section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringReceive]</code>)         \u2013 <p>The section received items.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringReceive], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section received items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringReceive] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionReturns","title":"DocstringSectionReturns","text":"<pre><code>DocstringSectionReturns(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a returns section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringReturn]</code>)         \u2013 <p>The section returned items.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringReturn], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section returned items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringReturn] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionText","title":"DocstringSectionText","text":"<pre><code>DocstringSectionText(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a text section.</p> <p>Parameters:</p> <ul> <li> value             (<code>str</code>)         \u2013 <p>The section text.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: str, title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section text.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: str = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionWarns","title":"DocstringSectionWarns","text":"<pre><code>DocstringSectionWarns(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a warns section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringWarn]</code>)         \u2013 <p>The section warnings.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringWarn], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section warnings.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringWarn] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringSectionYields","title":"DocstringSectionYields","text":"<pre><code>DocstringSectionYields(value, title=None)\n</code></pre> <p>         Bases: <code>DocstringSection</code></p> <p>This class represents a yields section.</p> <p>Parameters:</p> <ul> <li> value             (<code>list[DocstringYield]</code>)         \u2013 <p>The section yielded items.</p> </li> <li> title             (<code>str | None</code>)         \u2013 <p>An optional title.</p> </li> </ul> Source code in <code>src/griffe/docstrings/dataclasses.py</code> <pre><code>def __init__(self, value: list[DocstringYield], title: str | None = None) -&gt; None:\n\"\"\"Initialize the section.\n\n    Parameters:\n        value: The section yielded items.\n        title: An optional title.\n    \"\"\"\n    super().__init__(title)\n    self.value: list[DocstringYield] = value\n</code></pre>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringWarn","title":"DocstringWarn","text":"<p>         Bases: <code>DocstringElement</code></p> <p>This class represents a documented warn value.</p>"},{"location":"reference/griffe/docstrings/dataclasses/#griffe.docstrings.dataclasses.DocstringYield","title":"DocstringYield","text":"<p>         Bases: <code>DocstringNamedElement</code></p> <p>This class represents a documented yield value.</p>"},{"location":"reference/griffe/docstrings/google/","title":"google","text":"<p>This module defines functions to parse Google-style docstrings into structured data.</p>"},{"location":"reference/griffe/docstrings/google/#griffe.docstrings.google.parse","title":"parse","text":"<pre><code>parse(\n    docstring,\n    *,\n    ignore_init_summary=False,\n    trim_doctest_flags=True,\n    **options\n)\n</code></pre> <p>Parse a docstring.</p> <p>This function iterates on lines of a docstring to build sections. It then returns this list of sections.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring to parse.</p> </li> <li> ignore_init_summary             (<code>bool</code>)         \u2013 <p>Whether to ignore the summary in <code>__init__</code> methods' docstrings.</p> </li> <li> trim_doctest_flags             (<code>bool</code>)         \u2013 <p>Whether to remove doctest flags from Python example blocks.</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/google.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse a docstring.\n\n    This function iterates on lines of a docstring to build sections.\n    It then returns this list of sections.\n\n    Parameters:\n        docstring: The docstring to parse.\n        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.\n        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    sections: list[DocstringSection] = []\n    current_section = []\n\n    in_code_block = False\n    lines = docstring.lines\n\n    options = {\n        \"ignore_init_summary\": ignore_init_summary,\n        \"trim_doctest_flags\": trim_doctest_flags,\n        **options,\n    }\n\n    ignore_summary = (\n        options[\"ignore_init_summary\"]\n        and docstring.parent is not None\n        and docstring.parent.name == \"__init__\"\n        and docstring.parent.is_function\n        and docstring.parent.parent is not None\n        and docstring.parent.parent.is_class\n    )\n\n    offset = 2 if ignore_summary else 0\n\n    while offset &lt; len(lines):\n        line_lower = lines[offset].lower()\n\n        if in_code_block:\n            if line_lower.lstrip(\" \").startswith(\"```\"):\n                in_code_block = False\n            current_section.append(lines[offset])\n\n        elif line_lower.lstrip(\" \").startswith(\"```\"):\n            in_code_block = True\n            current_section.append(lines[offset])\n\n        else:\n            # TODO: once Python 3.7 is dropped, use walrus operator\n            match = _RE_ADMONITION.match(lines[offset])\n            if match:\n                groups = match.groupdict()\n                title = groups[\"title\"]\n                admonition_type = groups[\"type\"]\n                if admonition_type.lower() in _section_kind:\n                    if current_section:\n                        if any(current_section):\n                            sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                        current_section = []\n                    reader = _section_reader[_section_kind[admonition_type.lower()]]\n                    section, offset = reader(docstring, offset=offset + 1, **options)  # type: ignore[operator]\n                    if section:\n                        section.title = title\n                        sections.append(section)\n\n                else:\n                    contents, offset = _read_block(docstring, offset=offset + 1)\n                    if contents:\n                        if current_section:\n                            if any(current_section):\n                                sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                            current_section = []\n                        if title is None:\n                            title = admonition_type\n                        admonition_type = admonition_type.lower().replace(\" \", \"-\")\n                        sections.append(DocstringSectionAdmonition(kind=admonition_type, text=contents, title=title))\n                    else:\n                        with suppress(IndexError):\n                            current_section.append(lines[offset])\n            else:\n                current_section.append(lines[offset])\n\n        offset += 1\n\n    if current_section:\n        sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n\n    return sections\n</code></pre>"},{"location":"reference/griffe/docstrings/markdown/","title":"markdown","text":"<p>This module defines functions and classes to parse Markdown docstrings into structured data.</p>"},{"location":"reference/griffe/docstrings/numpy/","title":"numpy","text":"<p>This module defines functions to parse Numpy-style docstrings into structured data.</p> <p>Based on https://numpydoc.readthedocs.io/en/latest/format.html, it seems Numpydoc is a superset of RST. Since fully parsing RST is a non-goal of this project, some things are stripped from the Numpydoc specification.</p> <p>Rejected as non particularly Pythonic or useful as sections:</p> <ul> <li>See also: this section feels too subjective (specially crafted as a standard for Numpy itself),     and there are may ways to reference related items in a docstring, depending on the chosen markup.</li> <li>Methods: with a good documentation renderer, methods are easily made accessible or hidden.     Griffe also has a goal of making the merging of inherited methods configurable (on/off).</li> </ul> <p>Rejected as naturally handled by the user-chosen markup:</p> <ul> <li>Warnings: this is just markup.</li> <li>Notes: again, just markup.</li> <li>References: again, just markup.</li> </ul> <p>The following sections are supported:</p> <ul> <li>Deprecated (revisited): we expect a title instead of an RST directive.     Python has support for deprecating things, so it feels natural     to structure deprecations.</li> <li>Parameters: obviously.</li> <li>Returns: obviously.</li> <li>Yields: obviously.</li> <li>Receives: less used than Yields, but very natural/Pythonic as well.</li> <li>Other parameters: used here as documentation for keyword parameters.</li> <li>Raises: obviously.</li> <li>Warns: less used than Raises, but very natural/Pythonic as well.</li> <li>Examples: obviously. Special handling for non-code-blocks <code>&gt;&gt;&gt;</code>.</li> <li>Attributes: obviously.</li> </ul>"},{"location":"reference/griffe/docstrings/numpy/#griffe.docstrings.numpy.parse","title":"parse","text":"<pre><code>parse(\n    docstring,\n    *,\n    ignore_init_summary=False,\n    trim_doctest_flags=True,\n    **options\n)\n</code></pre> <p>Parse a docstring.</p> <p>This function iterates on lines of a docstring to build sections. It then returns this list of sections.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring to parse.</p> </li> <li> ignore_init_summary             (<code>bool</code>)         \u2013 <p>Whether to ignore the summary in <code>__init__</code> methods' docstrings.</p> </li> <li> trim_doctest_flags             (<code>bool</code>)         \u2013 <p>Whether to remove doctest flags from Python example blocks.</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/numpy.py</code> <pre><code>def parse(\n    docstring: Docstring,\n    *,\n    ignore_init_summary: bool = False,\n    trim_doctest_flags: bool = True,\n    **options: Any,\n) -&gt; list[DocstringSection]:\n\"\"\"Parse a docstring.\n\n    This function iterates on lines of a docstring to build sections.\n    It then returns this list of sections.\n\n    Parameters:\n        docstring: The docstring to parse.\n        ignore_init_summary: Whether to ignore the summary in `__init__` methods' docstrings.\n        trim_doctest_flags: Whether to remove doctest flags from Python example blocks.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    sections: list[DocstringSection] = []\n    current_section = []\n\n    in_code_block = False\n    lines = docstring.lines\n\n    options = {\n        \"trim_doctest_flags\": trim_doctest_flags,\n        \"ignore_init_summary\": ignore_init_summary,\n        **options,\n    }\n\n    ignore_summary = (\n        options[\"ignore_init_summary\"]\n        and docstring.parent is not None\n        and docstring.parent.name == \"__init__\"\n        and docstring.parent.is_function\n        and docstring.parent.parent is not None\n        and docstring.parent.parent.is_class\n    )\n\n    offset = 2 if ignore_summary else 0\n\n    while offset &lt; len(lines):\n        line_lower = lines[offset].lower()\n\n        if in_code_block:\n            if line_lower.lstrip(\" \").startswith(\"```\"):\n                in_code_block = False\n            current_section.append(lines[offset])\n\n        elif line_lower in _section_kind and _is_dash_line(lines[offset + 1]):\n            if current_section:\n                if any(current_section):\n                    sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n                current_section = []\n            reader = _section_reader[_section_kind[line_lower]]\n            section, offset = reader(docstring, offset=offset + 2, **options)  # type: ignore[operator]\n            if section:\n                sections.append(section)\n\n        elif line_lower.lstrip(\" \").startswith(\"```\"):\n            in_code_block = True\n            current_section.append(lines[offset])\n\n        else:\n            current_section.append(lines[offset])\n\n        offset += 1\n\n    if current_section:\n        sections.append(DocstringSectionText(\"\\n\".join(current_section).rstrip(\"\\n\")))\n\n    return sections\n</code></pre>"},{"location":"reference/griffe/docstrings/parsers/","title":"parsers","text":"<p>This module imports all the defined parsers.</p>"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.Parser","title":"Parser","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enumeration for the different docstring parsers.</p>"},{"location":"reference/griffe/docstrings/parsers/#griffe.docstrings.parsers.parse","title":"parse","text":"<pre><code>parse(docstring, parser, **options)\n</code></pre> <p>Parse the docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring to parse.</p> </li> <li> parser             (<code>Parser | None</code>)         \u2013 <p>The docstring parser to use. If None, return a single text section.</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>The options accepted by the parser.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/parsers.py</code> <pre><code>def parse(docstring: Docstring, parser: Parser | None, **options: Any) -&gt; list[DocstringSection]:\n\"\"\"Parse the docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        parser: The docstring parser to use. If None, return a single text section.\n        **options: The options accepted by the parser.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    if parser:\n        return parsers[parser](docstring, **options)  # type: ignore[operator]\n    return [DocstringSectionText(docstring.value)]\n</code></pre>"},{"location":"reference/griffe/docstrings/sphinx/","title":"sphinx","text":"<p>This module defines functions to parse Sphinx docstrings into structured data.</p> <p>Credits to Patrick Lannigan (@plannigan) who originally added the parser in the pytkdocs project. See https://github.com/mkdocstrings/pytkdocs/pull/71.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType","title":"FieldType  <code>dataclass</code>","text":"<p>Maps directive names to parser functions.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.FieldType.matches","title":"matches","text":"<pre><code>matches(line)\n</code></pre> <p>Check if a line matches the field type.</p> <p>Parameters:</p> <ul> <li> line             (<code>str</code>)         \u2013 <p>Line to check against</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>         \u2013 <p>True if the line matches the field type, False otherwise.</p> </li> </ul> Source code in <code>src/griffe/docstrings/sphinx.py</code> <pre><code>def matches(self, line: str) -&gt; bool:\n\"\"\"Check if a line matches the field type.\n\n    Parameters:\n        line: Line to check against\n\n    Returns:\n        True if the line matches the field type, False otherwise.\n    \"\"\"\n    return any(line.startswith(f\":{name}\") for name in self.names)\n</code></pre>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedDirective","title":"ParsedDirective  <code>dataclass</code>","text":"<p>Directive information that has been parsed from a docstring.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.ParsedValues","title":"ParsedValues  <code>dataclass</code>","text":"<p>Values parsed from the docstring to be used to produce sections.</p>"},{"location":"reference/griffe/docstrings/sphinx/#griffe.docstrings.sphinx.parse","title":"parse","text":"<pre><code>parse(docstring, **options)\n</code></pre> <p>Parse a Sphinx-styled docstring.</p> <p>Parameters:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring to parse.</p> </li> <li> **options             (<code>Any</code>)         \u2013 <p>Additional parsing options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[DocstringSection]</code>         \u2013 <p>A list of docstring sections.</p> </li> </ul> Source code in <code>src/griffe/docstrings/sphinx.py</code> <pre><code>def parse(docstring: Docstring, **options: Any) -&gt; list[DocstringSection]:  # noqa: ARG001\n\"\"\"Parse a Sphinx-styled docstring.\n\n    Parameters:\n        docstring: The docstring to parse.\n        **options: Additional parsing options.\n\n    Returns:\n        A list of docstring sections.\n    \"\"\"\n    parsed_values = ParsedValues()\n\n    lines = docstring.lines\n    curr_line_index = 0\n\n    while curr_line_index &lt; len(lines):\n        line = lines[curr_line_index]\n        for field_type in field_types:\n            if field_type.matches(line):\n                # https://github.com/python/mypy/issues/5485\n                curr_line_index = field_type.reader(docstring, curr_line_index, parsed_values)  # type: ignore[misc,operator]\n                break\n        else:\n            parsed_values.description.append(line)\n\n        curr_line_index += 1\n\n    return _parsed_values_to_sections(parsed_values)\n</code></pre>"},{"location":"reference/griffe/docstrings/utils/","title":"utils","text":"<p>This module contains utilities for docstrings parsers.</p>"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.parse_annotation","title":"parse_annotation","text":"<pre><code>parse_annotation(\n    annotation, docstring, log_level=LogLevel.error\n)\n</code></pre> <p>Parse a string into a true name or expression that can be resolved later.</p> <p>Parameters:</p> <ul> <li> annotation             (<code>str</code>)         \u2013 <p>The annotation to parse.</p> </li> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring in which the annotation appears. The docstring's parent is accessed to bind a resolver to the resulting name/expression.</p> </li> <li> log_level             (<code>LogLevel</code>)         \u2013 <p>Log level to use to log a message.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | Name | Expression</code>         \u2013 <p>The string unchanged, or a new name or expression.</p> </li> </ul> Source code in <code>src/griffe/docstrings/utils.py</code> <pre><code>def parse_annotation(\n    annotation: str,\n    docstring: Docstring,\n    log_level: LogLevel = LogLevel.error,\n) -&gt; str | Name | Expression:\n\"\"\"Parse a string into a true name or expression that can be resolved later.\n\n    Parameters:\n        annotation: The annotation to parse.\n        docstring: The docstring in which the annotation appears.\n            The docstring's parent is accessed to bind a resolver to the resulting name/expression.\n        log_level: Log level to use to log a message.\n\n    Returns:\n        The string unchanged, or a new name or expression.\n    \"\"\"\n    with suppress(\n        AttributeError,  # docstring has no parent that can be used to resolve names\n        SyntaxError,  # annotation contains syntax errors\n    ):\n        code = compile(annotation, mode=\"eval\", filename=\"\", flags=PyCF_ONLY_AST, optimize=2)\n        if code.body:  # type: ignore[attr-defined]\n            name_or_expr = safe_get_annotation(\n                code.body,  # type: ignore[attr-defined]\n                parent=docstring.parent,  # type: ignore[arg-type]\n                log_level=log_level,\n            )\n            return name_or_expr or annotation\n    return annotation\n</code></pre>"},{"location":"reference/griffe/docstrings/utils/#griffe.docstrings.utils.warning","title":"warning","text":"<pre><code>warning(name)\n</code></pre> <p>Create and return a warn function.</p> <p>Parameters:</p> <ul> <li> name             (<code>str</code>)         \u2013 <p>The logger name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable[[Docstring, int, str], None]</code>         \u2013 <p>A function used to log parsing warnings.</p> </li> </ul> <p>This function logs a warning message by prefixing it with the filepath and line number.</p> <p>Parameters of the returned function:</p> <ul> <li> docstring             (<code>Docstring</code>)         \u2013 <p>The docstring object.</p> </li> <li> offset             (<code>int</code>)         \u2013 <p>The offset in the docstring lines.</p> </li> <li> message             (<code>str</code>)         \u2013 <p>The message to log.</p> </li> </ul> Source code in <code>src/griffe/docstrings/utils.py</code> <pre><code>def warning(name: str) -&gt; Callable[[Docstring, int, str], None]:\n\"\"\"Create and return a warn function.\n\n    Parameters:\n        name: The logger name.\n\n    Returns:\n        A function used to log parsing warnings.\n\n    This function logs a warning message by prefixing it with the filepath and line number.\n\n    Other parameters: Parameters of the returned function:\n        docstring (Docstring): The docstring object.\n        offset (int): The offset in the docstring lines.\n        message (str): The message to log.\n    \"\"\"\n    logger = get_logger(name)\n\n    def warn(docstring: Docstring, offset: int, message: str) -&gt; None:\n        try:\n            prefix = docstring.parent.relative_filepath  # type: ignore[union-attr]\n        except (AttributeError, ValueError):\n            prefix = \"&lt;module&gt;\"\n        logger.warning(f\"{prefix}:{(docstring.lineno or 0)+offset}: {message}\")\n\n    return warn\n</code></pre>"},{"location":"reference/griffe/extensions/","title":"Index","text":"<p>This module is the public interface to import elements from the base.</p>"},{"location":"reference/griffe/extensions/#griffe.extensions.Extensions","title":"Extensions","text":"<pre><code>Extensions(*extensions)\n</code></pre> <p>This class helps iterating on extensions that should run at different times.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>Extension</code>)         \u2013 <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self, *extensions: Extension) -&gt; None:\n\"\"\"Initialize the extensions container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    self._visitors: dict[When, list[VisitorExtension]] = defaultdict(list)\n    self._inspectors: dict[When, list[InspectorExtension]] = defaultdict(list)\n    self.add(*extensions)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.after_children_inspection","title":"after_children_inspection  <code>property</code>","text":"<pre><code>after_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.after_children_visit","title":"after_children_visit  <code>property</code>","text":"<pre><code>after_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.after_inspection","title":"after_inspection  <code>property</code>","text":"<pre><code>after_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.after_visit","title":"after_visit  <code>property</code>","text":"<pre><code>after_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.before_children_inspection","title":"before_children_inspection  <code>property</code>","text":"<pre><code>before_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.before_children_visit","title":"before_children_visit  <code>property</code>","text":"<pre><code>before_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.before_inspection","title":"before_inspection  <code>property</code>","text":"<pre><code>before_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.before_visit","title":"before_visit  <code>property</code>","text":"<pre><code>before_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.add","title":"add","text":"<pre><code>add(*extensions)\n</code></pre> <p>Add extensions to this container.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>Extension</code>)         \u2013 <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def add(self, *extensions: Extension) -&gt; None:\n\"\"\"Add extensions to this container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    for extension in extensions:\n        if isinstance(extension, VisitorExtension):\n            self._visitors[extension.when].append(extension)\n        else:\n            self._inspectors[extension.when].append(extension)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.attach_inspector","title":"attach_inspector","text":"<pre><code>attach_inspector(parent_inspector)\n</code></pre> <p>Attach a parent inspector to the inspector extensions.</p> <p>Parameters:</p> <ul> <li> parent_inspector             (<code>Inspector</code>)         \u2013 <p>The parent inspector, leading the inspection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_inspector(self, parent_inspector: Inspector) -&gt; Extensions:\n\"\"\"Attach a parent inspector to the inspector extensions.\n\n    Parameters:\n        parent_inspector: The parent inspector, leading the inspection.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._inspectors:\n        for inspector in self._inspectors[when]:\n            inspector.attach(parent_inspector)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.Extensions.attach_visitor","title":"attach_visitor","text":"<pre><code>attach_visitor(parent_visitor)\n</code></pre> <p>Attach a parent visitor to the visitor extensions.</p> <p>Parameters:</p> <ul> <li> parent_visitor             (<code>Visitor</code>)         \u2013 <p>The parent visitor, leading the visit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_visitor(self, parent_visitor: Visitor) -&gt; Extensions:\n\"\"\"Attach a parent visitor to the visitor extensions.\n\n    Parameters:\n        parent_visitor: The parent visitor, leading the visit.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._visitors:\n        for visitor in self._visitors[when]:\n            visitor.attach(parent_visitor)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.InspectorExtension","title":"InspectorExtension","text":"<pre><code>InspectorExtension()\n</code></pre> <p>         Bases: <code>BaseInspector</code></p> <p>The object inspector extension base class, to inherit from.</p> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the inspector extension.\"\"\"\n    super().__init__()\n    self.inspector: Inspector = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.InspectorExtension.attach","title":"attach","text":"<pre><code>attach(inspector)\n</code></pre> <p>Attach the parent inspector to this extension.</p> <p>Parameters:</p> <ul> <li> inspector             (<code>Inspector</code>)         \u2013 <p>The parent inspector.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, inspector: Inspector) -&gt; None:\n\"\"\"Attach the parent inspector to this extension.\n\n    Parameters:\n        inspector: The parent inspector.\n    \"\"\"\n    self.inspector = inspector\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.InspectorExtension.inspect","title":"inspect","text":"<pre><code>inspect(node)\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.VisitorExtension","title":"VisitorExtension","text":"<pre><code>VisitorExtension()\n</code></pre> <p>         Bases: <code>BaseVisitor</code></p> <p>The node visitor extension base class, to inherit from.</p> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the visitor extension.\"\"\"\n    super().__init__()\n    self.visitor: Visitor = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.VisitorExtension.attach","title":"attach","text":"<pre><code>attach(visitor)\n</code></pre> <p>Attach the parent visitor to this extension.</p> <p>Parameters:</p> <ul> <li> visitor             (<code>Visitor</code>)         \u2013 <p>The parent visitor.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, visitor: Visitor) -&gt; None:\n\"\"\"Attach the parent visitor to this extension.\n\n    Parameters:\n        visitor: The parent visitor.\n    \"\"\"\n    self.visitor = visitor\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.base.VisitorExtension.visit","title":"visit","text":"<pre><code>visit(node)\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{node.kind}\", lambda _: None)(node)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.When","title":"When","text":"<p>         Bases: <code>enum.Enum</code></p> <p>This enumeration contains the different times at which an extension is used.</p> <p>Attributes:</p> <ul> <li> before_all             (<code>int</code>)         \u2013 <p>For each node, before the visit/inspection.</p> </li> <li> before_children             (<code>int</code>)         \u2013 <p>For each node, after the visit has started, and before the children visit/inspection.</p> </li> <li> after_children             (<code>int</code>)         \u2013 <p>For each node, after the children have been visited/inspected, and before finishing the visit/inspection.</p> </li> <li> after_all             (<code>int</code>)         \u2013 <p>For each node, after the visit/inspection.</p> </li> </ul>"},{"location":"reference/griffe/extensions/#griffe.extensions.load_extension","title":"load_extension","text":"<pre><code>load_extension(extension)\n</code></pre> <p>Load a configured extension.</p> <p>Parameters:</p> <ul> <li> extension             (<code>str | dict[str, Any] | Extension | type[Extension]</code>)         \u2013 <p>An extension, with potential configuration options.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExtensionNotLoadedError</code>           \u2013         <p>When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extension</code>         \u2013 <p>An extension instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extension(extension: str | dict[str, Any] | Extension | type[Extension]) -&gt; Extension:\n\"\"\"Load a configured extension.\n\n    Parameters:\n        extension: An extension, with potential configuration options.\n\n    Raises:\n        ExtensionNotLoadedError: When the extension cannot be loaded,\n            either because the module is not found, or because it does not expose\n            the Extension attribute. ImportError will bubble up so users can see\n            the traceback.\n\n    Returns:\n        An extension instance.\n    \"\"\"\n    ext_object = None\n\n    if isinstance(extension, (VisitorExtension, InspectorExtension)):\n        return extension\n\n    if isclass(extension) and issubclass(extension, (VisitorExtension, InspectorExtension)):  # type: ignore[arg-type]\n        return extension()  # type: ignore[operator]\n\n    if isinstance(extension, dict):\n        import_path, options = next(iter(extension.items()))\n\n    else:  # we consider it's a string\n        import_path = str(extension)\n        options = {}\n\n    if import_path in builtin_extensions:\n        import_path = f\"griffe.extensions.{import_path}\"\n    elif os.path.exists(import_path):\n        try:\n            ext_object = _load_extension_path(import_path)\n        except ImportError as error:\n            raise ExtensionNotLoadedError(f\"Extension module '{import_path}' could not be found\") from error\n\n    if not ext_object:\n        try:\n            ext_object = dynamic_import(import_path)\n        except ModuleNotFoundError as error:\n            raise ExtensionNotLoadedError(f\"Extension module '{import_path}' could not be found\") from error\n        except ImportError as error:\n            raise ExtensionNotLoadedError(f\"Error while importing extension '{import_path}': {error}\") from error\n\n    if isclass(ext_object) and issubclass(ext_object, (VisitorExtension, InspectorExtension)):\n        return ext_object(**options)  # type: ignore[misc]\n\n    try:\n        return ext_object.Extension(**options)  # type: ignore[union-attr]\n    except AttributeError as error:\n        raise ExtensionNotLoadedError(f\"Extension module '{import_path}' has no 'Extension' attribute\") from error\n</code></pre>"},{"location":"reference/griffe/extensions/#griffe.extensions.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(exts)\n</code></pre> <p>Load configured extensions.</p> <p>Parameters:</p> <ul> <li> exts             (<code>Sequence[str | dict[str, Any] | Extension | type[Extension]]</code>)         \u2013 <p>A sequence of extension, with potential configuration options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>An extensions container.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extensions(exts: Sequence[str | dict[str, Any] | Extension | type[Extension]]) -&gt; Extensions:\n\"\"\"Load configured extensions.\n\n    Parameters:\n        exts: A sequence of extension, with potential configuration options.\n\n    Returns:\n        An extensions container.\n    \"\"\"\n    extensions = Extensions()\n    for extension in exts:\n        extensions.add(load_extension(extension))\n    return extensions\n</code></pre>"},{"location":"reference/griffe/extensions/base/","title":"base","text":"<p>This module contains the base classes for dealing with extensions.</p>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions","title":"Extensions","text":"<pre><code>Extensions(*extensions)\n</code></pre> <p>This class helps iterating on extensions that should run at different times.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>Extension</code>)         \u2013 <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self, *extensions: Extension) -&gt; None:\n\"\"\"Initialize the extensions container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    self._visitors: dict[When, list[VisitorExtension]] = defaultdict(list)\n    self._inspectors: dict[When, list[InspectorExtension]] = defaultdict(list)\n    self.add(*extensions)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_children_inspection","title":"after_children_inspection  <code>property</code>","text":"<pre><code>after_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_children_visit","title":"after_children_visit  <code>property</code>","text":"<pre><code>after_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_inspection","title":"after_inspection  <code>property</code>","text":"<pre><code>after_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run after the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.after_visit","title":"after_visit  <code>property</code>","text":"<pre><code>after_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run after the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_children_inspection","title":"before_children_inspection  <code>property</code>","text":"<pre><code>before_children_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the children inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_children_visit","title":"before_children_visit  <code>property</code>","text":"<pre><code>before_children_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the children visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_inspection","title":"before_inspection  <code>property</code>","text":"<pre><code>before_inspection: list[InspectorExtension]\n</code></pre> <p>Return the inspectors that run before the inspection.</p> <p>Returns:</p> <ul> <li> <code>list[InspectorExtension]</code>         \u2013 <p>Inspectors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.before_visit","title":"before_visit  <code>property</code>","text":"<pre><code>before_visit: list[VisitorExtension]\n</code></pre> <p>Return the visitors that run before the visit.</p> <p>Returns:</p> <ul> <li> <code>list[VisitorExtension]</code>         \u2013 <p>Visitors.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.add","title":"add","text":"<pre><code>add(*extensions)\n</code></pre> <p>Add extensions to this container.</p> <p>Parameters:</p> <ul> <li> *extensions             (<code>Extension</code>)         \u2013 <p>The extensions to add.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def add(self, *extensions: Extension) -&gt; None:\n\"\"\"Add extensions to this container.\n\n    Parameters:\n        *extensions: The extensions to add.\n    \"\"\"\n    for extension in extensions:\n        if isinstance(extension, VisitorExtension):\n            self._visitors[extension.when].append(extension)\n        else:\n            self._inspectors[extension.when].append(extension)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.attach_inspector","title":"attach_inspector","text":"<pre><code>attach_inspector(parent_inspector)\n</code></pre> <p>Attach a parent inspector to the inspector extensions.</p> <p>Parameters:</p> <ul> <li> parent_inspector             (<code>Inspector</code>)         \u2013 <p>The parent inspector, leading the inspection.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_inspector(self, parent_inspector: Inspector) -&gt; Extensions:\n\"\"\"Attach a parent inspector to the inspector extensions.\n\n    Parameters:\n        parent_inspector: The parent inspector, leading the inspection.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._inspectors:\n        for inspector in self._inspectors[when]:\n            inspector.attach(parent_inspector)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.Extensions.attach_visitor","title":"attach_visitor","text":"<pre><code>attach_visitor(parent_visitor)\n</code></pre> <p>Attach a parent visitor to the visitor extensions.</p> <p>Parameters:</p> <ul> <li> parent_visitor             (<code>Visitor</code>)         \u2013 <p>The parent visitor, leading the visit.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>Self, conveniently.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach_visitor(self, parent_visitor: Visitor) -&gt; Extensions:\n\"\"\"Attach a parent visitor to the visitor extensions.\n\n    Parameters:\n        parent_visitor: The parent visitor, leading the visit.\n\n    Returns:\n        Self, conveniently.\n    \"\"\"\n    for when in self._visitors:\n        for visitor in self._visitors[when]:\n            visitor.attach(parent_visitor)\n    return self\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension","title":"InspectorExtension","text":"<pre><code>InspectorExtension()\n</code></pre> <p>         Bases: <code>BaseInspector</code></p> <p>The object inspector extension base class, to inherit from.</p> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the inspector extension.\"\"\"\n    super().__init__()\n    self.inspector: Inspector = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension.attach","title":"attach","text":"<pre><code>attach(inspector)\n</code></pre> <p>Attach the parent inspector to this extension.</p> <p>Parameters:</p> <ul> <li> inspector             (<code>Inspector</code>)         \u2013 <p>The parent inspector.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, inspector: Inspector) -&gt; None:\n\"\"\"Attach the parent inspector to this extension.\n\n    Parameters:\n        inspector: The parent inspector.\n    \"\"\"\n    self.inspector = inspector\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.InspectorExtension.inspect","title":"inspect","text":"<pre><code>inspect(node)\n</code></pre> <p>Inspect a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ObjectNode</code>)         \u2013 <p>The node to inspect.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def inspect(self, node: ObjectNode) -&gt; None:\n\"\"\"Inspect a node.\n\n    Parameters:\n        node: The node to inspect.\n    \"\"\"\n    getattr(self, f\"inspect_{node.kind}\", lambda _: None)(node)\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension","title":"VisitorExtension","text":"<pre><code>VisitorExtension()\n</code></pre> <p>         Bases: <code>BaseVisitor</code></p> <p>The node visitor extension base class, to inherit from.</p> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def __init__(self) -&gt; None:\n\"\"\"Initialize the visitor extension.\"\"\"\n    super().__init__()\n    self.visitor: Visitor = None  # type: ignore[assignment]\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension.attach","title":"attach","text":"<pre><code>attach(visitor)\n</code></pre> <p>Attach the parent visitor to this extension.</p> <p>Parameters:</p> <ul> <li> visitor             (<code>Visitor</code>)         \u2013 <p>The parent visitor.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def attach(self, visitor: Visitor) -&gt; None:\n\"\"\"Attach the parent visitor to this extension.\n\n    Parameters:\n        visitor: The parent visitor.\n    \"\"\"\n    self.visitor = visitor\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.VisitorExtension.visit","title":"visit","text":"<pre><code>visit(node)\n</code></pre> <p>Visit a node.</p> <p>Parameters:</p> <ul> <li> node             (<code>ast.AST</code>)         \u2013 <p>The node to visit.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def visit(self, node: ast.AST) -&gt; None:\n\"\"\"Visit a node.\n\n    Parameters:\n        node: The node to visit.\n    \"\"\"\n    getattr(self, f\"visit_{node.kind}\", lambda _: None)(node)  # type: ignore[attr-defined]\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.When","title":"When","text":"<p>         Bases: <code>enum.Enum</code></p> <p>This enumeration contains the different times at which an extension is used.</p> <p>Attributes:</p> <ul> <li> before_all             (<code>int</code>)         \u2013 <p>For each node, before the visit/inspection.</p> </li> <li> before_children             (<code>int</code>)         \u2013 <p>For each node, after the visit has started, and before the children visit/inspection.</p> </li> <li> after_children             (<code>int</code>)         \u2013 <p>For each node, after the children have been visited/inspected, and before finishing the visit/inspection.</p> </li> <li> after_all             (<code>int</code>)         \u2013 <p>For each node, after the visit/inspection.</p> </li> </ul>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.load_extension","title":"load_extension","text":"<pre><code>load_extension(extension)\n</code></pre> <p>Load a configured extension.</p> <p>Parameters:</p> <ul> <li> extension             (<code>str | dict[str, Any] | Extension | type[Extension]</code>)         \u2013 <p>An extension, with potential configuration options.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExtensionNotLoadedError</code>           \u2013         <p>When the extension cannot be loaded, either because the module is not found, or because it does not expose the Extension attribute. ImportError will bubble up so users can see the traceback.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extension</code>         \u2013 <p>An extension instance.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extension(extension: str | dict[str, Any] | Extension | type[Extension]) -&gt; Extension:\n\"\"\"Load a configured extension.\n\n    Parameters:\n        extension: An extension, with potential configuration options.\n\n    Raises:\n        ExtensionNotLoadedError: When the extension cannot be loaded,\n            either because the module is not found, or because it does not expose\n            the Extension attribute. ImportError will bubble up so users can see\n            the traceback.\n\n    Returns:\n        An extension instance.\n    \"\"\"\n    ext_object = None\n\n    if isinstance(extension, (VisitorExtension, InspectorExtension)):\n        return extension\n\n    if isclass(extension) and issubclass(extension, (VisitorExtension, InspectorExtension)):  # type: ignore[arg-type]\n        return extension()  # type: ignore[operator]\n\n    if isinstance(extension, dict):\n        import_path, options = next(iter(extension.items()))\n\n    else:  # we consider it's a string\n        import_path = str(extension)\n        options = {}\n\n    if import_path in builtin_extensions:\n        import_path = f\"griffe.extensions.{import_path}\"\n    elif os.path.exists(import_path):\n        try:\n            ext_object = _load_extension_path(import_path)\n        except ImportError as error:\n            raise ExtensionNotLoadedError(f\"Extension module '{import_path}' could not be found\") from error\n\n    if not ext_object:\n        try:\n            ext_object = dynamic_import(import_path)\n        except ModuleNotFoundError as error:\n            raise ExtensionNotLoadedError(f\"Extension module '{import_path}' could not be found\") from error\n        except ImportError as error:\n            raise ExtensionNotLoadedError(f\"Error while importing extension '{import_path}': {error}\") from error\n\n    if isclass(ext_object) and issubclass(ext_object, (VisitorExtension, InspectorExtension)):\n        return ext_object(**options)  # type: ignore[misc]\n\n    try:\n        return ext_object.Extension(**options)  # type: ignore[union-attr]\n    except AttributeError as error:\n        raise ExtensionNotLoadedError(f\"Extension module '{import_path}' has no 'Extension' attribute\") from error\n</code></pre>"},{"location":"reference/griffe/extensions/base/#griffe.extensions.base.load_extensions","title":"load_extensions","text":"<pre><code>load_extensions(exts)\n</code></pre> <p>Load configured extensions.</p> <p>Parameters:</p> <ul> <li> exts             (<code>Sequence[str | dict[str, Any] | Extension | type[Extension]]</code>)         \u2013 <p>A sequence of extension, with potential configuration options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Extensions</code>         \u2013 <p>An extensions container.</p> </li> </ul> Source code in <code>src/griffe/extensions/base.py</code> <pre><code>def load_extensions(exts: Sequence[str | dict[str, Any] | Extension | type[Extension]]) -&gt; Extensions:\n\"\"\"Load configured extensions.\n\n    Parameters:\n        exts: A sequence of extension, with potential configuration options.\n\n    Returns:\n        An extensions container.\n    \"\"\"\n    extensions = Extensions()\n    for extension in exts:\n        extensions.add(load_extension(extension))\n    return extensions\n</code></pre>"},{"location":"reference/griffe/extensions/hybrid/","title":"hybrid","text":"<p>This extension provides an hybrid behavior while loading data.</p>"},{"location":"reference/griffe/extensions/hybrid/#griffe.extensions.hybrid.HybridExtension","title":"HybridExtension","text":"<pre><code>HybridExtension(extensions, object_paths=None)\n</code></pre> <p>         Bases: <code>VisitorExtension</code></p> <p>Inspect during a visit.</p> <p>This extension accepts the name of another extension (an inspector) and runs it appropriately. It allows to inspect objects after having visited them, so as to extract more data.</p> <p>Indeed, during the visit, an object might be seen as a simple attribute (assignment), when in fact it's a function or a class dynamically constructed. In this case, inspecting it will provide the desired data.</p> <p>Parameters:</p> <ul> <li> extensions             (<code>Sequence[str | dict[str, Any] | InspectorExtension | type[Extension]]</code>)         \u2013 <p>The names or configurations of other inspector extensions.</p> </li> <li> object_paths             (<code>Sequence[str | Pattern] | None</code>)         \u2013 <p>Optional list of regular expressions to match against objects paths, to select which objects to inspect.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ExtensionError</code>           \u2013         <p>When the passed extension is not an inspector extension.</p> </li> </ul> Source code in <code>src/griffe/extensions/hybrid.py</code> <pre><code>def __init__(\n    self,\n    extensions: Sequence[str | dict[str, Any] | InspectorExtension | type[Extension]],\n    object_paths: Sequence[str | Pattern] | None = None,\n) -&gt; None:\n\"\"\"Initialize the extension.\n\n    Parameters:\n        extensions: The names or configurations of other inspector extensions.\n        object_paths: Optional list of regular expressions to match against objects paths,\n            to select which objects to inspect.\n\n    Raises:\n        ExtensionError: When the passed extension is not an inspector extension.\n    \"\"\"\n    self._extensions: list[InspectorExtension] = [load_extension(ext) for ext in extensions]  # type: ignore[misc]\n    for extension in self._extensions:\n        if not isinstance(extension, InspectorExtension):\n            raise ExtensionError(\n                f\"Extension '{extension}' is not an inspector extension. \"\n                \"The 'hybrid' extension only accepts inspector extensions. \"\n                \"If you want to use a visitor extension, just add it normally \"\n                \"to your extensions configuration, without using 'hybrid'.\",\n            )\n    self.object_paths = [re.compile(op) if isinstance(op, str) else op for op in object_paths or []]\n    super().__init__()\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}